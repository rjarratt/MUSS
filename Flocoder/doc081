@X @~
~V7 56 2 -5
~D10
~H                    MUSS
~
~
~D10
~H             DOC081
~D10
~MMANCHESTER UNIVERSITY  -  CONFIDENTIAL
~
~
                                                             ISSUE 11~
~V9 -1
~P
~V9 1
~YDOC081
~S1~M~ODOCUMENTATION IMPLEMENTATION DESCRIPTION
~S1~M~OSection 8 Version 1
~S1~OSection 8.1 Interactive Flowchart Inspection and Editing
~S1~O1. General Description
~BThis module contains procedures for displaying and screen editing
a flowchart on a VDU. As it is not possible to display a great deal
on VDU's currently available a facility for moving the display around
the chart is incorporated. Editing of boxes and flowlines is catered
for but in some cases screen refreshment will be required to see the
new effect.
~BThe procedures in module 2, INPUT.TITLE and INPUT.CHART are used to
reduce the chart to tabular form and DRAW.CHART (Section 4) is called
in conjunction with the Lineprinter/VDU device driver (Section 7) to
produce output in a vector which is convenient for screen refreshment.
~S12. Interfaces~
~
~OModules Used~
   DOC021~
   DOC041~
   DOC071~
   EDT021~
~
~OProcedures~
   DISPLAY~
   SCROLL~
   LEVEL~
   FL.ED~
~Q 6
~
~OData Structures~
   PICVEC~
   LZERO~
   BTA~
   XDISP~
   YDISP~
~S1~O2.1 Hardware Interface
~BThe VDU is assumed to have 24 lines of 80 characters each.
~S1~O2.2 Software Interface
~BThis consists of the following procedures:~
~
~
1) DISPLAY(FILENAME,CHARTNAME,LEVEL)~
~BThis causes the specified chart in the specified file to appear on
the screen at the specified level. A negative value of level will display a
skeleton diagram with only the box numbers in boxes.~
~
~
2) SCROLL(DIRECTION,DISPLACEMENT)~
~BThis causes the display to move according to DIRECTION which is a
character input (R-Right, L-Left, U-Up, D-Down) by DISPLACEMENT
character positions. If DISPLACEMENT is zero the display will move to
the edge of the chart in the direction specified. If DIRECTION is zero
the display moves to the top left hand corner.~
~
~
3) LEVEL(BOXNO,LEVEL)
~BThis changes the contents displayed for box BOXNO to those at the
specified level. If BOXNO is negative all boxes are changed. If LEVEL
is negative the skeleton box is displayed.
~
~
4) FL.ED(INPUTFILE,OUTPUTFILE,DEVICE)~
~BThis allows editing of the input file of flowchart descriptions
to an output file of the same format with alterations to specified
charts. The command set within FLED allows a chart to be selected
by one command and changes to be made separately to columns, rows,
flow paths and box text at any level by other commands as described
in the User Manual. This is achieved in conjunction with a screen
display of the chart which moves off as new commands are typed
but which maybe refreshed by use of further commands.
Box text is altered by use of the screen editor VEDIT which has
its own command interface described in the USER Manual and requires
to know the control interface of the VDU (DEVICE) being used.
~S1~O3. Implementation
~S1~O3.1 Outline of Operation
~BDISPLAY uses INPUT.TITLE to locate the specified chart and INPUT.CHART
specifying both levels 0 and 1 to reduce it to tabular form. Since
DRAW.CHART operates on only one translation level at a time, with the
default being level 0, the entries for level 0 are saved to allow the
LEVEL procedure to overwrite the first level area of the box table
with whichever level is required. Since LEVEL also requires box
numbers to be available somewhere in the box text buffer these
are also stored when DISPLAY is called.
The entries required for the
skeleton chart structure are manufactured by DISPLAY also.
~BDRAW.CHART is called specifying the VDU device
type which puts its output in a vector
(the picture vector) rather than a conventional output stream. This
output has multiple spaces packed together looking like a tab
character followed by a number which is the number of spaces but with
the top bit set to avoid it looking like an ordinary character.
DISPLAY finally calls SCROLL to display the top lefthand of the chart.
This operates by scanning the picture vector and displaying the part
required on the screen.
~BFLED implements its command calls by a switch
on the first non-blank character typed after the
previous command. The 'T' command uses a
version of INPUT.TITLE which copies input to output
until a chart title is encountered. It returns the
value of the input pointer at the start of the title
line so that if the chart is faulty and cannot be
displayed the edit can continue from that point.
When the specified title is found the chart is
converted to tabular form and displayed at level -1 in the same
way as in the DISPLAY command described earlier.
The commands C, F, R and B cause the tabular
information to be altered (i.e. the box, column, row
and box text buffer) but no corresponding display
to appear. This can be explicitly caused by use of the
L command.
~BThe M command allows the text for a specified box at a
specified level to be altered by use of the simple screen
editor VEDIT. The text will appear in a window at the bottom
of the screen.
FLED copies the box text at the specified level from the BOX TEXT
BUFFER to the start of another byte vector called the BOX TEXT AREA
(BTA).  The remainder of this vector is the space available for
insertions when editing.  On completion, the edited text is again
situated at the start of the BTA and the result from VEDIT is the
size.  This text is copied to the next available area in the BTB having
first shifted the text at the end of the BTB backwards on top of the
original text of the specified box.  This necessitates that all
pointers to the text are adjusted appropriately.  Next the box table
entries for the specified box are updated with the new text pointer
value, box height and width.
If the 'Control E' exit from the vector editor was used the
chart will finally be redrawn at the original level but
with the specified box at the specified level.~
~BAnother T command or an E command causes the tabular
representation of the chart to be converted back into
a flowchart description and output instead of the
original version.
~BThe N command allows a new chart to be inserted. It
consists of a start box containing its heading. It will be
placed in the output file prior to the currently selected
chart unless that has been altered in which case it will
follow it.
~BFaults within FLED commands are monitored and a
message indicates how much of the insertion/deletion
was accomplished before the fault occurred.
~S1~O3.3 Data Structures
~T# 14
~
LZERO~IA vector containing all entries in the BOX TABLE relevant
to level 0 of the chart.~
~ILZPTR an integer pointing to the text for level 0 of a box
in the BTB.~
~ILZWTH an integer giving the width of the box.~
~ILZHT an integer giving the height of the box.~
~
XDISP,YDISP~IThe display coordinates record the current
position of the first character to be displayed on the screen
in terms of character position on a
line and number of lines from the start of the picture vector.~
~
~
BTA~IThe Box Text Area is a byte vector holding the box text for
use by the simple screen editor.~
~Y
~V9 -1
~P
~D15
~HFLOWCHARTS
~
~
~H                DOC081
~V9 -1
~F
@TITLE DOC08(1,9)
@COL 1S-2R-3R-4R-5R-6F
@FLOW 1-2-3-4-5-6
@BOX 1.0
INTERACTIVE DRAW
@BOX 2.0
@BOX 3.0
@BOX 4.0
PROCEDURES IN MODULE
   DISPLAY [DOC08.1]
   SCROLL [DOC08.2]
LEVEL[DOC08.3]
FLED[DOC08.4]
@BOX 5.0
#DOC08.1
#DOC08.2
#DOC08.3
#DOC08.4
@BOX 6.0
END
@BOX 1.1
#DOC08/1
MODULE (DISPLAY,SCROLL,LEVEL,FLED);
::MU6 *GLOBAL 3;
::MC68000 *GLOBAL 3;
*GLOBAL 2;
TYPE LZSPECS IS $IN LZPTR $LO8 LZHT,LZWTH;
$LO8[7164]DUMMYB;
$IN XDISP,YDISP;
$LO8[2048]BTA;
LZSPECS[64] LZERO;
$LI ESC = %1B;
*GLOBAL 0;
@BOX 2.1
@BOX 3.1
@BOX 4.1
LSPEC DISPLAY($AD[$LO8],ADDR[$LO8],$IN);
LSPEC SCROLL($LO64,$IN);
LSPEC LEVEL($IN,$IN);
LSPEC FLED($AD[$LO8],$AD[$LO8],$IN);
$PS ORGANISE.TABLES();
$PS REFRESH.SCREEN();
#DOC08.1
#DOC08.1.1
#DOC08.2
#DOC08.2.1
#DOC08.3
#DOC08.4
@BOX 6.1
*END
@END
@TITLE DOC08/1(1,11)
@COL 1S-2R-3F
@FLOW 1-2-3
@BOX 1.0
EXTERNAL ENVIRONMENT
@BOX 2.0
EXTERNAL PROCS
@BOX 3.0
END
@BOX 1.1
::EXTERNALS
@BOX 2.1
$LS CURRENT.INPUT()/$IN; $LS CURRENT.OUTPUT()/$IN;
$LS DEFINE.INPUT($IN,$AD[$LO8],$IN32)/$IN;
$LS DEFINE.OUTPUT($IN,$AD[$LO8],$IN32,$IN32)/$IN;
$LS SELECT.INPUT($IN);$LS SELECTOUTPUT($IN);
$LS END.INPUT($IN,$IN);
$LS ENDOUTPUT($IN,$IN);$LS IENQ()/$IN;
$LS INCH()/$IN;$LS INI()/ADDR;
$LS OUTCH($IN);$LS SPACES($IN);
$LS OUTI($IN32,$IN);
$LS BREAKOUTPUT($IN);
$LS NEWLINES($IN);$LS CAPTION($AD[$LO8]);
$LS IPOS()/$IN32;$LS SET.IPOS($IN32);
$LS OPOS()/$IN32;$LS SET.OPOS($IN32);
$LS INSTR($AD[$LO8])/$IN;
$LS CREATE.SEGMENT($IN,$AD);
$LS RELEASE.SEGMENT($IN);
$LS INTERCHANGE($IN,$IN);
$LS PROMPT($AD[$LO8]);
$LS ISIZE()/$IN32;
$LS MAP($IN,$IN,$IN);
$LS VEDIT($AD[$LO8],$IN,$IN,$IN)/$IN;
::MU6 $PS INPUT.CHART($IN,$IN,$IN)/$IN;
::MU6 $PS INPUT.TITLE($AD[$LO8],$IN)/$IN32;
$LS INPUT.CHART($IN,$IN,$IN)/$IN;
$LS INPUT.TITLE($AD[$LO8],$IN)/$IN32;
::MC68000 $PS INPUT.CHART($IN,$IN,$IN)/$IN;
::MC68000 $PS INPUT.TITLE($AD[$LO8],$IN)/$IN32;
::MU6 $PS DRAW.CHART($IN,$IN);
::MC68000 $PS DRAW.CHART($IN,$IN);
$LS DRAW.CHART($IN,$IN);
TYPE BOXSPECS IS $IN COL.LINK,ROWLINK,PFLOW.LINK,YCOORD
$IN SFLOWLINK,TEXT.PTR,PFLOW.TEXT,SFLOW.TEXT,HT,TEXTPTR1
$LO8 T,BOXHT,BOXWTH,COL,INFLOW,LAB.COUNT,PLANTED,YFIXED,BOXHT1,BOXWTH1;
BOXSPECS[64] BOXTAB;$IN[8] COLTAB;
$LO8[8192] BTB;$LO8[64] TBUFF;
::MU6 $LO8[32000] PICVEC;
::MC68000 $LO8[32000] PICVEC;
$LO8[5688] PICVEC;
$LO8[10] DATESTR;
$IN MAXX,MINY,PHGT,BOXLIMIT,ROWLIMIT,COLIMIT,PICPTR,BTBPTR;
$AD PW0,PW1;
$IM$LI MINX,MAXY;
$IM$LI EOBWC,CRWC,PWC;
::MU6 $IM$LI WORKSEG;
@BOX 3.1
::END
@END
@TITLE DOC08.1(1,9)
@COL 12R
@COL 1S-2R-3R-4T-5R-6T-7R-8R-10R-11F
@COL 13R
@ROW 12-8-13
@FLOW 1-2-3-4Y-5-6N-7-8-10-11
@FLOW 4N-12-10
@FLOW 6Y-13-10
@BOX 1.0
DISPLAY(INPUT FILE,CHART TITLE,LEVEL)
@BOX 2.0
INITIALISE INPUT AND OUTPUT
@BOX 3.0
SEARCH INPUT FOR SPECIFIED
CHART TITLE [DOC02.1]
@BOX 4.0
FOUND?
@BOX 5.0
READ CHART DESCRIPTION TO FORM
BOX TEXT BUFFER,BOX,ROW AND
COLUMN TABLES[DOC02.2]
@BOX 6.0
CHART FAULTY?
@BOX 7.0
FORM SEPARATE LEVEL 0 TABLE
CREATE SKELETON DATA IN BOXTABLE
[DOC08.1.1]
@BOX 8.0
SELECT SPECIFIED LEVEL OF CHART
GENERATE CHART OUTPUT FOR
VDU IN PICTURE VECTOR
SCROLL TOP LEFT OF CHART
[DOC08.3]
@BOX 10.0
RESTORE INPUT AND OUTPUT
@BOX 11.0
END
@BOX 12.0
MONITOR - CHART NOT FOUND
@BOX 13.0
MONITOR - CHART FAULTY
CANNOT DISPLAY
@BOX 1.1
PROC DISPLAY(FILE,CHART,LEV);
$IN ERR,OLDIN,I;
::MU6 CREATESEGMENT(-1,%10000);INTERCHANGE(PW1,WORKSEG);
::MC68000 RELEASE.SEGMENT(48);CREATESEGMENT(48,%4000);
::MC68000 RELEASESEGMENT(49);CREATESEGMENT(49,%4000);
::MC68000 RELEASESEGMENT(50);CREATESEGMENT(50,%4000);
::MC68000 RELEASESEGMENT(51);CREATESEGMENT(51,%4000);
::MC68000 MAP(48,-1,0);MAP(49,-1,0);MAP(50,-1,0);MAP(51,-1,0);
CREATESEGMENT(30,%2000);MAP(30,5,1);
CREATESEGMENT(31,%2000);MAP(31,6,1);
@BOX 2.1
CURRENT.INPUT() => OLDIN;
SELECT.INPUT(DEFINE.INPUT(-1,FILE,0));
@BOX 3.1
NEXT.T:
IF INPUT.TITLE(^TBUFF,1) => ERR = 0, -> OUT;
FOR I < SIZE(CHART)DO
   IF CHART^[I] /= TBUFF[I], -> NEXT.T;
OD
IF TBUFF[I] /= '$L /= '(, -> NEXT.T;
OUT:
@BOX 4.1
IF ERR = 0
@BOX 5.1
INPUT.CHART(0,1,0) => ERR;
1 +> BOXLIMIT;
@BOX 6.1
IF ERR < 0
@BOX 7.1
ORGANISE.TABLES();
@BOX 8.1
LEVEL(-1,LEV);
@BOX 10.1
SELECT.INPUT(OLDIN);
@BOX 11.1
END
@BOX 12.1
CAPTION(%"$L CHART NOT FOUND$L");
@BOX 13.1
CAPTION(%"$L CHART FAULTY - CANNOT DISPLAY$L");
@END
@TITLE DOC08.1.1(1,9)
@COL 1S-3R-4R-6F
@FLOW 1-3-4-6
@BOX 1.0
ORGANISE CHART TABLES
@BOX 3.0
COPY ALL BOX TABLE VALUES FOR
THE FIRST LEVEL TO THE LZERO TABLE
@BOX 4.0
WRITE SKELETON DATA TO
BOX TEXT BUFFER
@BOX 6.0
END
@BOX 1.1
PROC ORGANISE.TABLES;
$IN BOX,I,J,K;
$DA N1($LO8)
'N 'U 'L 'L '$L 254
END
$DA N2($LO8)
'A 'N 'N 'O 'T '$L 254
END
$DA N3($LO8)
'S 'T 'A 'R 'T '$L 254
END
$DA N4($LO8)
'R 'E 'C 'T '$L 254
END
$DA N5($LO8)
'T 'E 'S 'T '$L 254
END
$DA N6($LO8)
'F 'I 'N 'I 'S 'H '$L 254
END
$DA N7($LO8)
'C 'I 'R 'C 'L 'E '$L 254
END
$DA BNAMES($AD[$LO8])
N1 N2 N3 N4 N5 N6 N7
END
@BOX 3.1
FOR BOX < BOXLIMIT DO
   TEXTPTR OF BOXTAB[BOX] => LZPTR OF LZERO[BOX];
   BOXHT OF BOXTAB[BOX] => LZHT OF LZERO[BOX];
   BOXWTH OF BOXTAB[BOX] => LZWTH OF LZERO[BOX];
OD
@BOX 4.1
FOR J < 7 DO
   -1=>K;
   J + 1 * 8 -1 => I;
   WHILE BNAMES[J]^[1+>K]=>BTB[1+>I] /= EOBWC DO OD
OD
@BOX 6.1
END
@END
@TITLE DOC08.2(1,9)
@COL 1S-2T-3R-4R-5F
@COL 6R
@ROW 3-6
@FLOW 1-2Y-3-4-5
@FLOW 2N-6-4
@BOX 1.0
SCROLL(DIRECTION,DISTANCE)
@BOX 2.0
SCROLL RESET TO TOP LEFT CORNER?
@BOX 3.0
RESET DISPLAY COORDINATES
@BOX 4.0
REFRESH SCREEN [DOC08.2.1]
@BOX 5.0
END
@BOX 6.0
SET DISPLAY COORDINATES
FROM DIRECTION AND DISTANCE
@BOX 1.1
PROC SCROLL(DIRN,DIST);
$IN I;
$DA DIR($LO8);
'D 'R 'L 'U
END
MAP(30,5,1);
MAP(31,6,1);
@BOX 2.1
IF DIRN /= 0
@BOX 3.1
0 => XDISP => YDISP;
@BOX 4.1
REFRESH.SCREEN();
@BOX 5.1
END
@BOX 6.1
IF DIST = 0 THEN
   1000 => DIST;
FI
FOR I < 4 DO
   IF DIRN = DIR[I], -> OUT;
OD
OUT:
ALTERNATIVE I FROM
BEGIN
IF DIST -> YDISP < 0 THEN
   0 => YDISP;
FI
END
BEGIN
IF DIST -> XDISP < 0 THEN
   0 => XDISP;
FI
END
BEGIN
IF DIST +> XDISP + 80*2 > MAXX THEN
   MAXX/2 - 80 => XDISP;
FI
END
BEGIN
IF DIST +> YDISP + 23*2 > (MAXY-MINY) THEN
   MAXY-MINY/2 - 23 => YDISP;
FI
END
BEGIN
0 => XDISP => YDISP;
END
END
@END
@TITLE DOC08.2.1(1,9)
@COL 1S-2R-3R-4R-5R-6R-7T-8F
@FLOW 1-2-3-4-5-6-7Y-8
@FLOW 7N-4
@BOX 1.0
REFRESH SCREEN
@BOX 2.0
SET PICTURE VECTOR
POINTER TO START
@BOX 3.0
SKIP THROUGH PICTURE VECTOR
TO FIRST LINE TO BE DISPLAYED
@BOX 4.0
SKIP THROUGH THIS LINE UNTIL
FIRST CHARACTER TO BE DISPLAYED
@BOX 5.0
OUTPUT CHARACTERS TO FILL
LINE ON SCREEN
@BOX 6.0
SKIP TO END OF LINE
@BOX 7.0
SCREEN FULL OR END OF OUTPUT?
@BOX 8.0
END
@BOX 1.1
PROC REFRESH.SCREEN;
$IN I,K,J,CH,TDISP,M;
$LI TAB=9;
@BOX 2.1
-1 => I;
@BOX 3.1
FOR YDISP DO
   WHILE PICVEC[1+>I] /= '$L DO OD
OD
0 => K;
@BOX 4.1
0 => M;
FOR J < XDISP DO
   IF PICVEC[1+>I] => CH = TAB THEN
      PICVEC[1+>I] & %7F +>J;
      IF J > XDISP THEN
         SPACES(J-XDISP=>M);
      FI
      1 -> J;
   FI
OD
@BOX 5.1
WHILE 1+>M < 81 DO
   IF PICVEC[1+>I] => CH = '$L, -> OUT;
   IF CH = TAB THEN
      IF PICVEC[1+>I] & %7F => TDISP +> M > 80, -> OUT;
      SPACES(TDISP);
   ELSE
      OUTCH(CH);
   FI
OD
OUT:
@BOX 6.1
IF CH /= '$L THEN
   WHILE PICVEC[1+>I] /= '$L DO OD
FI
OUTCH(%D); OUTCH(%A);
@BOX 7.1
IF 1+>K < 24 AND I < PICPTR
@BOX 8.1
END
@END
@TITLE DOC08.3(1,9)
@COL 1S-2T-3R-4T-5R-6T-7R-8R-9F
@COL 10R-11T-12R-13R
@ROW 3-10
@ROW 5-11
@FLOW 1-2Y-3-4Y-5-6NONE-7-8-9
@FLOW 2N-10-4N-11Y-12-6OK-4
@FLOW 11N-13-6
@BOX 1.0
LEVEL(BOX,LEVEL)
@BOX 2.0
ALL BOXES TO BE CHANGED?
@BOX 3.0
STARTING WITH BOX 1 AND
CONSIDERING ALL BOXES
@BOX 4.0
CHANGE TO LEVEL 0?
@BOX 5.0
OVERWRITE FIRST LEVEL OF BOX
TABLE FOR THE CURRENT BOX
WITH LEVEL 0 VALUES
@BOX 6.0
SELECT NEXT BOX
@BOX 7.0
GENERATE CHART OUTPUT FOR VDU
IN PICTURE VECTOR[DOC04.2]
@BOX 8.0
SCROLL TOP LEFT OF CHART
[DOC08.2]
@BOX 9.0
END
@BOX 10.0
STARTING WITH SPECIFIED BOX
AND ONLY THAT BOX
@BOX 11.0
CHANGE TO LEVEL 1?
@BOX 12.0
OVERWRITE FIRST LEVEL OF BOX
TABLE FOR THE CURRENT BOX
WITH LEVEL 1 VALUES
@BOX 13.0
OVERWRITE FIRST LEVEL OF BOX
TABLE FOR THE CURRENT BOX
WITH SKELETON VALUES
@BOX 1.1
PROC LEVEL(BOX,LEV);
$IN COUNT,I;
MAP(30,5,1);
MAP(31,6,1);
@BOX 2.1
IF BOX > 0
@BOX 3.1
1 => BOX;
64 => COUNT;
@BOX 4.1
IF LEV / = 0
@BOX 5.1
LZPTR OF LZERO[BOX] => TEXTPTR OF BOXTAB[BOX];
LZHT OF LZERO[BOX] => BOXHT OF BOXTAB[BOX];
LZWTH OF LZERO[BOX] => BOXWTH OF BOXTAB[BOX];
@BOX 6.1
IF 1 +> BOX < COUNT
@BOX 7.1
DRAW.CHART(0,LEV&1);
@BOX 8.1
SCROLL(0,0);
@BOX 9.1
END
@BOX 10.1
0 => COUNT;
@BOX 11.1
IF LEV /= 1
@BOX 12.1
TEXTPTR1 OF BOXTAB[BOX] => TEXTPTR OF BOXTAB[BOX];
BOXHT1 OF BOXTAB[BOX] => BOXHT OF BOXTAB[BOX];
BOXWTH1 OF BOXTAB[BOX] => BOXWTH OF BOXTAB[BOX];
@BOX 13.1
T OF BOXTAB[BOX]*8 => TEXTPTR OF BOXTAB[BOX];
1 => BOXHT OF BOXTAB[BOX];
6 => BOXWTH OF BOXTAB[BOX];
@END
@TITLE DOC08.4(1,9)
@COL 7C-10R-5C-6R-8C-9R-11C-12R-14F
@COL 1S-2R-35R-3R-4R-15C-16R-18C-19R-21C-22R
@COL 25C-26R-28C-29R-31C-32R
@ROW 7-3
@ROW 5-15-25
@ROW 8-18-28
@ROW 11-21-31
@FLOW 1-2-35-3-4
@FLOW 7-10-4
@FLOW 5-6-4
@FLOW 15-16-4
@FLOW 25-26-4
@FLOW 28-29-4
@FLOW 18-19-4
@FLOW 8-9-4
@FLOW 31-32-4
@FLOW 21-22-4
@FLOW 11-12-14
@BOX 1.0
FLOCODE EDITOR
@BOX 2.0
INITIALISE INPUTS AND OUTPUTS
SELECT FILE INPUT AND OUTPUT
@BOX 35.0
COPY FROM INPUT TO OUTPUT UNTIL
FIRST TITLE OR END OF FILE
NOTE INPUT POINTER VALUE
@BOX 3.0
RESTORE ORIGINAL I/O
SET NO CHART SELECTED
@BOX 4.0
SWITCH ON NEXT COMMAND
@BOX 7.0
N
@BOX 10.0
INSERT CHART
[DOC08.4.8]
@BOX 5.0
T
@BOX 6.0
LOCATE CHART
[DOC08.4.1]
@BOX 8.0
C
@BOX 9.0
INSERT COLUMN
[DOC08.4.2]
@BOX 11.0
E
@BOX 12.0
END EDIT
[DOC08.4.7]
@BOX 14.0
END
@BOX 15.0
S
@BOX 16.0
READ PARAMETERS AND
CALL SCROLL [DOC08.2]
@BOX 18.0
R
@BOX 19.0
INSERT/DELETE ROW
[DOC08.4.3]
@BOX 21.0
B
@BOX 22.0
INSERT/DELETE BOXES
[DOC08.4.6]
@BOX 25.0
L
@BOX 26.0
READ PARAMETERS AND
CALL LEVEL[DOC08.3]
@BOX 28.0
F
@BOX 29.0
INSERT/DELETE FLOW
[DOC08.4.4]
@BOX 31.0
M
@BOX 32.0
MODIFY BOX TEXT
[DOC08.4.5]
@BOX 1.1
PROC FLED(INFILE,OUTFILE,DEVICE);
$IN OLDIN,OLDOUT,CURIN,CUROUT,ERR,TITSIZE,I,J,K,M,N,CH,DIST;
$IN IND,FIRST,LAST,BNOLIM,COLNO,PREVBOX,PFLOW,SFLOW,FCAP;
$IN TEMP,SELECTED,ALTERED,WTH,MAXWTH,NLS,TEXTEND;
$IN BOX,LEV,DSEG1;
$IN32 INP,OUTP;
$LO DIRN;
$LO8[32] TITLE;
$LO8[4] FBSTR,LBSTR;
$LO8[64] MODSTR,SAV1,SAV2;
$IN[64] SAV3,SAV4,SAV5,SAV6;
$DA TYPES($LO8)
0 'N 'A 'S 'R 'T 'F 'C
END
$DA ARROW($LO8);
'-'>
END
$LI START=3,TEST=5
$PS INSERT.BOXES($IN,$IN)/$IN;
$PS FORM.STRINGS();
$PS READ.BOX($AD[$LO8],$IN)/$IN;
$PS READ.TYPE()/$IN;
$PS OUTPUT.CURRENT.CHART();
::MU6 CREATE.SEGMENT(-1,%10000);INTERCHANGE(PW1=>DSEG1,WORKSEG);
::MC68000 RELEASESEGMENT(48);CREATESEGMENT(48,%4000);
::MC68000 RELEASESEGMENT(49);CREATESEGMENT(49,%4000);
::MC68000 RELEASESEGMENT(50);CREATESEGMENT(50,%4000);
::MC68000 RELEASESEGMENT(51);CREATESEGMENT(51,%4000);
::MC68000 MAP(48,-1,0);MAP(49,-1,0);MAP(50,-1,0);MAP(51,-1,0);
CREATESEGMENT(30,%2000);MAP(30,5,1);
CREATESEGMENT(31,%2000);MAP(31,6,1);
@BOX 2.1
CURRENT.INPUT() => OLDIN;
CURRENT.OUTPUT() => OLDOUT;
SELECTINPUT(DEFINE.INPUT(-1,INFILE,0) => CURIN);
SELECTOUTPUT(DEFINE.OUTPUT(-1,OUTFILE,0,ISIZE()*3->>1) => CUROUT);
@BOX 35.1
IF INPUT.TITLE(^TBUFF,2) => INP = 0 THEN
   IPOS() => INP;
ELSE
   SET.IPOS(INP);
FI
@BOX 3.1
SELECTINPUT(OLDIN);
SELECTOUTPUT(OLDOUT);
0 => SELECTED;
@BOX 4.1
NEXT.COM:
WHILE INCH() => CH < %21 DO OD
IF CH < 'A OR CH > 'Z, -> IGN;
SWITCH CH - "A" \ IGN,LB,LC,IGN,LE,
LF,IGN,IGN,IGN,IGN,IGN,LL,LM,LN,
IGN,IGN,IGN,LR,LS,LT,IGN,IGN,IGN,
IGN,IGN,IGN;
IGN: WHILE INCH() /= '$L DO OD
-> NEXT.COM;
@BOX 7.1
LN:
@BOX 10.1
#DOC08.4.8
@BOX 5.1
LT:
@BOX 6.1
#DOC08.4.1
@BOX 8.1
LC:
@BOX 9.1
#DOC08.4.2
@BOX 11.1
LE:
@BOX 12.1
#DOC08.4.7
::MU6 INTERCHANGE(WORKSEG,DSEG1);RELEASE.SEGMENT(DSEG1);
::MC68000 RELEASESEGMENT(48);RELEASESEGMENT(49);
::MC68000 RELEASESEGMENT(50);RELEASESEGMENT(51);
RELEASESEGMENT(30);RELEASESEGMENT(31);
@BOX 14.1
END
@BOX 15.1
LS:
@BOX 16.1
WHILE INCH() => DIRN < %21 DO OD
INI() => DIST;
SCROLL(DIRN,DIST);
@BOX 18.1
LR:
@BOX 19.1
#DOC08.4.3
@BOX 21.1
LB:
@BOX 22.1
#DOC08.4.6
@BOX 25.1
LL:
@BOX 26.1
INI() => BOX;
INI() => LEV;
LEVEL(BOX,LEV);
@BOX 28.1
LF:
@BOX 29.1
#DOC08.4.4
@BOX 31.1
LM:
@BOX 32.1
#DOC08.4.5
@END
@TITLE DOC08.4.1(1,9)
@COL 14R
@COL 1S-12R-17R-3R-20R-4R-5T-7T-18R-6R-8R-9T-10R-11R-19R-13F
@COL 15R-16R
@ROW 14-11-15
@FLOW 1-12-17-3-20-4-5Y-7Y-6-8-9N-10-11-19-13
@FLOW 7N-18-4
@FLOW 5N-14-19
@FLOW 9Y-15-16-19
@BOX 1.0
T(TITLE)
@BOX 3.0
OUTPUT CURRENT CHART
[DOC08.4.7.1]
@BOX 20.0
NOTE OUTPUT POINTER VALUE
@BOX 4.0
COPY INPUT TO OUTPUT UNTIL
A TITLE IS ENCOUNTERED
[DOC02.1]
@BOX 5.0
FOUND?
@BOX 6.0
STORE I/O POINTERS
@BOX 7.0
IS THIS THE REQUIRED TITLE?
@BOX 18.0
OUTPUT TITLE
@BOX 8.0
READ CHART DESCRIPTION TO FORM
BOX TEXT BUFFER, BOX, ROW AND
COLUMN TABLES [DOC02.2]
NOTE BOX NUMBER LIMIT
SELECT OUTPUT 0
@BOX 9.0
CHART FAULTY?
@BOX 10.0
SET CHART SELECTED AND ALTERED
FORM SEPARATE LEVEL 0 TABLE
CREATE SKELETON DATA IN BOX TEXT BUFFER
[DOC08.1.1]
@BOX 11.0
SELECT LEVEL -1 OF CHART
GENERATE OUTPUT FOR SKELETON CHART
FOR A VDU IN THE PICTURE VECTOR
SCROLL TOP LEFT OF CHART[DOC08.3]
@BOX 12.0
READ THE REQUESTED TITLE
FROM STREAM 0
@BOX 13.0
END
@BOX 14.0
RESET I/O POINTERS
FAULT MONITOR ON
STREAM 0 - CHART
NOT FOUND
@BOX 15.0
RESET INPUT POINTER
TO START OF CHART
@BOX 16.0
FAULT MONITOR - CHART
FAULTY CANNOT DISPLAY
@BOX 17.0
SELECT FILE INPUT STREAM
SELECT FILE OUTPUT STREAM
@BOX 19.0
RESTORE INPUT STREAM 0
@BOX 1.1
::LOCATE CHART
@BOX 3.1
OUTPUT.CURRENT.CHART();
@BOX 20.1
IPOS()=>INP;OPOS()=>OUTP;
@BOX 4.1
INPUT.TITLE(^TBUFF,2) => ERR;
@BOX 5.1
IF ERR = 0
@BOX 6.1
ERR => INP;
OPOS() => OUTP;
@BOX 7.1
FOR I < TIT.SIZE DO
   IF TITLE[I] /= TBUFF[I] ,->MISS;
OD
IF TBUFF[I] = '$L OR TBUFF[I] = '( @>>
MISS:
@BOX 18.1
CAPTION(%"@TITLE ");
-1 => I;
WHILE TBUFF[1+>I] => CH /= '$L DO
   OUTCH(CH);
OD
NEWLINES(1);
@BOX 8.1
INPUT.CHART(0,1,0) => ERR;
1 +> BOXLIMIT=>BNOLIM;
SELECTOUTPUT(OLDOUT);
@BOX 9.1
IF ERR < 0
@BOX 10.1
1 => SELECTED;0 => ALTERED;

ORGANISE.TABLES();
@BOX 11.1
LEVEL(-1,-1);
@BOX 12.1
INSTR(^TITLE) => TITSIZE;
@BOX 13.1
::END
@BOX 14.1
SET.IPOS(INP);
SET.OPOS(OUTP);
SELECTOUTPUT(OLDOUT);
CAPTION(%"CHART NOT FOUND");
@BOX 15.1
SET.IPOS(INP);
@BOX 16.1
CAPTION(%"CHART FAULTY - CANNOT DISPLAY");
@BOX 17.1
SELECTINPUT(CURIN);
SELECTOUTPUT(CUROUT);
@BOX 19.1
SELECTINPUT(OLDIN);
@END
@TITLE DOC08.4.2(1,9)
@COL 1S-2R-3T-4T-5R-6R-7R-8R-9T-10R-11N-12F
@COL 13T-14R-15R-16N
@ROW 4-13
@ROW 10-15
@FLOW 1-2-3Y-4OK-5-6-7-8-9N-10-11-12
@FLOW 3N-13OK-14-6
@FLOW 4FAULTY-11
@FLOW 13FAULTY-16
@FLOW 9Y-15-16-11-12
@BOX 1.0
C
@BOX 2.0
READ LINE AND STORE AS FIRST
AND LAST BOX STRINGS AND
MODIFICATION BOX STRING
[DOC08.4.2.2]
@BOX 3.0
FIRST BOX SPECIFIED?
@BOX 4.0
READ FIRST BOX
[DOC08.4.3.3]
@BOX 16.0
DEFINED?
@BOX 5.0
SET NEW COLUMN NO TO ONE
MORE THAN FOR THE FIRST BOX
@BOX 6.0
STORE ALL BOX AND COLUMN
TABLES ENTRIES WHICH MAY
BE CHANGED
@BOX 7.0
SHIFT COLUMNS RIGHT TO
MAKE SPACE FOR NEW COLUMN
ADJUST COLUMN NO VALUES
IN BOX TABLE ENTRIES
@BOX 8.0
INSERT NEW COLUMN
[DOC08.4.2.1]
@BOX 9.0
FAULTY?
@BOX 10.0
INCREMENT NO OF COLUMNS
@BOX 12.0
END
@BOX 13.0
READ LAST BOX
[DOC08.4.3.3]
@BOX 17.0
DEFINED?
@BOX 14.0
SET NEW COLUMN NO TO
SAME AS FOR LAST BOX
@BOX 15.0
RESTORE ORIGINAL COLUMN
AND BOX TABLE ENTRIES
@BOX 1.1
::INSERT COLUMN
#DOC08.4.2.1
#DOC08.4.2.2
#DOC08.4.2.3
#DOC08.4.2.4
@BOX 2.1
FORM.STRINGS();
@BOX 3.1
IF FBSTR[0] = 0
@BOX 4.1
-1 => IND;
IF READBOX(^FBSTR,0) => FIRST < 0
@BOX 5.1
COL OF BOXTAB[FIRST]+1 => COLNO;
@BOX 16.1
IF T OF BOXTAB[FIRST] = 0
1+COL OF BOXTAB[FIRST] => COLNO;
@BOX 6.1
FOR I < 64 DO
   COL OF BOXTAB[I] => SAV1[I];
   T OF BOXTAB[I] => SAV2[I];
   COL.LINK OF BOXTAB[I] => SAV3[I];
OD
FOR I < 8 DO
   COLTAB[I] => SAV4[I];
OD
@BOX 7.1
COLIMIT => I;
WHILE 1->I >= COLNO DO
   COLTAB[I] => COLTAB[I+1] => J;
   I+1 => COL OF BOXTAB[J];
   WHILE COL.LINK OF BOXTAB[J] => J /= 0 DO
      I+1 => COL OF BOXTAB[J];
   OD
OD
@BOX 8.1
INSERT.BOXES(COLNO,0) => ERR;
@BOX 9.1
IF ERR < 0
@BOX 10.1
1 +> COLIMIT;
@BOX 12.1
::END
@BOX 13.1
-1 => IND;
IF READ.BOX(^LBSTR,0) => LAST < 0
@BOX 14.1
IF T OF BOXTAB[LAST] = 0
@BOX 14.1
COL OF BOXTAB[LAST] => COLNO;
@BOX 15.1
FOR I < 64 DO
   SAV1[I] => COL OF BOXTAB[I];
   SAV2[I] => T OF BOXTAB[I];
   SAV3[I] => COL.LINK OF BOXTAB[I];
OD
FOR I < 8 DO
   SAV4[I] => COLTAB[I];
OD
@END
@TITLE DOC08.4.2.1(1,9)
@COL 11R
@COL 1S-2T-3R-4T-5R-6T-7R-12R-8T-14T-15R-9R-10F
@COL 13R
@ROW 11-3
@ROW 9-13
@FLOW 1-2Y-3-4OK-5-12-8N-14N-15-13-10
@FLOW 2N-11-6OK-7-12
@FLOW 11
@FLOW 8Y-6
@FLOW 14Y-9-10
@FLOW 4FAULT-13
@FLOW 6FAULT-13
@BOX 1.0
INSERT BOXES (COLUMN NO, FIRST BOX)
@BOX 2.0
IS A NEW COLUMN TO
BE INSERTED?
@BOX 3.0
TREAT LAST BOX IN COLUMN
AS ZERO
@BOX 4.0
READ BOX NO AND TYPE
FROM MODIFICATION STRING
@BOX 5.0
STORE BOX NO AS TOP COLUMN
STORE TYPE AND COLUMN NO FOR BOX
@BOX 6.0
READ NEXT BOX AND TYPE
@BOX 7.0
STORE BOX NO AS COLUMN LINK
FOR PREVIOUS BOX
STORE TYPE AND COLUMN NO
STORE NULL BOX TEXT IN BTB
SET TEXT POINTERS,HEIGHT AND
WIDTH FOR LEVELS 0 AND 1
@BOX 8.0
ANY MORE BOXES IN STRING?
@BOX 9.0
STORE LAST BOX AS FINAL COLUMN LINK
NOTE BOX NUMBER LIMIT
SET CHART ALTERED
SET RESULT TO SUCCESS
@BOX 10.0
END
@BOX 11.0
TREAT COLUMN LINK OF FIRST
BOX AS LAST BOX
TREAT FIRST BOX AS PREVIOUS BOX
@BOX 12.0
MAKE CURRENT BOX
THE PREVIOUS BOX
@BOX 13.0
SET RESULT TO FAULTY
@BOX 14.0
NEXT NON-BLANK A MINUS?
@BOX 15.0
OUTPUT - ILLEGAL FORMAT
@BOX 1.1
PROC INSERT.BOXES(COLNO,FBOX);
$IN LBOX,BOX,BTYPE,PREV.BOX;
-1 => IND;
@BOX 2.1
IF FBOX /= 0
@BOX 3.1
0 => LBOX;
@BOX 4.1
IF READ.BOX(^MODSTR,1) => BOX < 0 @>>
IF READ.TYPE() => BTYPE < 0 @>>
@BOX 5.1
BOX => COLTAB[COLNO];
BTYPE => T OF BOXTAB[BOX];
COLNO => COL OF BOXTAB[BOX];
@BOX 6.1
IF READ.BOX(^MODSTR,1) => BOX < 0 @>>
IF READ.TYPE() => BTYPE < 0 @>>
@BOX 7.1
BOX => COL.LINK OF BOXTAB[PREV.BOX];
BTYPE => T OF BOXTAB[BOX];
COLNO => COL OF BOXTAB[BOX];
'$L => BTB[BTBPTR=>LZPTR OF LZERO[BOX]]
   => BTB[2+BTBPTR=>TEXTPTR1 OF BOXTAB[BOX]];
EOBWC => BTB[BTBPTR+1] => BTB[BTBPTR+3];
0 => BOXHT1 OF BOXTAB[BOX] =>
LZHT OF LZERO[BOX];
4 +> BTBPTR;
@BOX 8.1
WHILE MODSTR[1+>IND] < %21 DO OD
IF MODSTR[IND] = '-
@BOX 9.1
LBOX => COL.LINK OF BOXTAB[PREVBOX];
BNOLIM => BOXLIMIT;
1 => ALTERED;
0 => INSERT.BOXES;
@BOX 10.1
END
@BOX 11.1
COL.LINK OF BOXTAB[FBOX] => LBOX;
FBOX => PREVBOX;
@BOX 12.1
BOX => PREV.BOX;
@BOX 13.1
-1 => INSERT.BOXES;
@BOX 14.1
IF MODSTR[IND] = '/
@BOX 15.1
CAPTION(%"$LILLEGAL FORMAT");
@END
@TITLE DOC08.4.2.2(1,9)
@COL 1S-2R-3R-11T-4T-5R-6R-7R-8T-9R-10F
@COL 12R
@ROW 5-12
@FLOW 1-2-3-11N-4N-5-6-7-8N-9-10
@FLOW 11Y-12-10
@FLOW 8Y-10
@FLOW 4Y-6
@BOX 1.0
FORM STRINGS
@BOX 2.0
INITIALISE FIRST AND
LAST BOX STRINGS
@BOX 3.0
READ FIRST NON-BLANK CHAR
@BOX 11.0
IS IT "-"?
@BOX 4.0
IS IT "/" ?
@BOX 5.0
COPY UNTIL "/" TO
FIRST BOX STRING
@BOX 6.0
COPY UNTIL "/" TO
MODIFICATION STRING
@BOX 7.0
READ UNTIL NEWLINE OR
NON-BLANK
@BOX 8.0
NEWLINE?
@BOX 9.0
COPY UNTIL NEWLINE
TO LAST BOX STRING
@BOX 10.0
END
@BOX 12.0
COPY UNTIL NEWLINE TO
MODIFICATION STRING
MARK END WITH SPECIAL CHAR
@BOX 1.1
PROC FORM.STRINGS;
$IN SYM,I;
@BOX 2.1
0 => FBSTR[0];
'/ => LBSTR[0];
@BOX 3.1
WHILE INCH() => SYM < %21 DO OD
@BOX 11.1
IF SYM = '-
@BOX 4.1
IF SYM = '/
@BOX 5.1
-1 => I;
WHILE SYM => FBSTR[1 +> I] /= '/ DO
   INCH() => SYM;
OD
@BOX 6.1
-1 => I;
WHILE INCH() => MODSTR[1+>I] /= '/ DO OD
@BOX 7.1
WHILE INCH() => SYM < %21 /= '$L DO OD
@BOX 8.1
IF SYM = '$L
@BOX 9.1
-1 => I;
WHILE SYM => LBSTR[1+>I] /= '$L DO
   INCH() => SYM;
OD
@BOX 10.1
END
@BOX 12.1
-1 => I;
WHILE SYM => MODSTR[1+>I] /= '$L DO
   INCH() => SYM;
OD
EOBWC => MODSTR[I];
@END
@TITLE DOC08.4.2.3(1,9)
@COL 18T-19R-20R
@COL 1S-2R-3T-4R-5T-6R-7T-15T-16T-17R-13T-14R-8R-9F
@COL 10R-11R-12R
@ROW 4-10
@ROW 18-16
@ROW 13-11
@FLOW 1-2-3Y-4-5Y-6-7Y-15Y-16N-13Y-14-8-9
@FLOW 3N-10-12-9
@FLOW 5N-7N-11-12
@FLOW 16Y-17-12
@FLOW 15N-18N-19-20-9
@FLOW 18Y-13
@FLOW 13N-8
@BOX 1.0
READ BOX (STRING,BOX STATE)
@BOX 2.0
SKIP UNTIL NON-BLANK CHAR
@BOX 3.0
DECIMAL DIGIT?
@BOX 4.0
STORE AS BOX NO
@BOX 5.0
NEXT CHAR DECIMAL?
@BOX 6.0
ADD CHART TO 10* BOX NO
@BOX 7.0
IN RANGE?
@BOX 15.0
DOES BOX STATE EXPECT
BOX TO EXIST ALREADY?
@BOX 16.0
DEFINED?
@BOX 17.0
OUTPUT - BOX ALREADY
DEFINED
@BOX 18.0
DEFINED?
@BOX 19.0
OUTPUT - BOX UNDEFINED
@BOX 20.0
SET RESULT TO FAULTY
@BOX 13.0
BOX NO < CURRENT NUMBER LIMIT
@BOX 14.0
STORE NEW NUMBER LIMIT
@BOX 8.0
SET RESULT TO BOX NO
@BOX 9.0
END
@BOX 10.0
OUTPUT "FAULT-WRONG
FORMAT"
@BOX 11.0
OUTPUT "FAULT-OUT
OF RANGE
@BOX 12.0
SET RESULT TO FAULTY
@BOX 1.1
PROC READ.BOX(STR,STATE);
$IN I,SYM,BOX;
@BOX 2.1
WHILE STR^[1+>IND] => SYM < %21 DO OD
@BOX 3.1
IF SYM < '0 OR SYM > '9
@BOX 4.1
SYM-'0 => BOX;
@BOX 5.1
IF STR^[IND+1] => SYM < '0 OR SYM > '9
@BOX 6.1
10 * BOX + SYM -'0 => BOX; 1+>IND;
@BOX 7.1
IF BOX < 1 OR BOX > 63
@BOX 15.1
IF STATE = 0
@BOX 16.1
IF T OF BOXTAB[BOX] = 0
@BOX 17.1
CAPTION(%"$LBOX ALREADY DEFINED");
@BOX 18.1
IF T OF BOXTAB[BOX] /= 0
@BOX 19.1
CAPTION(%"$LBOX UNDEFINED");
@BOX 20.1
-1 => READ.BOX;
@BOX 13.1
IF BOX < BNOLIM
@BOX 14.1
BOX + 1 => BNOLIM;
@BOX 8.1
BOX => READ.BOX;
@BOX 9.1
END
@BOX 10.1
CAPTION(%"$LWRONG FORMAT");
@BOX 11.1
CAPTION(%"$LOUT OF RANGE");
@BOX 12.1
-1 => READ.BOX;
@END
@TITLE DOC08.4.2.4(1,9)
@COL 1S-2R-3T-4R-5F
@COL 6R
@ROW 4-6
@FLOW 1-2-3Y-4-5
@FLOW 3N-6-5
@BOX 1.0
READ TYPE
@BOX 2.0
READ NEXT NON-BLANK CHAR
@BOX 3.0
INVALID TYPE?
@BOX 6.0
CONVERT TYPE TO NUMBER
AND STORE AS RESULT
@BOX 5.0
END
@BOX 4.0
OUTPUT "FAULT-
WRONG TYPE"
SET RESULT FAULTY
@BOX 1.1
PROC READ.TYPE;
$IN SYM,I;
@BOX 2.1
WHILE MODSTR[1+>IND] => SYM < %21 DO OD
@BOX 3.1
FOR I < 8 DO
   IF SYM = TYPES[I] @>>
OD
@BOX 6.1
I => READ.TYPE;
@BOX 4.1
CAPTION(%"FAULT-WRONG TYPE");
-1 => READ.TYPE;
@BOX 5.1
END
@END
@TITLE DOC08.4.3(1,9)
@COL 11C-12R
@COL 1S-2R-3R-4T-5T-6T-7T-8R-14T-9R-15R-10F
@COL 13R
@ROW 11-4
@ROW 5-13
@ROW 12-9
@FLOW 1-2-3-4N-5OK-6Y-7OK-8-6N-14Y-9-10
@FLOW 11-12-10
@FLOW 5FAULT-12
@FLOW 4Y-13-10
@FLOW 7FAULT-12
@FLOW 14N-15-12
@BOX 1.0
R
@BOX 2.0
STORE ROWLINKS
@BOX 3.0
READ LINE INTO
MODIFICATION STRING
MARK END WITH SPECIAL CHAR
@BOX 4.0
IS FIRST CHAR A MINUS?
@BOX 5.0
READ FIRST BOX IN STRING
@BOX 6.0
NEXT NON BLANK IN STRING A MINUS?
@BOX 7.0
READ NEXT BOX
@BOX 8.0
LINK THIS BOX TO
PREVIOUS BOX
@BOX 14.0
END OF STRING?
@BOX 15.0
OUTPUT - ILLEGAL FORMAT
@BOX 9.0
SET CHART ALTERED
INCREMENT NO OF ROWS
@BOX 10.0
END
@BOX 11.0
FAIL
@BOX 12.0
RESTORE ORIGINAL ROW LINKS
@BOX 13.0
DELETE ROW [DOC08.4.3.1]
@BOX 1.1
::INSERT/DELETE ROW
@BOX 2.1
FOR BOX < 64 DO
   ROWLINK OF BOXTAB[BOX] => SAV3[BOX];
OD
@BOX 3.1
-1 => IND;
WHILE INCH() => MODSTR[1+>IND] /= '$L DO OD
EOBWC => MODSTR[IND];
@BOX 4.1
-1 => IND;
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
IF CH = '-
@BOX 5.1
-1 => IND;
IF READ.BOX(^MODSTR,0) => PREV.BOX < 0
@BOX 6.1
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
IF CH /= '-
@BOX 7.1
IF READ.BOX(^MODSTR,0) => BOX < 0
@BOX 8.1
BOX => ROWLINK OF BOXTAB[PREV.BOX] => PREV.BOX;
@BOX 14.1
IF CH /= EOBWC
@BOX 15.1
CAPTION(%"$LILLEGAL FORMAT");
@BOX 9.1
1 => ALTERED;
1 +> ROWLIMIT;
@BOX 10.1
::END
@BOX 11.1
FAIL:
@BOX 12.1
FOR BOX < 64 DO
   SAV3[BOX] => ROWLINK OF BOXTAB[BOX];
OD
@BOX 13.1
#DOC08.4.3.1
@END
@TITLE DOC08.4.3.1(1,9)
@COL 9N-10T-11R-12R-13C
@COL 1S-2T-3T-4T-5R-6R-7T-14T-16R-15R-8F
@ROW 9-3
@ROW 10-5
@FLOW 1-2OK-3OK-4Y-5-6-7N-14Y-16-8
@FLOW 2FAULT-8
@FLOW 3FAULT-9-13
@FLOW 4N-10Y-11-6
@FLOW 10N-12-13
@FLOW 7Y-3
@FLOW 14N-15-13
@BOX 1.0
DELETE ROW
@BOX 2.0
READ BOX NO FROM STRING
AND STORE AS PREVIOUS BOX
SKIP PAST NEXT NON-BLANK
@BOX 3.0
READ NEXT BOX NO AND
STORE AS CURRENT BOX
@BOX 4.0
IS ROWLINK OF PREVIOUS
BOX = CURRENT BOX?
@BOX 5.0
SET PREVIOUS BOX ROWLINK TO
CURRENT BOX ROWLINK
SET CURRENT BOX ROWLINK ZERO
@BOX 6.0
MAKE THE CURRENT BOX
THE PREVIOUS BOX
@BOX 7.0
NEXT NON-BLANK IN
STRING A MINUS?
@BOX 14.0
END OF STRING?
@BOX 16.0
SET CHART ALTERED
@BOX 15.0
OUTPUT - ILLEGAL FORMAT
@BOX 8.0
END
@BOX 10.0
IS ROWLINK OF CURRENT
BOX = PREVIOUS BOX
@BOX 11.0
SET CURRENT BOX ROWLINK
TO PREVIOUS BOX ROWLINK
SET PREVIOUS BOX ROWLINK ZERO
@BOX 12.0
OUTPUT "FAULTY
ROW LINKAGE"
@BOX 13.0
FAIL
@BOX 1.1
::DELETE ROW
@BOX 2.1
IF READ.BOX(^MODSTR,0) => PREV.BOX < 0 @>>
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
@BOX 3.1
IF READ.BOX(^MODSTR,0) => BOX < 0
@BOX 4.1
IF ROWLINK OF BOXTAB[PREVBOX] /= BOX
@BOX 5.1
0 => ROWLINK OF BOXTAB[PREVBOX];
@BOX 6.1
BOX => PREVBOX;
@BOX 7.1
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
IF CH = '-
@BOX 14.1
IF CH /= EOBWC
@BOX 15.1
CAPTION(%"$LILLEGAL FORMAT");
@BOX 8.1
::END
@BOX 10.1
IF ROWLINK OF BOXTAB[BOX] /= PREVBOX
@BOX 11.1
0 => ROWLINK OF BOXTAB[BOX];
@BOX 12.1
CAPTION(%"$LFAULTY ROW LINKAGE");
@BOX 13.1
->FAIL;
@END
@TITLE DOC08.4.4(1,9)
@COL 1S-2R-3R-4T-5T-8R-9T-6T-7R-23R-10C-11T-12T-13T-14T-15R-16R-17R
@COL 18R-19C-20R-21F-22R
@ROW 5-18
@ROW 15-22
@FLOW 1-2-3-4N-5OK-8-9Y-11OK-12Y-13Y-14Y-15-16-17-8
@FLOW 4Y-18-21
@FLOW 5FAULT-20-21
@FLOW 9N-6Y-23-10
@FLOW 11FAULT-20-21
@FLOW 12N-16
@FLOW 13N-16
@FLOW 14N-22-17
@FLOW 19-20
@FLOW 6N-7-20
@BOX 1.0
F
@BOX 2.0
STORE ALL PRIMARY AND
SECONDARY FLOWLINKS
@BOX 3.0
READ LINE TO MODIFICATION STRING
MARK END WITH SPECIAL CHAR
@BOX 4.0
FIRST NON-BLANK IN STRING A MINUS?
@BOX 5.0
READ FIRST BOX IN STRING
AND TREAT AS PREVIOUS BOX
@BOX 8.0
COPY FLOW CAPTION TO
BOX TEXT BUFFER
@BOX 6.0
END OF STRING?
@BOX 7.0
OUTPUT - ILLEGAL FORMAT
@BOX 9.0
ANY MORE BOXES?
@BOX 23.0
SET CHART ALTERED
@BOX 10.0
END
@BOX 11.0
READ NEXT BOX AND TREAT
AS CURRENT BOX
@BOX 12.0
HAS PREVIOUS BOX
ANY PRIMARY FLOW?
@BOX 13.0
PREVIOUS BOX A TEST BOX?
@BOX 14.0
CURRENT BOX BELOW PREVIOUS
BOX IN COLUMN?
@BOX 15.0
MAKE PRIMARY INTO SECONDARY FLOW
MONITOR IF OLD FLOWPATH DESTROYED
@BOX 16.0
MAKE CURRENT BOX THE PRIMARY FLOW
MONITOR IF OLD FLOW PATH DESTROYED
@BOX 17.0
MAKE CURRENT BOX THE
PREVIOUS BOX
@BOX 18.0
DELETE FLOW [DOC08.4.4.1]
@BOX 19.0
FAILA
@BOX 20.0
RESTORE ORIGINAL PRIMARY
AND SECONDARY FLOW LINKS
@BOX 21.0
END
@BOX 22.0
MAKE CURRENT BOX THE SECONDARY FLOW
MONITOR IF OLD FLOW PATH DESTROYED
@BOX 1.1
::INSERT/DELETE FLOW
@BOX 2.1
FOR BOX < 64 DO
PFLOWLINK OF BOXTAB[BOX] => SAV3[BOX];
SFLOWLINK OF BOXTAB[BOX] => SAV4[BOX];
PFLOWTEXT OF BOXTAB[BOX] => SAV5[BOX];
SFLOWTEXT OF BOXTAB[BOX] => SAV6[BOX];
OD
@BOX 3.1
-1 => IND;
WHILE INCH() => MODSTR[1+>IND] /= '$L DO OD
EOBWC => MODSTR[IND];
@BOX 4.1
-1 => IND;
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
IF CH = '-
@BOX 5.1
-1 => IND;
IF READ.BOX(^MODSTR,0) => PREVBOX < 0
@BOX 8.1
BTBPTR+1 => FCAP;
WHILE MODSTR[1+>IND] => BTB[1+>BTBPTR]=>CH /='- /= EOBWC DO OD
IF BTBPTR = FCAP THEN
   1->BTBPTR; 0=>FCAP;
FI
@BOX 6.1
IF CH = EOBWC
@BOX 7.1
CAPTION(%"$LILLEGAL FORMAT");
@BOX 9.1
IF CH = '-
@BOX 23.1
1 => ALTERED;
@BOX 10.1
->BX21;
@BOX 11.1
IF READ.BOX(^MODSTR,0) => BOX < 0
@BOX 12.1
IF PFLOWLINK OF BOXTAB[PREVBOX]=>PFLOW=0
@BOX 13.1
IF T OF BOXTAB[PREVBOX] /= TEST
@BOX 14.1
IF COL.LINK OF BOXTAB[PREVBOX] /= BOX
@BOX 15.1
IF SFLOWLINK OF BOXTAB[PREVBOX] => SFLOW /=0 THEN
   CAPTION(%"$LSECONDARY FLOW DELETED ");
   OUTI(PREVBOX,0);OUTCH('-);
   OUTI(SFLOW,0);
FI
PFLOWLINK OF BOXTAB[PREVBOX] => SFLOW => SFLOWLINK OF BOXTAB[PREVBOX] => PFLOW;
PFLOWTEXT OF BOXTAB[PREVBOX] => SFLOWTEXT OF BOXTAB[PREVBOX];
@BOX 16.1
IF PFLOW /= 0 THEN
   CAPTION(%"$LPRIMARY FLOW DELETED ");
   OUTI(PREVBOX,0);OUTCH('-);
   OUTI(PFLOW,0);
FI
BOX => PFLOWLINK OF BOXTAB[PREVBOX];
FCAP => PFLOWTEXT OF BOXTAB[PREVBOX];
@BOX 17.1
BOX => PREVBOX;
@BOX 18.1
#DOC08.4.4.1
@BOX 19.1
FAILA:
@BOX 20.1
FOR BOX < 64 DO
SAV3[BOX] => PFLOWLINK OF BOXTAB[BOX];
SAV4[BOX] => SFLOWLINK OF BOXTAB[BOX];
SAV5[BOX] => PFLOWTEXT OF BOXTAB[BOX];
SAV6[BOX] => SFLOWTEXT OF BOXTAB[BOX];
OD
@BOX 21.1
BX21:
::END
@BOX 22.1
IF SFLOWLINK OF BOXTAB[PREVBOX] => SFLOW /= 0 THEN
   CAPTION(%"$L SECONDARY FLOW DELETED ");
   OUTI(PREVBOX,0); OUTCH('-); OUTI(SFLOW,0);
FI
BOX => SFLOWLINK OF BOXTAB[PREVBOX];
FCAP => SFLOWTEXT OF BOXTAB[PREVBOX];
@END
@TITLE DOC08.4.4.1(1,9)
@COL 9T-10R-11R-12C
@COL 1S-2T-3T-4T-5R-6R-7T-13T-15R-14R-8F
@ROW 9-5
@FLOW 1-2OK-3OK-4Y-5-6-7N-13Y-15-8
@FLOW 2FAULT-8
@FLOW 3FAULT-8
@FLOW 4N-9Y-10-6
@FLOW 9N-11-12
@FLOW 7Y-3
@FLOW 13N-14-12
@BOX 1.0
DELETE FLOW
@BOX 2.0
READ FIRST BOX FROM STRING
AND TREAT AS PREVIOUS BOX
SKIP PAST NEXT NON-BLANK
@BOX 3.0
READ NEXT BOX AND TREAT
AS CURRENT BOX
@BOX 4.0
IS PRIMARY FLOW FROM PREVIOUS
BOX = CURRENT BOX?
@BOX 5.0
SET PRIMARY FLOW ZERO
@BOX 6.0
TREAT CURRENT BOX AS PREVIOUS BOX
@BOX 7.0
NEXT NON BLANK IN STRING
A MINUS?
@BOX 13.0
END OF STRING?
@BOX 15.0
SET CHART ALTERED
@BOX 14.0
OUTPUT - ILLEGAL FORMAT
@BOX 8.0
END
@BOX 9.0
SECONDARY FLOW FROM PREVIOUS
BOX = CURRENT BOX?
@BOX 10.0
SET SECONDARY FLOW ZERO
@BOX 11.0
OUTPUT "NO SUCH FLOW"
@BOX 12.0
FAILA
@BOX 1.1
::DELETE FLOW
@BOX 2.1
IF READ.BOX(^MODSTR,0) => PREV.BOX < 0 @>>
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
@BOX 3.1
IF READ.BOX(^MODSTR,0) => BOX < 0
@BOX 4.1
IF PFLOW.LINK OF BOXTAB[PREV.BOX] /= BOX
@BOX 5.1
0 => PFLOWLINK OF BOXTAB[PREV.BOX];
@BOX 6.1
BOX => PREV.BOX;
@BOX 7.1
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
IF CH = '-
@BOX 13.1
IF CH /= EOBWC
@BOX 15.1
1 => ALTERED;
@BOX 14.1
CAPTION(%"$LILLEGAL FORMAT");
@BOX 8.1
::END
@BOX 9.1
IF SFLOWLINK OF BOXTAB[PREVBOX] /= BOX
@BOX 10.1
0 => SFLOWLINK OF BOXTAB[PREVBOX];
@BOX 11.1
CAPTION(%"$LNO SUCH FLOW");
@BOX12.1
->FAILA;
@END
@TITLE DOC08.4.5(1,9)
@COL 1S-8T-2R-3R-7R-4R-6F
@COL 9R
@ROW 3-9
@FLOW 1-8N-2-3-7-4-6
@FLOW 8Y-9-6
@FLOW 9
@BOX 1.0
M(BOX,LEVEL)
@BOX 2.0
COPY BOX TEXT AT SPECIFIED
LEVEL TO BOX TEXT AREA
@BOX 3.0
CALL SIMPLE SCREEN EDITOR
SPECIFYING BTA
@BOX 4.0
WRITE TEXT FROM BTA BACK
TO THE END OF THE BOX
TEXT BUFFER
SET NEW VALUE OF TEXT POINTER
AT THE SPECIFIED LEVEL
SET CHART ALTERED
@BOX 6.0
END
@BOX 7.0
SHIFT ALL TEXT IN BTB FOLLOWING
THIS BACK ON TOP OF THE TEXT
FOR THIS BOX
@BOX 8.0
BOX UNDEFINED OR NULL?
@BOX 9.0
MONITOR - BOX UNDEFINED
@BOX 1.1
::BOX MODIFICATION
@BOX 2.1
IF LEV = 0 THEN
   LZPTR OF LZERO[BOX] => I => M => N;
ELSE
   TEXTPTR1 OF BOXTAB[BOX] => I => M => N;
FI
1 -> I; -1 => J;
WHILE BTB[1+>I] => BTA[1+>J]/=EOBWC DO OD
@BOX 3.1
VEDIT(^BTA,J,DEVICE,0) => TEXTEND;
PROMPT(^ARROW);
@BOX 4.1
0 => WTH => MAXWTH => NLS;
BTBPTR=>J-1=>BTBPTR;
FOR I < TEXTEND DO
   BTA[I] => BTB[1 +> BTBPTR] => CH;
   1 +> WTH;
   IF CH = '$L THEN
      IF WTH > MAXWTH THEN
         WTH => MAXWTH;
      FI
   0 => WTH;
   1 +> NLS;
   FI
OD
EOBWC => BTB[1 +> BTBPTR];
1 +> BTBPTR;
IF LEV = 0 THEN
   J => LZPTR OF LZERO[BOX];
   NLS => LZHT OF LZERO[BOX];
   MAXWTH => LZWTH OF LZERO[BOX];
ELSE
   J => TEXTPTR1 OF BOXTAB[BOX];
   NLS => BOXHT1 OF BOXTAB[BOX];
   MAXWTH => BOXWTH1 OF BOXTAB[BOX];
FI
1 => ALTERED;
@BOX 6.1
::END
@BOX 7.1
1+>J;
J + M => I;
FOR K < BTBPTR-I DO
   BTB[I+K]=>BTB[M+K];
OD
J -> BTBPTR;
FOR K < 64 DO
   IF LZPTR OF LZERO[K] > N THEN
      J -> LZPTR OF LZERO[K];
   FI
   IF TEXTPTR1 OF BOXTAB[K] > N THEN
      J -> TEXTPTR1 OF BOXTAB[K];
   FI
   IF PFLOWTEXT OF BOXTAB[K] > N THEN
      J -> PFLOWTEXT OF BOXTAB[K];
   FI
   IF SFLOWTEXT OF BOXTAB[K] > N THEN
      J -> SFLOWTEXT OF BOXTAB[K];
   FI
OD
@BOX 8.1
INI() & 63 => BOX;
INI() => LEV;
INCH();
IF T OF BOXTAB[BOX] < 2
@BOX 9.1
CAPTION(%"BOX UNDEFINED$L");
@END

@TITLE DOC08.4.6(1,9)
@COL 13R
@COL 1S-3R-2T-4R-5T-6T-7T-8R-9R-10T-11R-18N-12F
@COL 15R-16T-14C-17N
@ROW 4-15
@ROW 6-16
@ROW 13-8
@ROW 11-14
@ROW 18-17
@FLOW 1-3-2N-4-5N-6OK-7NONE-8-9-10Y-11-18-12
@FLOW 2Y-15-17-18-12
@FLOW 5Y-16OK-9
@FLOW 16FAULTY-11
@FLOW 6FAULTY-11
@FLOW 7FOUND-13-9
@FLOW 10N-18-12
@FLOW 14-17-18-12
@BOX 1.0
B
@BOX 2.0
FIRST CHAR A MINUS?
@BOX 3.0
READ LINE INTO FIRST AND LAST BOX
STRINGS AND MODIFICATION STRING
[DOC08.4.2.2]
@BOX 4.0
STORE ALL BOX AND COLUMN
VALUES THAT MAY ALTER
@BOX 5.0
FIRST BOX SPECIFIED?
@BOX 6.0
READ LAST BOX
@BOX 7.0
FIND BOX ABOVE LAST BOX
@BOX 8.0
TREAT FIRST BOX AS ZERO
@BOX 9.0
INSERT THE BOXES IN THE
MODIFICATION STRING AFTER
THE FIRST BOX [DOC08.4.2.1]
@BOX 10.0
FAULTY?
@BOX 11.0
RESTORE ORIGINAL BOX AND
COLUMN TABLE ENTRIES
@BOX 12.0
END
@BOX 13.0
TREAT THIS BOX AS
THE FIRST BOX
@BOX 14.0
DELETE
FAIL
@BOX 15.0
DELETE BOXES
[DOC08.4.6.1]
@BOX 16.0
READ FIRST BOX
@BOX 1.1
::INSERT/DELETE BOXES
@BOX 2.1
IF MODSTR[0=>IND] = '-
@BOX 3.1
FORM.STRINGS();
@BOX 4.1
FOR BOX < 64 DO
   COL OF BOXTAB[BOX] => SAV1[BOX];
   T OF BOXTAB[BOX] => SAV2[BOX];
   COL.LINK OF BOXTAB[BOX] => SAV3[BOX];
OD
@BOX 5.1
-1 =>IND;
IF FBSTR[0] /= 0
@BOX 6.1
IF READ.BOX(^LBSTR,0) => LAST < 0 @>>
COL OF BOXTAB[LAST] => COLNO;
@BOX 16.1
IF READ.BOX(^FBSTR,0) => FIRST < 0@>>
COL OF BOXTAB[FIRST] => COLNO;
@BOX 7.1
FOR BOX < BOXLIMIT DO
   IF COL.LINK OF BOXTAB[BOX] = LAST@>>
OD
@BOX 8.1
0 => FIRST;
@BOX 9.1
INSERT.BOXES(COLNO,FIRST) => ERR;
@BOX 10.1
IF ERR = 0
@BOX 11.1
FOR BOX < 64 DO
   SAV1[BOX] => COL OF BOXTAB[BOX];
   SAV2[BOX] => T OF BOXTAB[BOX];
   SAV3[BOX] => COL.LINK OF BOXTAB[BOX];
OD
@BOX 12.1
::END
@BOX 13.1
BOX => FIRST;
@BOX 14.1
DELFAIL:
@BOX 15.1
#DOC08.4.6.1
@END
@TITLE DOC08.4.6.1(1,9)
@COL 1S-2T-3T-4R-5R-6T-7R-8R-9T-10R-11R-12R-13T-20T-25R-14F
@COL 15N-23T-16R-24R-17T-18R-21R-22C
@ROW 2-15
@ROW 4-23
@ROW 10-17
@FLOW 1-2OK-3FOUND-4-5-6FOUND-7-8-9Y-10-9N-17Y-18-17N-11-12-13N-20Y-25-14
@FLOW 2FAULTY-15-22
@FLOW 3FAIL-23N-16-5
@FLOW 23Y-24-6
@FLOW 6NONE-8
@FLOW 13Y-2
@FLOW 20N-21-22
@BOX 1.0
DELETE BOXES
@BOX 2.0
READ BOX FROM
MODIFICATION STRING
@BOX 3.0
SCAN COLUMN LINKS
FOR CURRENT BOX
@BOX 16.0
SET BOX BELOW
AS TOP OF COLUMN
@BOX 5.0
RESET COLUMN LINK FOR
CURRENT BOX
@BOX 6.0
SCAN ROWLINKS FOR
CURRENT BOX
@BOX 7.0
LINK PREVIOUS BOX IN
ROW TO NEXT BOX
@BOX 8.0
DELETE ROWLINK FOR
CURRENT BOX
@BOX 9.0
ANY PRIMARY FLOW
TO CURRENT BOX?
@BOX 10.0
ROUTE THIS PRIMARY FLOW
TO NEXT BOX IN PRIMARY FLOW
@BOX 11.0
DELETE PRIMARY AND
SECONDARY FLOW FOR
CURRENT BOX
@BOX 12.0
SET BOX UNDEFINED
@BOX 13.0
NEXT NON-BLANK IN STRING A MINUS?
@BOX 14.0
END
@BOX 4.0
LINK THIS ENTRY TO BOX
BELOW CURRENT BOX
@BOX 17.0
ANY SECONDARY FLOW
TO CURRENT BOX?
@BOX 18.0
ROUTE THIS SECONDARY FLOW
TO NEXT BOX IN PRIMARY FLOW
@BOX 20.0
END OF STRING?
@BOX 21.0
OUTPUT - ILLEGAL FORMAT
@BOX 22.0
DELETE
FAIL
@BOX 23.0
LAST BOX IN COLUMN?
@BOX 24.0
SHIFT ALL COLUMNS ON THE
RIGHT LEFT BY ONE
@BOX 25.0
SET CHART ALTERED
@BOX 1.1
::DELETE BOXES
@BOX 2.1
IF READ.BOX(^MODSTR,0) => BOX < 0
@BOX 3.1
1 => I;
WHILE COLLINK OF BOXTAB[I] /= BOX DO
   IF 1 +>I = BOXLIMIT @>>
OD
@BOX 4.1
COL.LINK OF BOXTAB[BOX] => COL.LINK OF BOXTAB[I];
@BOX 5.1
0 => COL.LINK OF BOXTAB[BOX];
@BOX 6.1
1 => I;
WHILE ROWLINK OF BOXTAB[I] /= BOX DO
   IF 1 +> I = BOXLIMIT @>>
OD
@BOX 7.1
ROWLINK OF BOXTAB[BOX] => ROWLINK OF BOXTAB[I];
@BOX 8.1
0 => ROWLINK OF BOXTAB[BOX];
@BOX 9.1
1 => I;
WHILE PFLOWLINK OF BOXTAB[I] /= BOX DO
   IF 1 +> I = BOXLIMIT @>>
OD
@BOX 10.1
PFLOWLINK OF BOXTAB[BOX] => PFLOWLINK OF BOXTAB[I];
@BOX 11.1
0 => PFLOWLINK OF BOXTAB[BOX] =>
SFLOWLINK OF BOXTAB[BOX];
@BOX 12.1
0 => T OF BOXTAB[BOX];
@BOX 13.1
WHILE MODSTR[1+>IND]=>CH < %21 DO OD
IF CH = '-
@BOX 20.1
IF CH /= EOBWC
@BOX 14.1
::END
@BOX 16.1
TEMP => COLTAB[COL OF BOXTAB[BOX]];
@BOX 17.1
1 => I;
WHILE SFLOWLINK OF BOXTAB[I] /= BOX DO
   IF 1 +> I = BOXLIMIT @>>
OD
@BOX 18.1
PFLOWLINK OF BOXTAB[BOX] => SFLOWLINK OF BOXTAB[I];
@BOX 21.1
CAPTION(%"$LILLEGAL FORMAT");
@BOX 22.1
->DELFAIL;
@BOX 23.1
IF COLLINK OF BOXTAB[BOX] => TEMP = 0
@BOX 24.1
COL OF BOXTAB[BOX] => COLNO;
FOR I < BOXLIMIT DO
   IF COL OF BOXTAB[I] > COLNO THEN
      1 -> COL OF BOXTAB[I];
   FI
OD
WHILE COLNO =< COLIMIT DO
   COLTAB[1+>COLNO] => COLTAB[COLNO-1];
OD
1 -> COLIMIT;
@BOX 25.1
1 => ALTERED;
@END
@TITLE DOC08.4.7(1,9)
@COL 1S-6R-3R-4R-7R-5F
@FLOW 1-6-3-4-7-5
@BOX 1.0
E
@BOX 6.0
SELECT INPUT AND
OUTPUT FILES
@BOX 3.0
OUTPUT CURRENT CHART
[DOC08.4.7.1]
@BOX 4.0
COPY FROM INPUT TO
OUTPUT UNTIL END OF FILE
@BOX 7.0
END FILE I/O
SELECT ORIGINAL I/O
@BOX 5.0
END
@BOX 1.1
::ENDCHART
@BOX 3.1
OUTPUT.CURRENT.CHART();
@BOX 4.1
WHILE IENQ() & %C = 0 DO
   OUTCH(INCH());
OD
@BOX 5.1
::END
#DOC08.4.7.1
@BOX 6.1
SELECTINPUT(CURIN);
SELECTOUTPUT(CUROUT);
@BOX 7.1
END.INPUT(CURIN,0);
END.OUTPUT(CUROUT,0);
SELECT.INPUT(OLDIN);
SELECT.OUTPUT(OLDOUT);
@END
@TITLE DOC08.4.7.1(1,9)
@COL 1S-10T-11T-2R-3R-4R-5R-6R-7R-8R-12R-9F
@COL 13R
@ROW 6-13
@FLOW 1-10Y-11Y-2-3-4-5-6-7-8-12-9
@FLOW 10N-9
@FLOW 11N-13-12
@BOX 1.0
OUTPUT CURRENT CHART
@BOX 10.0
IS A CHART CURRENTLY SELECTED?
@BOX 11.0
HAS IT BEEN ALTERED?
@BOX 2.0
OUTPUT TITLE LINE
@BOX 3.0
OUTPUT COLUMNS
[DOC.8.4.7.2]
@BOX 4.0
OUTPUT ROWS
[DOC08.4.7.3]
@BOX 5.0
OUTPUT FLOWS
[DOC08.4.7.4]
@BOX 6.0
OUTPUT BOX TEXT
AT LEVEL 0
[DOC08.4.7.5]
@BOX 7.0
OUTPUT BOX TEXT
AT LEVEL 1
[DOC08.4.7.5]
@BOX 8.0
OUTPUT @END
OUTPUT NEWPAGE
@BOX 12.0
RESET SELECTED AND ALTERED
@BOX 13.0
RESET INPUT POINTER TO
START OF SELECTED CHART
@BOX 9.0
END
@BOX 1.1
$PS OUTNUM($IN);
PROC OUTNUM(I);
$IN TENS;
IF I/10 => TENS > 0 THEN
   OUTCH(TENS + '0);
   TENS * 10 -> I;
FI
OUTCH(I+'0);
END
PROC OUTPUT.CURRENT.CHART;
$IN I,COLNO,ORIG,J,SYM;
$PS OUTBOXTEXT($IN);
#DOC08.4.7.5
$PS OUTFLOW($IN,$IN);
#DOC08.4.7.4.1
@BOX 10.1
IF SELECTED = 0
@BOX 11.1
IF ALTERED = 0
@BOX 2.1
CAPTION(%"@TITLE ");
-1 => I;
WHILE TBUFF[1+>I] => SYM /= '$L DO
   OUTCH(SYM);
OD
@BOX 3.1
#DOC08.4.7.2
@BOX 4.1
#DOC08.4.7.3
@BOX 5.1
#DOC08.4.7.4
@BOX 6.1
OUTBOXTEXT(0);
@BOX 7.1
OUTBOXTEXT(1);
@BOX 8.1
CAPTION(%"@END$L");
@BOX 12.1
0 => SELECTED => ALTERED;
@BOX 13.1
SET.IPOS(INP);
@BOX 9.1
END
@END
@TITLE DOC08.4.7.2(1,9)
@COL 1S-2R-3T-4R-5R-6T-7R-9T-10F
@FLOW 1-2-3OK-4-5-6NONE-9NONE-10
@FLOW 9OK-3NONE-9
@FLOW 6OK-7-5
@BOX 1.0
OUTPUT COLUMNS
@BOX 2.0
STARTING WITH LEFTMOST COLUMN
@BOX 3.0
LOAD FIRST BOX NO IN COLUMN
@BOX 4.0
OUTPUT "@COL "
@BOX 5.0
OUTPUT BOX NO
OUTPUT BOX TYPE
@BOX 6.0
SELECT BOX BELOW
@BOX 7.0
OUTPUT "-"
@BOX 9.0
SELECT NEXT COLUMN
@BOX 10.0
END
@BOX 1.1
::OUTPUT COLS
@BOX 2.1
0 => COLNO;
@BOX 3.1
IF COLTAB[COLNO] => I = 0
@BOX 4.1
CAPTION(%"$L@COL ");
@BOX 5.1
OUTNUM(I);
OUTCH(TYPES[T OF BOXTAB[I]]);
@BOX 6.1
IF COLLINK OF BOXTAB[I] => I = 0
@BOX 7.1
OUTCH('-);
@BOX 9.1
IF 1 +> COLNO < COLIMIT
@BOX 10.1
::END
@END
@TITLE DOC08.4.7.3(1,9)
@COL 1S-2R-3T-4R-5T-6T-7R-8R-9T-10R-12T-13F
@FLOW 1-2-3FOUND-4-3FAIL-5N-7-8-9NONE-12NO MORE-13
@FLOW 5Y-6-7
@FLOW 9OK-10-8
@FLOW 6N-12
@FLOW 12NEXT-3
@BOX 1.0
OUTPUT ROWS
@BOX 2.0
START WITH BOX 1 AS
THE ORIGINAL BOX
@BOX 3.0
SCAN ROWLINKS FOR
CURRENT BOX NO
@BOX 4.0
SELECT BOX POINTING
TO CURRENT BOX
@BOX 7.0
OUTPUT "@ROW"
@BOX 8.0
OUTPUT CURRENT BOX NO
@BOX 9.0
SELECT NEXT BOX IN ROW
@BOX 10.0
DELETE ROWLINK
OUTPUT "-"
@BOX 12.0
INCREMENT ORIGINAL BOX NO
@BOX 13.0
END
@BOX 5.0
IS CURRENT BOX THE ORIGINAL?
@BOX 6.0
ROWLINK SET FOR CURRENT BOX?
@BOX 1.1
::OUTPUT ROWS
@BOX 2.1
1 => ORIG => I;
@BOX 3.1
1 => J;
WHILE ROWLINK OF BOXTAB[J] /= I DO
   IF 1 +> J = BOXLIMIT @>>
OD
@BOX 4.1
J => I;
@BOX 5.1
IF I /= ORIG
@BOX 6.1
IF ROWLINK OF BOXTAB[I] = 0
@BOX 7.1
CAPTION(%"$L@ROW ");
@BOX 8.1
OUTNUM(I);
I => J;
@BOX 9.1
IF ROWLINK OF BOXTAB[I] => I = 0
@BOX 10.1
0 => ROWLINK OF BOXTAB[J];
OUTCH('-);
@BOX 12.1
IF 1 +> ORIG => I < BOXLIMIT
@BOX 13.1
::END
@END
@TITLE DOC08.4.7.4(1,9)
@COL 1S-2R-3R-4R-5T-6R-11T-12R-7T-8R-9T-14R-10F
@FLOW 1-2-3-4-5FOUND-6-5FAIL-11FAIL-7Y-9NONE-14-10
@FLOW 11FOUND-12-5
@FLOW 9NEXT-5
@FLOW 7N-8-5
@BOX 1.0
OUTPUT FLOWS
@BOX 2.0
FIND START BOX
@BOX 3.0
OUTPUT PRIMARY FLOWPATH
FROM START BOX [DOC08.4.7.4.1]
@BOX 4.0
SET ORIGINAL BOX NO TO 1
@BOX 5.0
SCAN PRIMARY FLOWS
FOR CURRENT BOX
@BOX 6.0
SELECT THIS AS
CURRENT BOX
@BOX 7.0
IS CURRENT BOX THE
ORIGINAL BOX?
@BOX 8.0
OUTPUT PRIMARY FLOW
PATH FROM CURRENT BOX
[DOC08.4.7.4.1]
RESELECT ORIGINAL BOX
@BOX 9.0
INCREMENT ORIGINAL BOX NO
@BOX 14.0
OUTPUT NEWLINE
@BOX 10.0
END
@BOX 11.0
SCAN SECONDARY FLOWS
FOR CURRENT BOX
@BOX 12.0
OUTPUT SECONDARY FLOW
[DOC08.4.7.4.1]
@BOX 1.1
::OUTPUT FLOWS
@BOX 2.1
0 => I;
WHILE T OF BOXTAB[1+>I] /= START DO OD
@BOX 3.1
OUTFLOW(I,0);
@BOX 4.1
1 => ORIG => I;
@BOX 5.1
1 => J;
WHILE PFLOWLINK OF BOXTAB[J] /= I DO
   IF 1 +> J = BOXLIMIT @>>
OD
@BOX 6.1
J => I;
@BOX 7.1
IF I = ORIG
@BOX 8.1
OUTFLOW(I,0);
ORIG => I;
@BOX 9.1
IF 1 +> ORIG => I < BOXLIMIT
@BOX 14.1
NEWLINES(1);
@BOX 10.1
::END
@BOX 11.1
1 => J;
WHILE SFLOWLINK OF BOXTAB[J] /= I DO
   IF 1 +> J = BOXLIMIT @>>
OD
@BOX 12.1
OUTFLOW(J,1);
@END
@TITLE DOC08.4.7.4.1(1,9)
@COL 1S-2R-3T-4R-6T-5R-7R-9F
@COL 10R
@ROW 4-10
@FLOW 1-2-3Y-4-6OK-5-7-4
@FLOW 3N-10-4
@FLOW 6NONE-9
@BOX 1.0
OUTPUT FLOWPATH (BOXNO,FLOWTYPE)
@BOX 2.0
OUTPUT "@FLOW "
@BOX 3.0
PRIMARY FLOW?
@BOX 4.0
OUTPUT CURRENT BOX NO
@BOX 5.0
OUTPUT PRIMARY FLOW TEXT
TO THIS BOX
@BOX 6.0
SELECT NEXT BOX IN
PRIMARY FLOW
@BOX 7.0
DELETE PRIMARY FLOW LINK
OUTPUT "-"
@BOX 9.0
END
@BOX 10.0
OUTPUT CURRENT BOX NO
OUTPUT SECONDARY TEXT
SELECT SECONDARY
FLOW LINK AS CURRENT BOX
DELETE SECONDARY FLOWLINK
OUTPUT "-"
@BOX 1.1
PROC OUTFLOW(BOX,FLOWTYPE);
$IN I,J;
@BOX 2.1
CAPTION(%"$L@FLOW ");
@BOX 3.1
IF FLOWTYPE /= 0
@BOX 4.1
OUTNUM(BOX);
@BOX 5.1
IF PFLOWTEXT OF BOXTAB[I] => J /= 0 THEN
   WHILE BTB[J] /= '- DO
      OUTCH(BTB[J]); 1 +> J;
   OD
FI
@BOX 6.1
BOX => I;
IF PFLOWLINK OF BOXTAB[BOX] => BOX = 0
@BOX 7.1
0 => PFLOWLINK OF BOXTAB[I];
OUTCH('-);
@BOX 9.1
END
@BOX 10.1
OUTNUM(BOX);
IF SFLOWTEXT OF BOXTAB[BOX] => I /= 0 THEN
   WHILE BTB[I] /= '- DO
      OUTCH(BTB[I]); 1 +> I;
  OD
FI
BOX => I;
SFLOWLINK OF BOXTAB[BOX] => BOX;
0 => SFLOWLINK OF BOXTAB[I];
OUTCH('-);
@END
@TITLE DOC08.4.7.5(1,9)
@COL 1S-2R-3T-4R-5T-6R-7R-8T-9F
@FLOW 1-2-3N-4-5Y-6-8NONE-9
@FLOW 8NEXT-3Y-8
@FLOW 5N-7-8
@BOX 1.0
OUTPUT BOX TEXT(LEVEL)
@BOX 2.0
STARTING WITH BOX 1
@BOX 3.0
BOX UNDEFINED OR NULL?
@BOX 4.0
OUTPUT "@BOX "
OUTPUT BOX NO
OUTPUT "."
OUTPUT LEVEL
OUTPUT NEWLINE
@BOX 5.0
ANY TEXT AT THIS LEVEL?
@BOX 6.0
OUTPUT TEXT UNTIL EOBWC
@BOX 7.0
OUTPUT NEWLINE
@BOX 8.0
INCREMENT BOX NO
@BOX 9.0
END
@BOX 1.1
PROC OUTBOXTEXT(LEV);
$IN I,J,CH;
@BOX 2.1
1 => I;
@BOX 3.1
IF T OF BOXTAB[I] < 2
@BOX 4.1
CAPTION(%"@BOX ");
OUTNUM(I);
OUTCH('.);
OUTCH(LEV + '0);
OUTCH('$L);
@BOX 5.1
IF LEV = 0 THEN
   LZPTR OF LZERO[I] => J;
ELSE
   TEXTPTR1 OF BOXTAB[I] => J;
FI
IF J = 0
@BOX 6.1
WHILE BTB[J] => CH /= EOBWC DO
   IF CH=CRWC OR CH=PWC THEN
      5 +> J;
   ELSE
       OUTCH(BTB[J]); 1 +> J;
   FI
OD
@BOX 7.1
NEWLINES(1);
@BOX 8.1
IF 1 +> I < BOXLIMIT
@BOX 9.1
END
@END
@TITLE DOC08.4.8(1,9)
@COL1S-2R-3R-4R-5R-6R-7R-8R-9F
@FLOW 1-2-3-4-5-6-7-8-9
@BOX 1.0
N
@BOX 2.0
SELECT FILE I/O
@BOX 3.0
OUTPUT CURRENT CHART
@BOX 4.0
SELECT ORIGINAL INPUT
OUTPUT TITLE
@BOX 5.0
OUTPUT "@COL 1S"
OUTPUT "@BOX 1.0"
@BOX 6.0
OUTPUT HEADING
@BOX 7.0
OUTPUT ENDING
@BOX 8.0
SELECT ORIGINAL OUTPUT
@BOX 9.0
END
@BOX 1.1
$PS OUTISTR();
$PR OUTISTR;
$IN CH;
WHILE INCH() => CH < %21 DO OD
WHILE CH > %20 DO
   OUTCH(CH);INCH()=>CH;
OD
END
@BOX 2.1
SELECTINPUT(CURIN);
SELECTOUTPUT(CUROUT);
@BOX 3.1
OUTPUT.CURRENT.CHART();
@BOX 4.1
SELECT.INPUT(OLDIN);
CAPTION(%"@TITLE ");
OUTISTR();
@BOX 5.1
CAPTION(%"$L@COL 1S$L@BOX 1.0$L");
@BOX 6.1
OUTISTR();
@BOX 7.1
CAPTION(%"$L@END$L$P");
@BOX 8.1
SELECTOUTPUT(OLDOUT);
@BOX 9.1
::END
@END

