@X @~
~V7 56 2 -5
~D10
~H                    MUSS
~
~
~D10
~H         NMSL051
~D10
~MMANCHESTER UNIVERSITY  -  CONFIDENTIAL
~
~
                                                           ISSUE 11~
~V9 -1
~P
~V9 1
~YMSL051
~S1~M~OMSL IMPLEMENTATION DESCRIPTION~
~S1~M~OSection 5  Version 1~
~S1~OSection 5.1 Declarative Statement Processing
~S1~O1. General Description~
~BThis section deals with the processing of declarative statements,
which results in the building up of property list information.
It contains procedures
that correspond with the declaratives of MUSL.
~S1~O2.2 Software Interface~
~
~
MOD.HEAD~
DECL.PROC~
ADD.LSPEC~
PROC.HEAD~
BEGIN.ST~
DECL.TYPE~
DECL.VAR~
DECL.FIELD~
DECL.SPACE~
DECL.LIT~
DECL.LAB~
DECL.DVEC~
DECL.IMPORT~
END.ST~
DECL.VSTORE~
COMP.TYPE~
PLIST~
TLIST~
PARAMS~
LASTMN~
CURLEV~
CURRES~
CURPROC~
CURBLK~
GLEV~
~S1~O3. Implementation~
~S1~O3.1 Outline of Operation~
~BThe procedures in this section generally relate to MUSL
declaratives that fall mainly into two
categories. Mostly they are concerned with assigning
meanings to names. The second smaller group partition
a program into modules, procedures and blocks.
Finally there is a procedure to generate LSPECS for a library
operand using the *LIB directive.
~BEach procedure that is concerned with assigning a
meaning to a name has to~
~
~Mcheck for syntax errors~
~Nallocate a MUTL name~
~Ndeclare the name to MUTL~
~Nand note its properties (on PLIST).~
~
At 'itemise' time an internal identifier (INTID) is allocated to
each name.
MUTL names are allocated to INTIDs (see section 8) by a procedure
DECLARE.N, which is contained in Section 8, and this
procedure checks that the name corresponding to the INTID has not been previousl
y
declared in the current block.~
~BWhen a procedure heading is encountered (PROC.HEAD) a check is first made
that its specification has previously been given and that the
procedure is not already defined. Next, the PARAMETER properties
from the specification, (if any), are used
to make entries for the parameters on the property list (PLIST).
A check is
made that the number of parameters given in the heading corresponds
with that given in the specification.
At the start of a procedure various global variables of the compiler must
be preserved, for restoring at the corresponding END statement.
They are then set to the appropriate initial values for the procedure.
These variables are noted in the CON.STK. They are~
~
~MCURGLB~
~NCURLEV~
~NCURRES~
~NCURPROC~
~NCURBLK~
~NGLEV~
~NLASTN~
~NLASTCH~
~
Also the global variable PROCLEV is incremented.
Finally the
procedure heading is declared to MUTL
and a *GLOBAL 0 is generated.
Since MUTL will already have the procedure specification,
declarations for the parameters will be
implicit.
In the BEGIN case only CURBLK, LASTN and LASTCH need to be stacked and reset.~
~BAn END statement may terminate a DATAVEC an ALTERNATIVE
statement, a BEGIN block or a PROC.
The first is normally detected directly by DECL.DVEC and for the
others the CON.STK entry defines the associated heading.
Context is tested for each possibility in turn.
Tests are made for incomplete control
constructs. If any exist, faults are monitored and appropriate
OD and FI statements are generated.
In the case of a PROC the global variable PROCLEV is
decremented.~
~BAlso, for all types of level a suitable MUTLEND is invoked,
and those global variables preserved at the procedure/block
heading in the CON.STK, (see above) are restored.~
~BA comment about literals might also be helpful. Those of type
INTEGER can be computed. For example,~
~
~MLITERAL/INTEGER    COUNT = SZ - 1;~
~
for this reason the values of INTEGER literals are
kept in the DETAIL field on PLIST.
In all other cases the value of the literal is passed
to MUTL and the DETAIL field is not used.~
~S1~O3.2 Data Structures~
~BThe main data structure used by this section is a property list (PLIST), that
is indexed by MUTL name. It contains type and
kind information relating to the MUTL names.
In addition it contains information that relates to the mapping
of user names into MUTL names that is required by Section 8.
This information may change with different versions of Section 8 hence
PLIST is formally treated as a data structure of Section 8, only the
three fields relevant to this section are described here. There are
also some scalar variables that record specially significant
positions in
the property list such as CURLEV which gives the index of
the first entry in the current PROC. These are best shown
pictorially~
~Q 25
~
~
~M~O                 PLIST               ~O           ~
~N|                                   |~
~N|                                   |~
~N|                                   |~
~N|                                   |~
~N|                                   |~
~N|                                   |~
~N|                                   |<---GLEV~
~N|                                   |~
~N|                                   |~
~N|                                   |~
~N|                                   |<----CURPROC~
~N~O|                                   |~
~N~O| SEE SECT.8|K(KIND) |T(TYPE)|DETAIL|~
~N|                                   |~
~N|                                   |<----CURLEV~
~N|                                   |~
~N|                                   |<----CURRES~
~N|                                   |~
~N|                                   |<----CURBLK~
~N|                                   |~
~N|                                   |<----LASTMN~
~
~
~T# 12
~
PLIST -~Ithis has an entry for each current MUTL name (MUTLN) which
is indexed by the MUTLN. Each entry has three fields
relevant to this section~
~
#K      - this field gives the kind of the~
#         entity to which it relates as~
#         follows~
#           0 UNDEF (only relevant in position 0~
#             and compiler names)~
#           1 PSPEC (the specification of an~
#             undefined PROC)~
#           3 PROC (the specification of a~
#             defined PROC)~
#           4 VARiable (which includes~
#             scalars, vectors, data vectors~
#             and parameters)~
#           5 FIELD (in fact the associated~
#             pointer)~
#           6 TYPE~
#           7 LITeral~
#           8 SPACE~
#           9 Type REFerence~
#          10 EXPORT (only relevant in position 1)~
#          11 Data VEC~
#          13 GLAB (a global label)~
#          14 LAB (defined label)~
#          15 LABREF (undefined label)~
#          16 IMPLAB~
~
#T        - this field gives the MUTL type~
#           encoding for the entity. In the case~
#           of a PROC SPEC it is the type of the~
#           result~
~
#DETAIL   - this field is unused except in KINDs~
#           1, 2 and 5. In the case of variables~
#           it gives a dimension for vectors and~
#           is zero for scalars. In the other~
#           cases it is an index into a list~
#           containing supplementary information.~
~
PARAMS  -~Ithis list (of integers) gives the parameter information for procedure
s.
It is indexed by the DETAIL field of a PROPLIST entry for a PSPEC.
For each procedure there is a sequence of integers giving
the MUTL type of each.
This is preceded by an integer giving the number of
parameters in the procedure.~
~
LASTP   -~Iis the index of the last used entry in PARAMS.~
~
TLIST  -~Ithis list (of 16 bit logicals) gives the field information for user de
fined types.
There are two elements for each field. The first gives its
MUTL type and the second is its INTID.
Vector instances of types have bit %4000 set and
ADDR PROC variables are coded as %8000 'or'ed with the
MUTLN of the procedure specification.
This list of field type and identifiers is preceded by an
entry giving the number of fields in an aggregate type
declaration. Alternative definitions of an aggregate type
have a one set in the top bit (%8000) of this entry,
except for the last definition of this union type.~
~
LASTT  -~Iis the index of the last used entry in TLIST.~
~
PROCLEV-~Ithis is an integer which indicates the depth of procedure
nesting. It is initialised to 0.~
~
GLEV   -~Ithis variable contains the index of the first entry on
PLIST for the current second level procedure. Hence
accessible non-local variables satisfy MUTLN<GLEV
Initially this variable will be set to the maximum MUTLN
and when the procedure nesting is only one level deep it will
be the same as CURLEV.~
~
CURPROC-~Ithis variable is an index to the proc spec of the
procedure whose body is currently being compiled
(or -1 if none).~
~
CURLEV -~Ithis variable is the index of the first entry on the PROP list
for the current innermost procedure. Hence local names
satisfy MUTLN~C>CURLEV~
~
CURRES -~Ithis variable is an index to the variable created for
the result of the current procedure~
~
CURBLK -~Ithis variable is an index to the first entry on the
PROP list for the current block. Hence local labels
satisfy MUTLN~C>CURBLK.~
~
LASTMN  -~Ithis is the last allocated MUTL name.~
~Y
~V9 -1
~P
~V9 -1
~D15
~HFLOWCHARTS
~
~
~H              NMSL051
~V9 -1
~F
@TITLE MSL05(1,11)
@COL 1S-2R-3R-4R-5R-6F
@FLOW 1-2-3-4-5-6
@BOX 1.0
DECLARATIVE STATEMENT
PROCESSING SECTION
@BOX 2.0
   .
@BOX 3.0
   .
@BOX   4.0
MOD.HEAD     MSL05.1
DECL.PROC    MSL05.2
ADD.LSPEC    MSL05.3
PROC.HEAD    MSL05.4
BEGIN.ST     MSL05.5
DECL.TYPE    MSL05.6
DECL.VAR     MSL05.7
DECL.FIELD   MSL05.8
DECL.SPACE   MSL05.9
DECL.LIT     MSL05.10
DECL.LAB     MSL05.11
DECL.DVEC    MSL05.12
DECL.IMPORT  MSL05.14
END.ST       MSL05.15
DECL.VSTORE  MSL05.16
COMP.TYPE    MSL05.17
EVAL.LIT     MSL05.20
COMP.DIM     MSL05.18
CHECK.LIT    MSL05.19
END.CHECKS   MSL05.21
EVAL.CONST   MSL05.22
@BOX 5.0
     .
@BOX 6.0
END
@BOX 1.1
#MSL05/1
MODULE(MOD.HEAD,DECL.PROC,ADD.LSPEC,DECL.FN,PROC.HEAD,BEGIN.ST,END.ST,INITS5,
DECL.TYPE,DECL.VAR,DECL.FIELD,DECL.SPACE,DECL.LIT,DECL.LAB,DECL.DVEC,
DECL.IMP,DECL.VSTORE,TLIST,PARAMS,KSPACE,KPROC,KFIELD,KPSPEC,COMP.TYPE,
::TEMP MOVE TO SEC 2 PLISTENT,PLIST,KLAB,KLABREF,KVAR,KDUMMY,KGLAB,KTREF,KTYPE,K
IMPLAB,
LASTMN,CURLEV,CURRES,CURPROC,CURBLK,GLEV,EVAL.CONST,END.CHECKS,PROCLEV,EVAL.LIT)
;
@BOX 1.2
#include <stdio.h>
#include <memory.h>

typedef struct { unsigned char TAG, ST; unsigned short IND; } ITYPE;
typedef unsigned char      uint8;
typedef short              int16;
typedef unsigned short     uint16;
typedef int                int32;
typedef unsigned int       uint32;
typedef long long          t_int64;
typedef unsigned int       uint32;
typedef unsigned long long t_uint64;

#define LBUFFZ 125
#define CLISTZ 125
#define PLISTZ 320
#define PARAMSZ 270
#define TLISTZ 250
#define NLISTZ 340
#define CHLISTZ 4100
#define SDLIST 87
extern ITYPE DIF;
extern ITYPE DTHEN;
extern ITYPE DELSE;
extern ITYPE DDO;
extern ITYPE DVSTORE;
extern ITYPE DTY;
extern ITYPE DEND;
extern ITYPE DDATAVEC;
extern ITYPE DADDR;
extern ITYPE DLA;
extern ITYPE DFROM;
extern ITYPE DOF;
extern ITYPE DIS;
extern ITYPE DAND;
extern ITYPE DOR;
extern ITYPE LTHAN;
extern ITYPE EQUALS;
extern ITYPE GTHAN;
extern ITYPE PLUS;
extern ITYPE MINUS;
extern ITYPE SLASH;
extern ITYPE GOTO;
extern ITYPE DAMPAND;
extern ITYPE DBANG;
extern ITYPE DEREF;
extern ITYPE HASH;
extern ITYPE REF;
extern ITYPE COMMA;
extern ITYPE LSB;
extern ITYPE RSB;
extern ITYPE LB;
extern ITYPE RB;
extern ITYPE BSLASH;
extern ITYPE XCOLON;
extern ITYPE COLON;
extern ITYPE UMINUS;
extern ITYPE EOS;
extern ITYPE LSHIFT;
extern ITYPE ASTERISK;
extern ITYPE EOL;
extern ITYPE DIMPORT;
#define KLAB 14
#define KLABREF 15
#define KVAR 4
#define KDUMMY 0
#define KGLAB 13
#define KIMPLAB 16
#define KTREF 9
#define KTYPE 6
#define NIL NULL
#define TADPROC 0x24
#define CONSTKZ 500
typedef struct { unsigned short MUTLN,MUSLN,HASH;} NLISTENT;
typedef struct { unsigned short INTID,PREVN,K,T; int32 DETAIL; } PLISTENT;
extern NLISTENT NLIST[NLISTZ];
extern PLISTENT PLIST[PLISTZ];
extern unsigned char CHLIST[CHLISTZ];
extern unsigned char XNAME[64];

#define MAXKEYWORD 45
#define TINT0 0x40
#define TLO8 0x80
#define TLO0 0x80
#define TLO1 0x20
#define STRINGTYPE 0x83
#define TINT16 0x44
#define TINT32 0x4C
#define TINT64 0x5C
#define TLO32 0x8C
#define TRE0 0x00
#define TLAB 0x30

#define KEYWORD 44
#define TDELIM 0
#define TNAME 1
#define TSTRING 2
#define TCONST 3

#define IEOS 0
#define IBYTE 29
#define IMINCOMP 46
#define ILOAD 51
#define ISTORE 61
#define ICOMP 71

// FROM NMSL051
#define KPSPEC 1
#define KPROC 3
#define KVAR 4
#define KFIELD 5
#define KTYPE 6
#define KLIT 7
#define KSPACE 8
#define KTREF 9
#define KEX 10
#define KDVEC 11
#define KDUMMY 0
#define KLAB 14
#define KLABREF 15
#define KGLAB 13
#define KIMPLAB 16

#MSL05/1
@BOX 2.1
::TEMP MOVE TO SEC 2 $TY PLIST.ENT $IS $LO16 INTID,PREVN,K,T $IN32 DETAIL;
@BOX 2.2
//TEMP MOVE TO SEC 2 $TY PLIST.ENT $IS $LO16 INTID,PREVN,K,T $IN32 DETAIL;
@BOX 3.1
*GLOBAL 5;
::TEMP MOVE TO SEC 2 PLIST.ENT [PLISTZ] PLIST;
$IN [PARAMSZ] PARAMS;
$IN [TLISTZ] TLIST;
$IN LASTMN,CURLEV,CURRES,CURPROC,CURBLK,GLEV;
PLISTZ => GLEV;
$LI KPSPEC = 1,KPROC = 3,KVAR=4,KFIELD=5,
KTYPE = 6,KLIT = 7,KSPACE = 8,
KTREF = 9,KEX =10,KDVEC =11,KDUMMY = 0,
KLAB = 14,KLABREF=15,KGLAB=13,KIMPLAB=16;
$IN PROCLEV,LASTT,LASTP;
PLISTZ => GLEV;
@BOX 3.2
//TEMP MOVE TO SEC 2 PLIST.ENT [PLISTZ] PLIST;
int PARAMS[PARAMSZ];
int TLIST[TLISTZ];
int LASTMN,CURLEV,CURRES,CURPROC,CURBLK,GLEV;
GLEV = PLISTZ;
//#define KPSPEC 1
//#define KPROC 3
////#define KVAR 4
//#define KFIELD 5
////#define KTYPE 6
//#define KLIT 7
//#define KSPACE 8
////#define KTREF 9
//#define KEX 10
//#define KDVEC 11
////#define KDUMMY 0
////#define KLAB 14
////#define KLABREF 15
////#define KGLAB 13
////#define KIMPLAB 16
int PROCLEV,LASTT,LASTP;
@BOX 4.1
$PS MOD.HEAD();
$PS DECL.PROC($IN);
$PS ADD.LSPEC($LO16)/$LO16;
$PS PROC.HEAD();
$PS BEGIN.ST();
$PS DECL.TYPE($LO);
$PS DECL.VAR();
$PS DECL.FIELD();
$PS DECL.SPACE();
$PS DECL.LIT();
$PS DECL.LAB();
$PS DECL.DVEC();
$PS DECL.IMP();
$PS END.ST();
$PS DECL.VSTORE();
$PS ENDCHECKS();
$PS CHECK.LIT($IN,$IN)/$IN;
$PS EVAL.LIT($IN,$IN)/$IN32;
$PS EVAL.CONST()/$IN32;
$PS COMP.TYPE()/$IN;
$PS COMP.DIM()/ADDR;
::PDP *CODE 2;
#MSL05.1
#MSL05.2
#MSL05.3
#MSL05.4
::PDP *CODE 1;
#MSL05.5
::PDP *CODE 2;
#MSL05.6
::PDP *CODE 1;
#MSL05.7
::PDP *CODE 3;
#MSL05.8
::PDP *CODE 2;
#MSL05.9
#MSL05.10
::PDP *CODE  1;
#MSL05.11
::PDP *CODE 2;
#MSL05.12
#MSL05.14
::PDP *CODE 1;
#MSL05.15
::PDP *CODE 2;
#MSL05.16
::PDP *CODE 1;
#MSL05.17
#MSL05.18
#MSL05.19
#MSL05.20
#MSL05.21
#MSL05.22
@BOX 4.2
void MODHEAD(void);
void DECLPROC(int);
uint16 ADDLSPEC(uint16);
void PROCHEAD(void);
void BEGINST(void);
void DECLTYPE(uint);
void DECLVAR(void);
void DECLFIELD(void);
void DECLSPACE(void);
void DECLLIT(void);
void DECLLAB(void);
void DECLDVEC(void);
void DECLIMP(void);
void ENDST(void);
void DECLVSTORE(void);
void ENDCHECKS(void);
int CHECKLIT(int, int);
int32 EVALLIT(int, int);
int32 EVALCONST(void);
int COMPTYPE(void);
void *COMPDIM(void);
//PDP *CODE 2;
#MSL05.1
#MSL05.2
#MSL05.3
#MSL05.4
//PDP *CODE 1;
#MSL05.5
//PDP *CODE 2;
#MSL05.6
//PDP *CODE 1;
#MSL05.7
//PDP *CODE 3;
#MSL05.8
//PDP *CODE 2;
#MSL05.9
#MSL05.10
//PDP *CODE  1;
#MSL05.11
//PDP *CODE 2;
#MSL05.12
#MSL05.14
//PDP *CODE 1;
#MSL05.15
//PDP *CODE 2;
#MSL05.16
//PDP *CODE 1;
#MSL05.17
#MSL05.18
#MSL05.19
#MSL05.20
#MSL05.21
#MSL05.22
@BOX 5.1
$PS INIT.S5();
$PR INIT.S5;
0  => PROCLEV => LASTT => LASTP;
-1 => CURPROC => CURRES;
1 => LASTMN => CURBLK => CURLEV;

0 => K OF PLIST[0];
KEX => K OF PLIST[1];
$EN
@BOX 5.2
void INITS5(void);
void INITS5(void)
{
  PROCLEV = 0;
  LASTT = 0;
  LASTP = 0;
  CURPROC = -1;
  CURRES = -1;
  LASTMN = 1;
  CURBLK = 1;
  CURLEV = 1;
  
  PLIST[0].K = 0;
  PLIST[1].K = KEX;
}
@BOX 6.1
*END
@BOX 6.2
@END
@TITLE MSL05/1(1,11)
@COL 1S
@BOX 1.0
EXTERNAL ENVIRONMENT
@BOX 1.1
$LS SELECT.OUTPUT($IN);
$LS NEWLINES($IN);
$LS FIND.N(ADDR[$LO8],$IN)/$LO32;
$LS FIND.P($LO32,$IN,$IN)/$IN;
$LS CAPTION($AD[$LO8]);
$LS TL.PROC.KIND($IN);
$LS TL.PROC.PARAM($IN,ADDR);
$LS TL.PROC.RESULT($IN);
$LS TL.PROC($IN);
$LS TL.DATA.AREA($IN);
$LS TL.BLOCK();
$LS TL.TYPE.COMP($IN,ADDR,ADDR[$LO8]);
$LS TL.END.TYPE($IN);
$LS TL.S.DECL(ADDR[$LO8],$IN,ADDR);
$LS TL.PL($IN,$IN);
$LS TL.SELECT.VAR();
$LS TL.SELECT.FIELD($IN,$IN,$IN);
$LS TL.SPACE(ADDR);
$LS TL.C.LIT.32($IN,$IN32);
$LS TL.C.LIT.16($IN,$IN16);
$LS TL.ASS($IN,$IN);
$LS TL.C.LIT.S($IN,$AD[$LO8]);
$LS TL.ASS.VALUE($IN,$IN);
$LS TL.ASS.END();
$LS TL.LABEL($IN);
$LS TL.PROC.SPEC(ADDR[$LO8],$IN);
$LS TL.TYPE(ADDR[$LO8],$IN);
$LS TL.C.NULL($IN);
$LS TL.LIT(ADDR[$LO8],$IN);
$LS TL.END.PROC();
$LS TL.END.BLOCK();
$LS TL.LABEL.SPEC($AD[$LO8],$IN);
$LS TL.V.DECL(ADDR[$LO8],$LO32,$IN,$IN,$IN,ADDR);
$PS MONITOR($IN);
$PS ADDN()/$LO16;
$PS GENN($LO16)/ADDR[$LO8];
$PS ITEMISE($IN);
$PS TRANS.COMP($IN)/$IN;
$PS TRANS.END.ALT();
$PS TRANS.OD();
$PS TRANS.FI();
$PS DECLARE.N($LO16,$IN,$IN)/$LO16;
$PS DUMMY()/$LO16;
$PS MUTLN($LO16)/$LO16;
$PS EXPN($LO16);
$TY ITYPE IS $LO8 TAG,ST $LO16 IND;
ITYPE LB,COMMA,RB,SLASH,EQUALS,DOR,EOS,REF,LSB,RSB,DLA,DWITHIN,
BSLASH,COLON,DEND,DTY,DVSTORE,LTHAN,GTHAN,DADDR,DIS,EOL;
$IN XNPTR,CONPTR,IX,IPTR,CUR.GLB,MSTR,MUTLSTR;
$IN TINT;
$IM $LI CONSTKZ,PARAMSZ,TLISTZ;
$IN [CONSTKZ] CONSTK;
$IM $LI CHLISTZ;
$LO8 [CHLISTZ] CHLIST;
$IM $LI LBUFFZ;
ITYPE [LBUFFZ] LBUFF;
$IM $LI TDELIM,TLO1;
$IM $LI TCONST,TNAME;
$IM $LI NLISTZ,PLISTZ;
$TY NLIST.ENT IS $LO16 MUTLN,MUSLN,HASH;
NLIST.ENT[NLISTZ] NLIST;
$TY PLISTENT IS $LO16 INTID,PREVN,K,T $IN32 DETAIL; ::TEMP MOD
PLISTENT [PLISTZ] PLIST; ::TEMP MOD
$IN LASTN,LASTCH;
$LO8 [64] XNAME;
$IM $LI TADPROC,TRE0,TINT0;
$IM $LI CLISTZ;
$LO8 [CLISTZ] CLIST;
$LI/ADDR[$LO8] NIL =;
$IM $LI TLO8,TLAB,TINT16,TINT32;
$IN TVST,TBYADDR;
$IM $LI SDLIST;
$LO16[SDLIST] DLIST;
$IN MAXMUTLN,MAXN,MAXCH;
$IM $LI TLO0;
$LI AOPD = %3000;
@BOX 1.2
// LIBSPECs moved to NMSL021
// PSPECS moved to NMSL021
//$TY ITYPE IS $LO8 TAG,ST $LO16 IND;
//ITYPE LB,COMMA,RB,SLASH,EQUALS,DOR,EOS,REF,LSB,RSB,DLA,DWITHIN,
//BSLASH,COLON,DEND,DTY,DVSTORE,LTHAN,GTHAN,DADDR,DIS,EOL;
int XNPTR,CONPTR,IX,IPTR,CURGLB,MSTR,MUTLSTR;
int TINT;
//$IM $LI CONSTKZ,PARAMSZ,TLISTZ;
extern int CONSTK[CONSTKZ];
//$IM $LI CHLISTZ;
uint8 CHLIST[CHLISTZ];
//$IM $LI LBUFFZ;
extern ITYPE LBUFF[LBUFFZ];
//$IM $LI TDELIM,TLO1;
//$IM $LI TCONST,TNAME;
//$IM $LI NLISTZ,PLISTZ;
//$TY NLIST.ENT IS $LO16 MUTLN,MUSLN,HASH;
NLISTENT NLIST[NLISTZ];
//$TY PLISTENT IS $LO16 INTID,PREVN,K,T $IN32 DETAIL; ::TEMP MOD
//PLISTENT [PLISTZ] PLIST; ::TEMP MOD
int LASTN,LASTCH;
uint8 XNAME[64];
//$IM $LI TADPROC,TRE0,TINT0;
//$IM $LI CLISTZ;
uint8 CLIST[CLISTZ];
//$LI/ADDR[$LO8] NIL =;
//$IM $LI TLO8,TLAB,TINT16,TINT32;
int TVST,TBYADDR;
//$IM $LI SDLIST;
uint16 DLIST[SDLIST];
int MAXMUTLN,MAXN,MAXCH;
//$IM $LI TLO0;
#define AOPD 0x3000;
@END
@TITLE MSL05.1(1,7)
@COL 10R
@COL 1S-2R-9T-14R-12T-13R-3T-4T-15T-16R-5R-6T-7T-11R-8F
@COL 17R
@ROW 7-17
@ROW 10-8
@FLOW 1-2-9Y-14-12Y-13-3Y-4N-15N-10
@FLOW 15Y-16-4
@FLOW 3N-17-11
@FLOW 4Y-5-6N-7Y-11-8
@FLOW 6Y-4
@FLOW 7N-10
@FLOW 9N-10
@FLOW 12N-3
@BOX 1.0
MOD.HEAD
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
IS THE NEXT ITEM '('?
@BOX 4.0
IS THE NEXT ITEM A NAME?
@BOX 5.0
MARK NAME ON NLIST AS
MODULE INTERFACE ENTITY
@BOX 6.0
IS THE NEXT ITEM ','?
@BOX 7.0
IS THE NEXT ITEM ')'?
@BOX 8.0
END
@BOX 9.0
IS THE CONTEXT PREMODULE
@BOX 10.0
FAULT
@BOX 11.0
SKIP EOL IF ANY
RESET IMPORT BIT OF IX
@BOX 12.0
IS NEXT ITEM A NAME?
@BOX 13.0
NOTE AS PREFIX OF
EXPORT NAMES
@BOX 14.0
INIT MODULE PREFIX
SET 'IN MODULE' CONTEXT
PRINT HEADING

@BOX 15.0
IS THE NEXT ITEM EOS
@BOX 16.0
CALL ITEMISE
@BOX17.0
ADJUST ITEM
POINTER
@BOX 1.1
$PR MOD.HEAD;
@BOX 1.2
void MODHEAD(void)
{
@BOX 2.1
$IN I,J,K;
@BOX 2.2
int I,J,K;
@BOX 3.1
$IF LBUFF[1+>IPTR] /= LB
@BOX 3.2
if (memcmp(&LBUFF[++IPTR], &LB, sizeof(ITYPE)) != 0)
@BOX 4.1
$IF TAG OF LBUFF[1+>IPTR]=1
@BOX 4.2
if (LBUFF[++IPTR].TAG == 1)
@BOX 5.1
EXPN(IND OF LBUFF[IPTR]);
@BOX 5.2
EXPN(LBUFF[IPTR].IND);
@BOX 6.1
$IF LBUFF[1+>IPTR] = COMMA
@BOX 6.2
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX 7.1
$IF LBUFF[IPTR]/=RB
@BOX 7.2
if (memcmp(&LBUFF[IPTR], &RB, sizeof(ITYPE)) != 0)
@BOX 8.1
$EN
@BOX 8.2
;
// BOX 8.2
}
@BOX 9.1
$IF CONSTK[CONPTR] /= 7
@BOX 9.2
if (CONSTK[CONPTR] != 7)
@BOX 10.1
MONITOR(0);
@BOX 10.2
MONITOR(0);
@BOX11.1
$IF LBUFF[IPTR+1] = EOL $TH 1+>IPTR $FI
0 => IX;
@BOX11.2
if (memcmp(&LBUFF[IPTR+1], &EOL, sizeof(ITYPE)) == 0)
{
  IPTR++;
}
IX = 0;
@BOX 12.1
$IF TAG OF LBUFF[1+IPTR] /= 1
@BOX 12.2
if (LBUFF[1+IPTR].TAG != 1)
@BOX 13.1
MUSLN OF NLIST[IND OF LBUFF[1+>IPTR] => K] => I
$FO J < HASH OF NLIST[K] & %3F $DO
CHLIST [I+J] => XNAME [1 +> XNPTR] $OD
@BOX 13.2
K = LBUFF[++IPTR].IND;
I = NLIST[K].MUSLN;
for (J = 0; J < (NLIST[K].HASH & 0x3F); J++)
{
  XNAME[++XNPTR] = CHLIST[I+J];
}
@BOX 14.1
-1 => XNPTR;
6 => CONSTK[CONPTR];
MONITOR(200);
@BOX 14.2
XNPTR = -1;
CONSTK[CONPTR] = 6;
MONITOR(200);
@BOX 15.1
$IF LBUFF[IPTR] /= EOL
@BOX 15.2
if (memcmp(&LBUFF[IPTR], &EOL, sizeof(ITYPE)) != 0)
@BOX 16.1
ITEMISE(1);
@BOX 16.2
ITEMISE(1);
@BOX17.1
1 -> IPTR;
@BOX17.2
IPTR--;
@END
@TITLE MSL05.2(1,8)
@COL 14R
@COL 1S-2R-23R-3T-4R-5T-21R-6T-7R-8T-9T-22R-10T-11R-12R-13F
@COL 16T-17T-18R-19R-20R
@ROW 6-16
@ROW 10-20
@ROW 14-11
@FLOW 1-2-23-3Y-4-5Y-21-6N-7-8N-9Y-22-10Y-11-12-13
@FLOW 3N-20
@FLOW 5N-16Y-17Y-18-19-12
@FLOW 6Y-22
@FLOW 8Y-7
@FLOW 9N-20
@FLOW 10N-14-12
@FLOW 16N-20
@FLOW 17N-20
@BOX 1.0
DECL.PROC
@BOX 2.0
@BOX 3.0
NEXT ITEM
A NAME?
@BOX 4.0
CREATE MUTLN DECLARE IT TO MUTL
@BOX 5.0
NEXT ITEM '('?
@BOX 6.0
NEXT ITEM ')'?
@BOX 7.0
ADD PARAM TYPE TO PLIST
AND DECLARE IT TO MUTL
@BOX 8.0
NEXT ITEM ','?
@BOX 9.0
NEXT ITEM ')'?
@BOX 10.0
NEXT ITEM '/'?
@BOX 11.0
FORM RESULT TYPE
@BOX 12.0
NOTE RESULT TYPE ON PLIST
DECLARE IT TO MUTL
@BOX 13.0
EXIT
@BOX 14.0
SET RESULT
TYPE TO NIL
@BOX 16.0
NEXT ITEM '='?
@BOX 17.0
NEXT ITEM
A PROC NAME?
@BOX 18.0
DUPLICATE PLIST POINTER
AND DECLARE PARAMS TO MUTL
@BOX 19.0
FORM RESULT TYPE
@BOX 20.0
FAULT
@BOX21.0
SETPOINTER TO PLIST
@BOX22.0
PUT PARAM COUNT IN PARAMS
@BOX23.0
SET PROC KIND=2
IF PROCLEV=1
@BOX 1.1
$PR DECL.PROC(NAT);
@BOX 1.2
void DECLPROC(int NAT)
{
@BOX 2.1
$IN ID,N,N1,T.RES,DUPLN,TEMP,I;
@BOX 2.2
int ID,N,N1,TRES,DUPLN,TEMP,I;
@BOX 3.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 3.2
if (LBUFF[++IPTR].TAG != 1)
@BOX 4.1
DECLARE.N(IND OF LBUFF[IPTR]=>ID,KPSPEC,0)=>N;
IX +> NAT;
IF NAT&8 /= 0 THEN %8000 &> IX FI
TL.PROC.SPEC(GENN(ID),NAT);
@BOX 4.2
ID = LBUFF[IPTR].IND;
N = DECLAREN(ID,KPSPEC,0);
NAT += IX;
if ((NAT & 8) != 0)
{
  IX &= 0x8000;
}
TLPROCSPEC(GENN(ID),NAT);
@BOX 5.1
$IF LBUFF[1+>IPTR]/=LB
@BOX 5.2
if (memcmp(&LBUFF[++IPTR], &LB, sizeof(ITYPE)) != 0)
@BOX 6.1
$IF LBUFF[1+IPTR]=RB
@BOX 6.2
if (memcmp(&LBUFF[++IPTR], &RB, sizeof(ITYPE)) == 0)
@BOX 7.1
IF COMP.TYPE()=>PARAMS[1+>LASTP] => TEMP & %8000 /=0 $TH
TADPROC => TEMP FI
TL.PROCPARAM(TEMP,0);
IF LASTP >= PARAMSZ THEN
SELECTOUTPUT(MSTR);NEWLINES(0);
CAPTION(%"PARAM LIST");MONITOR(9);FI
@BOX 7.2
TEMP = COMPTYPE();
PARAMS[++LASTP] = TEMP;
if ((TEMP & 0x8000) != 0)
{
  TEMP = TADPROC;
}
TLPROCPARAM(TEMP,0);
if (LASTP >= PARAMSZ)
{
  SELECTOUTPUT(MSTR);
  NEWLINES(0);
  CAPTION("PARAM LIST");
  MONITOR(9);
}
@BOX 8.1
$IF LBUFF[1+>IPTR]=COMMA
@BOX 8.2
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX 9.1
1 -> IPTR;
$IF LBUFF[IPTR + 1]/= RB
@BOX 9.2
IPTR--;
if (memcmp(&LBUFF[IPTR + 1], &RB, sizeof(ITYPE)) != 0)
@BOX 10.1
$IF LBUFF[2+>IPTR]/=SLASH
@BOX 10.2
IPTR += 2;
if (memcmp(&LBUFF[IPTR], &SLASH, sizeof(ITYPE)) != 0)
@BOX 11.1
COMP.TYPE()=>T.RES;
@BOX 11.2
TRES = COMPTYPE();
@BOX 12.1
IF T.RES=>T OF PLIST[N] & %8000 /=0 $TH
TADPROC => T.RES FI
TL.PROC.RESULT(T.RES);
@BOX 12.2
PLIST[N].T = TRES;
if ((TRES & 0x8000) !=0)
{
  TRES = TADPROC;
}
TLPROCRESULT(TRES);
@BOX 13.1
$EN
@BOX 13.2
//13.2
;
}
@BOX 14.1
0 => T.RES;
1 -> IPTR;
@BOX 14.2
TRES = 0;
IPTR--;
@BOX 16.1
$IF LBUFF[IPTR]/=EQUALS
@BOX 16.2
if (memcmp(&LBUFF[IPTR], &EQUALS, sizeof(ITYPE)) != 0)
@BOX 17.1
$IF TAG OF LBUFF[1+>IPTR]/=1
$OR MUTLN(IND OF LBUFF[IPTR])
=> DUPLN = 0 $OR K OF PLIST[DUPLN]>2
@BOX 17.2
DUPLN = MUTLN(LBUFF[IPTR].IND);
if ((LBUFF[++IPTR].TAG != 1) || (DUPLN == 0) || (PLIST[DUPLN].K > 2))
@BOX 18.1
DETAIL OF PLIST[DUPLN]
=>DETAIL OF PLIST[N] => N1;
$FO PARAMS[N1] DO
TL.PROC.PARAM(PARAMS[1+>N1],0)OD
@BOX 18.2
N1 = PLIST[DUPLN].DETAIL;
PLIST[N].DETAIL = N1;
for (int i = 0; i < PARAMS[N1]; i++)
{
  TLPROCPARAM(PARAMS[++N1],0);
}
@BOX 19.1
T OF PLIST[DUPLN] => T.RES;
@BOX 19.2
TRES = PLIST[DUPLN].T;
@BOX 20.1
MONITOR(0);
@BOX 20.2
MONITOR(0);
@BOX 21.1
1+>LASTP => DETAIL OF PLIST[N] => I
@BOX 21.2
I = ++LASTP;
PLIST[N].DETAIL = I;
@BOX 22.1
LASTP-I=>PARAMS[I];
@BOX 22.2
PARAMS[I] = LASTP-I;
@BOX23.1
$IF PROCLEV=1 $TH
TL.PROC.KIND(2) $FI
@BOX23.2
if (PROCLEV == 1)
{
  TLPROCKIND(2);
}
@END
@TITLE MSL05.3(1,8)
@COL 1S-3T-4R-5R-6R-7R-8R-9F
@COL 10R
@ROW 8-10
@FLOW 1-3N-4-5-6-7-8-9
@FLOW 3Y-10-9
@BOX1.0
ADD.LSPEC(LIBN)
@BOX3.0
GET FINDN INDEX
IS IT ZERO?
@BOX4.0
CREATE MUTLN FOR
THIS LIBRARY PROC
DECLARE IT TO MUTL
@BOX5.0
ADD PARAMETER TYPES
AND DECLARE THEM TO MUTL
@BOX6.0
PUT PARAM COUNT
IN PARAMS
@BOX7.0
NOTE RESULT TYPE
ON PLIST
AND DECLARE IT
TO MUTL
@BOX8.0
SET RESULT AS MUTLN
@BOX9.0
END
@BOX10.0
SET RESULT = 0
@BOX1.1
PROC ADD.LSPEC(LIBN);
$IN J,K,M,N;
$LO32 F;
ADDR[$LO8] LNAME;
@BOX1.2
uint16 ADDLSPEC(uint16 LIBN)
{
uint16 result = 0;
int J,K,M,N;
uint32 F;
char *LNAME;
@BOX3.1
GENN(LIBN) => LNAME;
IF FIND.N(LNAME,0) => F = 0
@BOX3.2
LNAME = GENN(LIBN);
F = FINDN(LNAME,0);
if (F == 0)
@BOX4.1
DECLARE.N(LIBN,KPROC,0) => N;
TL.PROC.SPEC(LNAME,%8008);
@BOX4.2
N = DECLAREN(LIBN,KPROC,0);
TLPROCSPEC(LNAME,0x8008);
@BOX5.1
FIND.P(F,-1,0) => M;
1 +> LAST.P => DETAIL OF PLIST[N] => J;
FOR K < M DO
TL.PROC.PARAM(FIND.P(F,-1,K+1) => PARAMS[1 +> LAST.P],0) OD
@BOX5.2
M = FINDP(F,-1,0);
LASTP++;
PLIST[N].DETAIL = LASTP;
J = LASTP;
for (K = 0; K < M; K++)
{
  PARAMS[++LASTP] = FINDP(F,-1,K+1);
  TLPROCPARAM(PARAMS[LASTP],0);
}
@BOX6.1
M => PARAMS[J];
IF LAST.P > PARAMS.Z THEN
SELECT.OUTPUT(MSTR);
NEWLINES(0);CAPTION(%"PARAM LIST");
MONITOR(9) FI
@BOX6.2
PARAMS[J] = M;
if (LASTP > PARAMSZ)
{
  SELECTOUTPUT(MSTR);
  NEWLINES(0);
  CAPTION("PARAM LIST");
  MONITOR(9);
}
@BOX7.1
FIND.P(F,-1,M+1) => T OF PLIST[N] => J;
TL.PROC.RESULT(J);
@BOX7.2
PLIST[N].T = FINDP(F,-1,M+1);
J = PLIST[N].T;
TLPROCRESULT(J);
@BOX8.1
N => ADDLSPEC;
@BOX8.2
result = N;
@BOX9.1
END
@BOX9.2
;
// BOX 9.2
return result;
}
@BOX10.1
result = 0;
@END
@TITLE MSL05.4(1,6)
@COL 1S-2R-3T-5T-6R-7R-8T-9T-10T-11R-12T-13T-14R
@COL 17R-21T-22R-23F-18T
@ROW 6-17
@ROW 9-21
@ROW 13-18
@FLOW 1-2-3Y-5Y-6-7-8Y-9Y-10Y-11-12Y-13N-14
@FLOW 3N-14
@FLOW 9N-14
@FLOW 10N-14
@FLOW 5N-17
@FLOW 12N-18N-14
@FLOW 13Y-10
@FLOW 18Y-21
@FLOW 8N-21Y-22-23
@FLOW 21N-23
@BOX 1.0
PROC.HEAD
@BOX 2.0
DECLARATIONS
@BOX 3.0
NEXT ITEM
A NAME?
@BOX 5.0
IS NAME UNDEF LOCAL PSPEC
@BOX 6.0
PRINT HEADING
INCREMENT PROC LEV
MAKE PROCENTRY ON CONTEXT STACK
AND SET PLIST VARS
MARK PLIST ENTRY DEFINED
@BOX 7.0
DECLARE PROC.HEAD TO MUTL
GENERATE *GLOBAL 0
@BOX 8.0
ANY PARAMS
@BOX 9.0
NEXT ITEM '('?
@BOX 10.0
NEXT ITEM
A NAME?
@BOX 11.0
CREATE MUTL NAME FOR PARAM
AND MAKE ENTRY ON PLIST
@BOX 12.0
ANY MORE PARAMS
@BOX 13.0
NEXT ITEM ','?
@BOX 14.0
FAULT
@BOX 17.0
FAULT
@BOX 18.0
NEXT ITEM ')'?
@BOX21.0
ANY RESULT
@BOX22.0
CREATE MUTLN
FOR RESULT
@BOX23.0
EXIT
@BOX 1.1
$PR PROC.HEAD;
@BOX 1.2
void PROCHEAD(void)
{
@BOX 2.1
$IN PROCN,N,I,J;
@BOX 2.2
int PROCN,N,I,J;
@BOX 3.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 3.2
if (LBUFF[++IPTR].TAG != 1)
@BOX5.1
$IF MUTLN(IND OF LBUFF[IPTR])=>PROCN<CURLEV
$OR K OF PLIST[PROCN] /= KPSPEC
@BOX5.2
PROCN = MUTLN(LBUFF[IPTR].IND);
if ((PROCN < CURLEV) || (PLIST[PROCN].K != KPSPEC))
@BOX6.1
MONITOR(200);
1 +> PROC.LEV;
CUR.GLB => CONSTK[1+>CONPTR];
CUR.LEV => CONSTK[1+>CONPTR];
CURRES => CONSTK[1+>CONPTR];
CURPROC => CONSTK[1+>CONPTR];
CURBLK => CONSTK[1+>CONPTR];
GLEV => CONSTK[1+>CONPTR];
LASTN => CONSTK[1+>CONPTR];
LASTCH => CONSTK[1+>CONPTR];
4 => CONSTK[1 +> CONPTR];
1 + LASTMN => CUR.LEV => CURBLK;
PROCN => CURPROC; -1 => CURRES;
$IF PROCLEV < 3 $TH CURLEV => GLEV $FI
KPROC => K OF PLIST[PROCN];
@BOX6.2
MONITOR(200);
PROCLEV++;
CONSTK[++CONPTR] = CURGLB;
CONSTK[++CONPTR] = CURLEV;
CONSTK[++CONPTR] = CURRES;
CONSTK[++CONPTR] = CURPROC;
CONSTK[++CONPTR] = CURBLK;
CONSTK[++CONPTR] = GLEV;
CONSTK[++CONPTR] = LASTN;
CONSTK[++CONPTR] = LASTCH;
CONSTK[++CONPTR]= 4;
CURLEV = 1 + LASTMN;
CURBLK = CURLEV;
CURPROC = PROCN;
CURRES = -1;
if (PROCLEV < 3)
{
  GLEV = CURLEV;
}
PLIST[PROCN].K = KPROC;
@BOX 7.1
TL.PROC(PROCN);
TLDATAAREA(0=>CUR.GLB);
@BOX 7.2
TLPROC(PROCN);
CURGLB = 0;
TLDATAAREA(CURGLB);
@BOX 8.1
$IF PARAMS[DETAIL OF PLIST[PROCN]=>I]=>J=0
@BOX 8.2
I = PLIST[PROCN].DETAIL;
J = PARAMS[I];
if (J == 0)
@BOX 9.1
$IF LBUFF[1+>IPTR]/= LB
@BOX 9.2
if (memcmp(&LBUFF[++IPTR], &LB, sizeof(ITYPE)) != 0)
@BOX 10.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 10.2
if (LBUFF[++IPTR].TAG != 1)
@BOX 11.1
DECLAREN(IND OF LBUFF[IPTR],KVAR,PARAMS[1+>I])=>N;
0 => DETAIL OF PLIST[N];
@BOX 11.2
N = DECLAREN(LBUFF[IPTR].IND,KVAR,PARAMS[++I]);
PLIST[N].DETAIL = 0;
@BOX 12.1
$IF 1->J=0
@BOX 12.2
J--;
if (J == 0)
@BOX 13.1
$IF LBUFF[1+>IPTR]=COMMA
@BOX 13.2
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX 14.1
MONITOR(0);
@BOX 14.2
MONITOR(0);
@BOX 17.1
MONITOR(1);
@BOX 17.2
MONITOR(1);
@BOX 18.1
$IF LBUFF[1+>IPTR]=RB
@BOX 18.2
if (memcmp(&LBUFF[++IPTR], &RB, sizeof(ITYPE)) == 0)
@BOX 21.1
$IF T OF PLIST[PROCN]=>N = 0
@BOX 21.2
N = PLIST[PROCN].T;
if (N == 0)
@BOX 22.1
DUMMY() => CURRES;
N=>T OF PLIST[CURRES];
$IF N&%8000 /= 0 $TH
TADPROC => N$FI
TL.S.DECL(NIL,N,0);
@BOX 22.2
CURRES = DUMMY();
PLIST[CURRES].T = N;
if ((N & 0x8000) != 0)
{
  N = TADPROC;
}
TLSDECL(NULL,N,0);
@BOX 23.1
$EN
@BOX 23.2
;
// BOX 23.1
}
@END
@TITLE MSL05.5(1,6)
@COL 1S-3R-4R-5F
@FLOW 1-3-4-5
@BOX 1.0
BEGIN.ST
@BOX 3.0
MAKE ENTRY ON
CONTEXT STACK
CONTAINING CURBLK
@BOX 4.0
SET CURBLK TO
NEXT MUTL NAME
DECLARE BEGIN
TO MUTL
@BOX 5.0
EXIT
@BOX 1.1
$PR BEGIN.ST;
@BOX 1.2
void BEGINST(void)
{
@BOX 3.1
CUR.BLK => CON.STK[1+>CON.PTR];
LASTN => CONSTK[1+>CON.PTR];
LASTCH => CONSTK[1+>CON.PTR];
5 => CON.STK[1+>CON.PTR];
@BOX 3.2
CONSTK[++CONPTR] = CURBLK;
CONSTK[++CONPTR] = LASTN;
CONSTK[++CONPTR] = LASTCH;
CONSTK[++CONPTR] = 5;
@BOX 4.1
LASTMN + 1 => CUR.BLK;
TL.BLOCK();
@BOX 4.2
CURBLK = LASTMN + 1;
TLBLOCK();
@BOX 5.1
$EN
@BOX 5.2
;
// BOX 5.2
}
@END
@TITLE MSL05.6(1,11)
@COL 19R
@COL 1S-2R-3T-4T-5R-6R-18T-7R-8T-9R-10T-11T-12R-13T-14R-15F
@COL 22T-20T-16R-21R-23R
@ROW 19-7
@ROW 5-20
@FLOW 1-2-3Y-4Y-5-6-18Y-7-8Y-9-10N-11Y-12-18
@FLOW 3N-16
@FLOW 4N-22N-20N-16
@FLOW 22Y-23-15
@FLOW 20Y-21-15
@FLOW 8N-16
@FLOW 10Y-8
@FLOW 11N-13Y-14-15
@FLOW 18Y-19-11
@FLOW 13N-18
@BOX1.0
DECL TYPE
@BOX2.0
DECLARATIONS
@BOX3.0
IS THE NEXT ITEM A NAME
@BOX4.0
IS THE NEXT ITEM 'IS'
@BOX5.0
CREATE MUTLN DECLARE IT TO MUTL
@BOX6.0
INITIALISE TLIST ENTRY
@BOX7.0
COMPUTE FIELD TYPE
[MSL05.17]
AND DIMENSION
[MSL05.18]
@BOX8.0
NEXT ITEM A NAME
@BOX9.0
DECLARE FIELD TO MUTL
AND MAKE ENTRY ON TLIST
@BOX10.0
IS THE NEXT ITEM ','
@BOX11.0
IS THE NEXT ITEM OR
@BOX12.0
MAKE ALT ENTRY ON TLIST
DECLARE IT TO MUTL
@BOX13.0
IS THE NEXT ITEM EOS
@BOX14.0
COMPLETE ENTRY ON TLIST
DECLARE END OF DEFN TO MUTL
@BOX15.0
EXIT
@BOX16.0
FAULT
@BOX 18.0
IS THE NEXT ITEM EOL
@BOX 19.0
CALL ITEMISE
@BOX 20.0
IS THE NEXT ITEM "EOS"
@BOX 21.0
CREATE FORWARD REF TYPE
MUTLN AND DECLARE IT TO MUTL
@BOX 22.0
IS THE NEXT ITEM "="
@BOX 23.0
CREATE AN INCREMENTAL TYPE
@BOX 1.1
$PR DECL.TYPE(MODE);
@BOX 1.2
void DECLTYPE(int MODE)
{
@BOX 2.1
$IN N,TT,MTT,FIRST.T,ID;
ADDR D;
@BOX 2.2
int N,TT,MTT,FIRSTT,ID;
void *D;
@BOX 3.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 3.2
if (LBUFF[++IPTR].TAG != 1)
@BOX 4.1
$IF LBUFF[1+>IPTR]/=DIS
@BOX 4.2
if (memcmp(&LBUFF[++IPTR], &DIS, sizeof(ITYPE)) != 0)
@BOX 5.1
IND OF LBUFF[IPTR-1] => ID;
DECLARE.N(ID,KTYPE,0)=>N;
TL.TYPE(GENN(ID),MODE!IX);
@BOX 5.2
ID = LBUFF[IPTR-1].IND;
N = DECLAREN(ID,KTYPE,0);
TLTYPE(GENN(ID),MODE || IX);
@BOX 6.1
1+>LAST.T=>DETAIL OF PLIST[N]
=> FIRST.T;
@BOX 6.2
LASTT++;
PLIST[N].DETAIL = LASTT;
FIRSTT = LASTT;
@BOX 7.1
IF COMP.TYPE()=>TT=> MTT & %8000 /=0 $TH
TADPROC => TT FI
IF COMP.DIM()=>D /= 0 THEN
%4000 !> MTT
FI
@BOX 7.2
TT = COMPTYPE();
MTT = TT;
if ((MTT & 0x8000) !=0)
{
  TT = TADPROC;
}
D = COMPDIM();
if (D != 0)
{
  MTT |= 0x4000;
}
@BOX 8.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 8.2
if (LBUFF[++IPTR].TAG != 1)
@BOX 9.1
MTT=>TLIST[1+>LAST.T];
IND OF LBUFF[IPTR]=>TLIST[1+>LAST.T]=>ID;
TL.TYPE.COMP(TT,D,GENN(ID));
IF LAST.T >= TLISTZ THEN
SELECTOUTPUT(MSTR);NEWLINES(0);
CAPTION(%"TYPE LIST");MONITOR(9);FI
@BOX 9.2
TLIST[++LASTT] = MTT;
TLIST[++LASTT] = LBUFF[IPTR].IND;
ID = LBUFF[IPTR].IND;
TLTYPECOMP(TT,D,GENN(ID));
if (LASTT >= TLISTZ)
{
  SELECTOUTPUT(MSTR);
  NEWLINES(0);
  CAPTION("TYPE LIST");
  MONITOR(9);
}
@BOX 10.1
$IF LBUFF[1+>IPTR]=COMMA
@BOX 10.2
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX 11.1
$IF LBUFF[IPTR]/ = DOR
@BOX 11.2
if (memcmp(&LBUFF[IPTR], &DOR, sizeof(ITYPE)) != 0)
@BOX 12.1
LAST.T - FIRST.T ->> 1
 ! %8000 => T.LIST[FIRST.T];
1 +> LAST.T => FIRST.T;
TL.END.TYPE(1);
@BOX 12.2
TLIST[FIRSTT] = LASTT - (FIRSTT >> 1) | 0x8000;
LASTT++;
FIRSTT = LASTT;
TLENDTYPE(1);
@BOX 13.1
$IF LBUFF[1->IPTR+1] /= EOS
@BOX 13.2
IPTR--;
if (memcmp(&LBUFF[IPTR+1], &EOS, sizeof(ITYPE)) != 0)
@BOX 14.1
LAST.T - FIRST.T
->> 1 => TLIST[FIRST.T];
TL.END.TYPE(0);
@BOX 14.2
TLIST[FIRSTT] = LASTT - (FIRSTT >> 1);
TLENDTYPE(0);
@BOX 15.1
$EN
@BOX 15.2
;
// BOX 15.2
}
@BOX 16.1
MONITOR(0);
@BOX 16.2
MONITOR(0);
@BOX 18.1
$IF LBUFF[IPTR+1] = EOL
@BOX 18.2
if (memcmp(&LBUFF[IPTR+1], &EOL, sizeof(ITYPE)) == 0)
@BOX 19.1
ITEMISE(1);
1 +>IPTR;
@BOX 19.2
ITEMISE(1);
IPTR++;
@BOX 20.1
IF LBUFF[IPTR] = EOS
@BOX 20.2
if (memcmp(&LBUFF[IPTR], &EOS, sizeof(ITYPE)) == 0)
@BOX 21.1
DECLAREN (IND OF LBUFF[1->IPTR]=>ID,KTREF,0);
TL.TYPE(GENN(ID),IX!%2000);
@BOX 21.2
ID = LBUFF[--IPTR].IND;
DECLAREN (ID,KTREF,0);
TLTYPE(GENN(ID),IX | 0x2000);
@BOX 22.1
IF LBUFF[IPTR] = EQUALS
@BOX 22.2
if (memcmp(&LBUFF[IPTR], &EQUALS, sizeof(ITYPE)) == 0)
@BOX 23.1
DECLARE.N (IND OF LBUFF[IPTR-1] => ID, KTREF, 0);
TL.TYPE (GENN(ID),IX);
TL.TYPE.COMP (TLO8,EVAL.CONST(),NIL);
TL.END.TYPE(2);

@BOX 23.1
ID = LBUFF[IPTR-1].IND;
DECLAREN(ID, KTREF, 0);
TLTYPE (GENN(ID),IX);
TLTYPECOMP (TLO8,EVAL.CONST(),NIL);
TLENDTYPE(2);

@END
@TITLE MSL05.7(1,11)
@COL 1S-2R-3R-9T-10R-11T-12F
@COL 13R
@ROW 10-13
@FLOW 1-2-3-9Y-10-11N-12
@FLOW 9N-13
@FLOW 11Y-9
@BOX 1.0
DECL.VAR
@BOX 2.0
DECLARATIONS
@BOX 3.0
COMPUTE TYPE
AND DIMENSION
@BOX 9.0
IS THE NEXT ITEM A NAME
@BOX 10.0
CREATE MUTLN
AND DECLARE TO MUTL
@BOX 11.0
IS THE NEXT ITEM ','
@BOX 12.0
EXIT
@BOX 13.0
FAULT
@BOX 1.1
$PR DECL.VAR;
@BOX 1.2
void DECLVAR(void)
{
@BOX 2.1
$IN VART,VT,MUTLN,N;
ADDR VDIM;
@BOX 2.2
int VART,VT,MUTLN,N;
void *VDIM;
@BOX 3.1
1 -> IPTR;
IF COMP.TYPE()=>VART=>VT & %8000 /=0 $TH
TADPROC => VT FI
IF COMP.DIM() => VDIM /= 0 THEN
%4000 !> VART FI
@BOX 3.2
IPTR--;
VART = COMPTYPE();
VT = VART;
if ((VT & 0x8000) !=0)
{
  VT = TADPROC;
}
VDIM = COMPDIM();
if (VDIM != 0)
{
  VART |= 0x4000;
}
@BOX 9.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 9.2
if (LBUFF[++IPTR].TAG !=1)
@BOX 10.1
DECLARE.N(IND OF LBUFF[IPTR] => N,KVAR,VART)=>MUTLN;
TL.S.DECL(GENN(N),VT ! IX,VDIM);
VDIM => DETAIL OF PLIST[MUTLN];
@BOX 10.2
N = LBUFF[IPTR].IND;
MUTLN = DECLAREN(N,KVAR,VART);
TLSDECL(GENN(N),VT | IX,VDIM);
PLIST[MUTLN].DETAIL = (int32)VDIM;
@BOX 11.1
$IF LBUFF[1+>IPTR] = COMMA
@BOX 11.2
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX 12.1
1 -> IPTR;
$EN
@BOX 12.2
IPTR--;
}
@BOX 13.1
MONITOR(0);
@BOX 13.2
MONITOR(0);
@END
@TITLE MSL05.8(1,6)
@COL 1S-2R-3R-4R-5R-6T-14R-7R-8R-9R-10R-11T-12F
@COL 13R
@ROW 7-13
@FLOW 1-2-3-4-5-6Y-14-7-8-9-10-11N-12
@FLOW 11Y - 7
@FLOW 6N-13
@BOX 1.0
SELECT
@BOX 3.0
DECLARE MUTLN FOR
CONTEXT POINTER
@BOX 4.0
STORE A ^ PRECEDING CONTEXT
AND CALL TRANSLATE COMPUTATION
@BOX 5.0
PLANT D => CONTEXT POINTER
@BOX 6.0
IS CONTEXT AN AGGREGATE
@BOX 7.0
START FIELDS LOOP
DECLARE MUTLN FOR FIELD POINTER
@BOX 8.0
DECLARE FIELD
@BOX 9.0
@BOX 10.0
REPEAT LOOP
@BOX 11.0
ANY MORE ALTERNATIVES
@BOX 11.0
ANY MORE ALTERNATIVES
@BOX 12.0
END
@BOX 13.0
FAULT
@BOX 14.0
SELECT ALTERNATIVE 0
@BOX 1.1
$PR DECL.FIELD;
@BOX 1.2
void DECLFIELD(void)
{
@BOX 2.1
$IN CON.N,FIELD.N,PTR,I,ID,C.TYPE,ALT,SW;
@BOX 2.2
int CONN,PTR,I,CTYPE,ALT,SW;
@BOX 3.1
KDUMMY => K OF PLIST[1+>LASTMN=>CON.N];
TL.SELECT.VAR();
@BOX 3.2
CONN = ++LASTMN;
PLIST[CONN].K = KDUMMY;
TLSELECTVAR();
@BOX 4.1
REF => LBUFF[IPTR];
1 -> IPTR;
TRANS.COMP(0)=>C.TYPE;
@BOX 4.2
LBUFF[IPTR] = REF;
IPTR--;
CTYPE = TRANSCOMP(0);
@BOX 5.1
TL.PL(%60,CON.N);
@BOX 5.2
TLPL(0x60,CONN);
@BOX 6.1
$IF C.TYPE ->> 2 -64 => PTR < 0
@BOX 6.2
PTR = (CTYPE >> 2) - 64;
if (PTR < 0)
@BOX 7.1
TLIST[PTR]&%8000 => SW;
$FO I < T.LIST[PTR]&%FF $DO
DECLARE.N(TLIST[2+>PTR],KFIELD,TLIST[PTR-1]);
@BOX 7.2
SW = TLIST[PTR] & 0x8000;
for (I = 0; I < (TLIST[PTR] & 0xFF); I++)
{
  PTR += 2;
  DECLAREN(TLIST[PTR],KFIELD,TLIST[PTR-1]);
@BOX 8.1
TL.SELECT.FIELD(CONN,ALT,I);
@BOX 8.1
TLSELECTFIELD(CONN,ALT,I);
@BOX 9.1
@BOX 9.2
// BOX 9.2
@BOX 10.1
$OD
@BOX 10.2
}
@BOX11.1
1 +> ALT; 1 +> PTR;
$IF SW /= 0
@BOX11.2
ALT++;
PTR++;
if (SW != 0)
@BOX 12.1
$EN
@BOX 12.2
;
// BOX 12.2
}
@BOX 13.1
MONITOR(3);
@BOX 13.2
MONITOR(3);
@BOX 14.1
DETAIL OF PLIST[PTR] => PTR;
0 => ALT;
@BOX 14.2
PTR = PLIST[PTR].DETAIL;
ALT = 0;
@END
@TITLE MSL05.9(1,11)
@COL 1S-2R-3T-4T-5R-6T-7R-9F
@COL 10R
@ROW 7-10
@FLOW 1-2-3Y-4Y-5-6Y-7-9
@FLOW 3N-10
@FLOW 4N-10
@FLOW 6N-10
@BOX 1.0
DECL.SPACE
@BOX 2.0
DECLARATIONS
@BOX 3.0
IS THE NEXT ITEM A NAME?
@BOX 4.0
IS THE NEXT ITEM '['?
@BOX 5.0
EVALUATE CONSTANT
TO GIVE SIZE OF SPACE
@BOX 6.0
IS THE NEXT ITEM ']'?
@BOX 7.0
CREATE MUTLN
AND DECLARE TO MUTL
@BOX 9.0
EXIT
@BOX 10.0
FAULT
@BOX 1.1
$PR DECL.SPACE;
@BOX 1.2
void DECLSPACE(void)
{
@BOX 2.1
ADDR SZ;
@BOX 2.2
void *SZ;
@BOX 3.1
$IF TAG OF LBUFF[1+>IPTR]/=1
@BOX 3.2
if (LBUFF[++IPTR].TAG !=1)
@BOX 4.1
$IF LBUFF[1+>IPTR]/=LSB
@BOX 4.2
if (memcmp(&LBUFF[++IPTR], &LSB, sizeof(ITYPE)) != 0)
@BOX 5.1
EVAL.CONST()=>SZ;
@BOX 5.2
SZ = (void *)EVALCONST();
@BOX 6.1
$IF LBUFF[1+>IPTR]/=RSB
@BOX 6.2
if (memcmp(&LBUFF[++IPTR], &RSB, sizeof(ITYPE)) != 0)
@BOX 7.1
 DECLARE.N(IND OF LBUFF[IPTR-3],KSPACE,TBYADDR);
TL.SPACE(SZ);
@BOX 7.2
DECLAREN(LBUFF[IPTR-3].IND,KSPACE,TBYADDR);
TLSPACE(SZ);
@BOX 9.1
$EN
@BOX 9.2
;
// BOX 9.2
}
@BOX 10.1
MONITOR(0);
@BOX 10.2
MONITOR(0);
@END
@TITLE MSL05.10(1,6)
@COL 1S-2R-10T-11R-3T-4T-5R-6R-7T-15R-8F
@COL 12R-13T-14R-9R
@ROW 11-12
@ROW 5-9
@FLOW 1-2-10Y-11-3Y-4Y-5-6-7N-15-8
@FLOW 3N-13N-9
@FLOW 13Y-14-3
@FLOW 4N-9
@FLOW 7Y-3
@FLOW 10N-12-3
@BOX 1.0
DECL.LIT
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
NEXT ITEM
A NAME?
@BOX 4.0
NEXT ITEM
'='?
@BOX 5.0
CREATE MUTLN AND
MAKE ENTRY ON PLIST
@BOX 6.0
EVALUATE LITERAL
AND PASS IT TO MUTL
[MSL05.10.1]
@BOX 7.0
NEXT ITEM
','?
@BOX 8.0
EXIT
@BOX 9.0
FAULT
@BOX 10.0
IS THE NEXT ITEM '/'
@BOX 11.0
COMPUTE TYPE
@BOX 12.0
SET TYPE TO INTEGER
@BOX 13.0
IS THE NEXT ITEM EOL
@BOX 14.0
CALL ITEMISE
@BOX 15.0
SKIP EOL IF ANY
@BOX 1.1
$PR DECL.LIT;
$PS FIND($IN,$AD[$IN])/$IN;
$PR FIND(V,L);
$IN I;
$FO I < 6 DO
$IF V = L^[I] , ->OUT;
$OD
OUT:I=>FIND;
$EN
@BOX 1.2
int FIND(int V,int L[])
{
int I;
for(I = 0; I < 6; I++)
{
  if (V == L[I]) break;
}
return I;
}
void DECLLIT(void)
{
@BOX 2.1
$IN LIT.T,MN,ID;
@BOX 2.2
int LITT,MN,ID;
@BOX 3.1
$IF TAG  OF LBUFF[1+>IPTR]/=1
@BOX 3.2
if (LBUFF[++IPTR].TAG != 1)
@BOX 4.1
$IF LBUFF[1+>IPTR]/= EQUALS
@BOX 4.2
if (memcmp(&LBUFF[++IPTR], &EQUALS, sizeof(ITYPE)) != 0)
@BOX 5.1
DECLARE.N(IND OF LBUFF[IPTR-1]=>ID,KLIT,LIT.T) => MN;
@BOX 5.2
ID = LBUFF[IPTR-1].IND;
MN = DECLAREN(ID,KLIT,LITT);
@BOX 6.1
#MSL05.10.1
@BOX 6.2
#MSL05.10.1
@BOX 7.1
$IF LBUFF[1+>IPTR] = COMMA
@BOX 7.1
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX 8.1
1 -> IPTR;
$EN
@BOX 8.2
IPTR--;
}
@BOX 9.1
MONITOR(0);
@BOX 9.2
MONITOR(0);
@BOX 10.1
$IF LBUFF[1+>IPTR]/= SLASH
@BOX 10.2
if (memcmp(&LBUFF[++IPTR], &SLASH, sizeof(ITYPE)) != 0)
@BOX 11.1
COMP.TYPE()=>LIT.T;
@BOX 11.2
LITT = COMPTYPE();
@BOX 12.1
1 -> IPTR;
TINT => LIT.T;
@BOX 12.2
IPTR--;
LITT = TINT;
@BOX 13.1
$IF LBUFF[IPTR] /= EOL
@BOX 13.2
if (memcmp(&LBUFF[IPTR], &EOL, sizeof(ITYPE)) != 0)
@BOX 14.1
ITEMISE(1);
@BOX 14.2
ITEMISE(1);
@BOX 15.1
$IF LBUFF[IPTR] = EOL $TH 1+>IPTR $FI
@BOX 15.1
if (memcmp(&LBUFF[IPTR], &EOL, sizeof(ITYPE)) == 0)
{
  IPTR++;
}
@END
@TITLE MSL05.10.1(1,11)
@COL 23R
@COL 1S-2R-21T-22T-3R-8R-9R-10T-11R-12R-26R-13F
@COL 16T-17R-18T-24R
@ROW 3-16
@ROW 23-22
@FLOW 1-2-21N-22Y-3-8-9-10Y-11-8
@FLOW 10N-12-26-13
@FLOW 22N-16Y-17-13
@FLOW 21Y-23-26
@FLOW 16N-18N-24
@FLOW 18Y-26
@BOX 1.0
EVALUATE LITERAL
@BOX 22.0
IS THE TYPE COMPUTABLE
@BOX 3.0
SET RES = 0 AND FN = '+'
@BOX 8.0
EVALUATE LITERAL
[MSL05.20]
(AS INTEGER32)
NOTE ITS VALUE
@BOX 9.0
COMPUTE 'RES FN VAL'
@BOX 10.0
IS THE NEXT ITEM A LITOPR
@BOX 11.0
NOTE IT AS FN
@BOX 12.0
DECLARE COMPUTED RESULT
TO MUTL AND NOTE IT
ON PLIST
@BOX 13.0
END
@BOX 16.0
IS THE TYPE USER DEFINED
@BOX 17.0
EVALUATE AGG.LIT
[MSL05.10.2]
@BOX 18.0
EVALUATE LITERAL
[MSL05.20]
WAS IT A CONSTANT?
@BOX 21.0
IS THE TYPE AN ADDR
@BOX 23.0
DECLARE NIL PTR TOMUTL
@BOX 24.0
FAULT 0
@BOX 26.0
DECLARE LITERAL TO
MUTL (AS CUR.LIT)
@BOX 1.1
$BE
@BOX 1.2
{
// BOX 1.2
@BOX 2.1
$IN32 RES,VAL;
$IN FN;
$DA FNLIST($IN)
52 ::PLUS
53 ::MINUS
58 ::AMPAND
59 ::BANG
54 ::ASTERISK
55 ::SLASH
$EN
@BOX 2.2
int32 RES,VAL;
int FN;
int FNLIST[] =
{
52, //PLUS
53, //MINUS
58, //AMPAND
59, //BANG
54, //ASTERISK
55 //SLASH
};
@BOX 3.1
0 => RES;0 => FN;
@BOX 3.2
RES = 0;
FN = 0;
@BOX 8.1
EVAL.LIT(0,TINT32) => VAL;
@BOX 8.2
VAL = EVALLIT(0,TINT32);
@BOX 9.1
$AL FN $FR
VAL +> RES;
VAL -> RES;
VAL &> RES;
VAL !> RES;
VAL *> RES;
VAL /> RES;
$EN
@BOX 9.2
switch (FN)
{
  case 0:
  {
    RES += VAL;
    break;
  }
  case 1:
  {
    RES -= VAL;
    break;
  }
  case 2:
  {
    RES &= VAL;
    break;
  }
  case 3:
  {
    RES |= VAL;
    break;
  }
  case 4:
  {
    RES *= VAL;
    break;
  }
  case 5:
  {
    RES /= VAL;
    break;
  }
}
@BOX 10.1
$IF FIND(IND OF LBUFF[IPTR+1],^FNLIST) => FN = 6
@BOX 10.2
FN = FIND(LBUFF[IPTR+1].IND,FNLIST);
if (FN == 6)
@BOX 11.1
1 +> IPTR;
::FN SET ABOVE
@BOX 11.2
IPTR++;
//FN SET ABOVE
@BOX 12.1
RES => DETAIL OF PLIST[MN];
TL.C.LIT.32(LIT.T,RES);
@BOX 12.2
PLIST[MN].DETAIL = RES;
TLCLIT32(LITT,RES);
@BOX 13.1
$EN
@BOX 13.2
;
// BOX 13.2
}
@BOX 16.1
$IF LIT.T < 256
@BOX 16.2
if (LITT < 256)
@BOX 17.1
#MSL05.10.2
@BOX 17.2
#MSL05.10.2
@BOX 18.1
IF EVAL.LIT(1,LIT.T) = 0
@BOX 18.2
if (EVALLIT(1,LITT) == 0)
@BOX 22.1
IF LIT.T & %FF00 /= 0
OR CHECK.LIT(LIT.T,TINT32) /= 0
@BOX 22.2
if ((LITT & 0xFF00) != 0 || CHECKLIT(LITT,TINT32) != 0)
@BOX21.1
$IF LIT.T & %8003 /= 0
@BOX21.2
if ((LITT & 0x8003) != 0)
@BOX23.1
TL.C.NULL(LIT.T);
@BOX23.2
TLCNULL(LITT);
@BOX24.1
MONITOR(0);
@BOX24.2
MONITOR(0);
@BOX 26.1
TL.LIT(GENN(ID),IX);
@BOX 26.2
TLLIT(GENN(ID),IX);
@END
@TITLE MSL05.10.2(1,6)
@COL 1S-2R-3R-4R-15R-8T-9T-10R
@COL 14F
@ROW 9-14
@FLOW 1-2-3-4-15-8Y-9N-10
@FLOW 9Y-4
@FLOW 8N-14
@BOX 1.0
EVALUATE AGG.LIT
@BOX 2.0
FIND ITS TLIST ENTRY
@BOX 3.0
DECLARE AGG.LIT TO MUTL
@BOX 4.0
EVALUATE LITERAL
[MSL05.20]
IN TYPE OF NEXT FIELD
OF AGGREGATE AND
NOTE NAME IN N
@BOX 8.0
ANY MORE FIELDS
@BOX 9.0
IS THE NEXT ITEM '\'
@BOX 10.0
FAULT
@BOX 14.0
END
@BOX15.0
DECLARE N TO
MUTL AS AN AGGFIELD
@BOX 1.1
$BE
@BOX 1.2
{
@BOX 2.1
$IN PTR,N,FCOUNT;
LIT.T - 256 ->> 2 => PTR;
DETAIL OF PLIST[PTR]=>PTR;
TLIST[PTR] => FCOUNT;
1 -> PTR;
@BOX 2.2
int PTR,N,FCOUNT;
PTR = (LITT - 256) >> 2;
PTR = PLIST[PTR].DETAIL;
FCOUNT = TLIST[PTR];
PTR = 1;
@BOX 3.1
TL.S.DECL(GENN(ID),IX+LIT.T,-4096);
TL.ASS(MN,-1);
@BOX 3.2
TLSDECL(GENN(ID),IX+LITT,(void *)-4096);
TLASS(MN,-1);
@BOX 4.1
EVAL.LIT(1,TLIST[2+>PTR]) => N;
@BOX 4.2
PTR += 2;
N = EVALLIT(1,TLIST[PTR]);
@BOX15.1
TL.ASS.VALUE(N,1);
@BOX15.2
TLASSVALUE(N,1);
@BOX 8.1
$IF 1 -> FCOUNT = 0
@BOX 8.2
FCOUNT--;
if (FCOUNT == 0)
@BOX 9.1
$IF LBUFF[1+>IPTR] = BSLASH
@BOX 9.2
IPTR++;
if (memcmp(&LBUFF[IPTR], &BSLASH, sizeof(ITYPE)) == 0)
@BOX 10.1
MONITOR(0);
@BOX 10.2
MONITOR(0);
@BOX 14.1
TL.ASS.END()
$EN
@BOX 14.2
TLASSEND();
}
@END
@TITLE MSL05.11(1,6)
@COL 1S-2R-7T-8R-3R-4R-5R-6F
@FLOW 1-2-7Y-8-3-4-5-6
@FLOW 7N-3
@BOX 1.0
DECL.LAB(NAME)
@BOX 2.0
DECLARATIONS
ASSUME KIND LABEL
@BOX 3.0
DECLARE NAME
AS KIND "KIND"
@BOX 4.0
DECLARE NAME
TO MUTL AS
LABEL
@BOX 5.0
ADVANCE IPTR
@BOX 6.0
EXIT
@BOX 7.0
1S IT A GLOBAL LABEL
@BOX 8.0
SET KIND = GLAB
@BOX 1.1
$PR DECL.LAB;
@BOX 1.2
void DECLLAB(void)
{
@BOX 2.1
$IN MNAME,KIND;
KLAB => KIND;
@BOX 2.2
int MNAME,KIND;
KIND = KLAB;
@BOX 3.1
DECLARE.N(IND OF LBUFF[1+>IPTR],KIND,0)=>MNAME;
@BOX 3.2
MNAME = DECLAREN(LBUFF[++IPTR].IND,KIND,0);
@BOX 4.1
TL.LABEL(MNAME);
@BOX 4.2
TLLABEL(MNAME);
@BOX 5.1
1+>IPTR;
@BOX 5.2
IPTR++;
@BOX 6.1
$EN
@BOX 6.2
;
// BOX 6.2
}
@BOX 7.1
$IF LBUFF[IPTR+2] = COLON
@BOX 7.2
if (memcmp(&LBUFF[IPTR+2], &COLON, sizeof(ITYPE)) == 0)
@BOX 8.1
KGLAB => KIND;
@BOX 8.2
KIND = KGLAB;
@END
@TITLE MSL05.12(1,11)
@COL 1S-2R-3T-4T-5R-6T-8R-9R-14T-10R-11F
@COL 13R
@ROW 10-13
@FLOW 1-2-3Y-4Y-5-6Y-8-9-14OK-10-11
@FLOW 14NOT THERE-13
@FLOW 3N-13
@FLOW 4N-13
@FLOW 6N-13
@BOX 1.0
DECL.DVEC
@BOX 2.0
DECLARATIONS &
MAKE CON.STACK ENTRY
@BOX 3.0
IS THE NEXT ITEM A NAME?
@BOX 4.0
IS THE NEXT ITEM '('?
@BOX 5.0
COMPUTE TYPE
@BOX 6.0
IS THE NEXT ITEM ')'?
@BOX 14.0
IS THE TYPE AN ADDR PROC
OR A BASIC NUMERIC TYPE
@BOX 8.0
CREATE MUTLN
MAKE PLIST ENTRY
AND DECLARE NAME TO MUTL
@BOX 9.0
RECOGNISE &
PLANT DATA
VECTOR ELEMENTS
[MUDL5.12.1]
@BOX 10.0
SKIP EOL IF ANY
DECLARE END OF DV
TO MUTL
DELETE CON.STACK
ENTRY
@BOX 11.0
EXIT
@BOX 13.0
FAULT
@BOX 15.0
FAULT
@BOX 14.0
CHECK FOR END
@BOX 1.1
$PR DECL.DVEC;
@BOX 1.2
void DECLDVEC(void)
{
@BOX 2.1
$IN DVT,N,ID,MN,NPTR;
0 => CONSTK[1+>CONPTR];
@BOX 2.2
int DVT,N,ID,MN,NPTR;
CONSTK[++CONPTR] = 0;
@BOX 3.1
$IF TAG OF LBUFF[1+>IPTR=>NPTR]/=1
@BOX 3.2
NPTR = ++IPTR;
if (LBUFF[NPTR].TAG != 1)
@BOX 4.1
$IF LBUFF[1+>IPTR]/=LB
@BOX 4.2
if (memcmp(&LBUFF[++IPTR], &LB, sizeof(ITYPE)) != 0)
@BOX 5.1
COMP.TYPE()=>DVT
@BOX 5.2
DVT = COMPTYPE();
@BOX 6.1
$IF LBUFF[1+>IPTR] /= RB
@BOX 6.2
if (memcmp(&LBUFF[++IPTR], &RB, sizeof(ITYPE)) != 0)
@BOX 8.1
DECLARE.N(IND OF LBUFF[NPTR]=>ID,KDVEC,DVT ! %4000) => MN;
$IF DVT&%8000 /= 0$TH
TADPROC => DVT
ELSE IF DVT = TLAB THEN
%2C => DVT $FI$FI
TL.S.DECL(GENN(ID), DVT!IX, -1);
TL.ASS(MN,(IF PROCLEV = 0 THEN -2 ELSE -1 ));
@BOX 8.2
ID = LBUFF[NPTR].IND;
MN = DECLAREN(ID,KDVEC,DVT | 0x4000);
if ((DVT & 0x8000) != 0)
{
  DVT = TADPROC;
}
else if (DVT == TLAB)
{
  DVT = 0x2C;
}
TLSDECL(GENN(ID), DVT | IX, (void *)-1);
TLASS(MN,(PROCLEV == 0)? -2 : -1);
@BOX 9.1
#MSL05.12.1
@BOX 9.2
#MSL05.12.1
@BOX 10.1
$IF LBUFF[1+>IPTR] /= EOL $TH 1->IPTR $FI
TL.ASS.END();
1 -> CON.PTR;
@BOX 10.2
if (memcmp(&LBUFF[++IPTR], &EOL, sizeof(ITYPE)) != 0)
{
  IPTR--;
}
TLASSEND();
CONPTR--;
@BOX 11.1
$EN
@BOX 11.2
;
// BOX 11.2
}
@BOX 13.1
MONITOR(0);
@BOX 13.2
MONITOR(0);
@BOX 14.1
::BOX TO BE REMOVED
@BOX 14.2
//BOX TO BE REMOVED
@BOX15.1
@BOX15.2
@BOX 14.1
ITEMISE(0);
$IF LBUFF[1=>IPTR] /= DEND
@BOX 14.2
ITEMISE(0);
IPTR = 1;
if (memcmp(&LBUFF[IPTR], &DEND, sizeof(ITYPE)) != 0)
@END
@TITLE MSL05.12.1(1,11)
@COL 1S-2R-15R-3T-13T-5R-6R-9R-16T
@COL 11F-14R
@ROW 5-11
@FLOW 1-2-15R-3N-13N-5-6-9-16Y-15
@FLOW 13Y-14-16
@FLOW 3Y-11
@FLOW 16N-3
@BOX 1.0
RECOGNISE &
PLANT DATA
VECTOR ELEMENTS
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 15.0
ITEMISE NEXT
SECTION OF INPUT
@BOX 3.0
IS THE NEXT ITEM EOS
@BOX 5.0
PROCESS DVEC
ELEMENT
[MSL05.12.2]
@BOX 6.0
COMPUTE DIMENSION
@BOX 9.0
PASS NAME OR VALUE
TO MUTL
@BOX 11.0
END
@BOX13.0
IS THE NEXT ITEM A STRING
AND TYPE = $L08
@BOX14.0
PASS STRING
TO MUTL
@BOX 16.0
IS NEXT ITEM EOL
@BOX 1.1
$BE
@BOX 1.2
{
@BOX 2.1
$IN CH.PTR,CH,C;
ADDR D;
$AD[$LO8]ADLIT;
@BOX 2.2
int CHPTR,C;
void *D;
//char *ADLIT;
@BOX15.1
$IF DVT = TLO8 $TH
ITEMISE(2);
$EL
ITEMISE(1)
$FI
@BOX15.2
if (DVT == TLO8)
{
  ITEMISE(2);
}
else
{
  ITEMISE(1);
}
@BOX3.1
$IF LBUFF[1+>IPTR] = EOS
@BOX3.2
if (memcmp(&LBUFF[++IPTR], &EOS, sizeof(ITYPE)) == 0)
@BOX5.1
#MSL05.12.2
@BOX5.2
#MSL05.12.2
@BOX6.1
$IF COMP.DIM() => D = 0 $TH 1=>D $FI
@BOX6.2
D = COMPDIM();
if (D == 0)
{
  D = (void *)1;
}
@BOX9.1
TL.ASS.VALUE(N,D);
@BOX9.2
TLASSVALUE(N,(int)D);
@BOX11.1
$EN
@BOX11.2
;
// BOX 11.2
}
@BOX13.1
$IF TAG $OF LBUFF[IPTR] = 2 $AN DVT = TLO8
@BOX13.2
if (LBUFF[IPTR].TAG == 2 && DVT == TLO8)
@BOX14.1
IND OF LBUFF[IPTR] => CH.PTR;
0 => C;
$WH CLIST[CH.PTR + C] /= 0 $DO 1 +> C $OD
TL.C.LIT.S(TLO8,PART(^CLIST,CH.PTR,CH.PTR + C -1));
TL.ASS.VALUE(0,1);
@BOX14.2
CHPTR = LBUFF[IPTR].IND;
C = 0;
while (CLIST[CHPTR + C] != 0)
{
  C++;
}
TLCLITS(TLO8,PART(CLIST,CHPTR,CHPTR + C - 1));
TLASSVALUE(0,1);
@BOX 16.1
$IF LBUFF[1+IPTR] /= EOL
@BOX 16.2
if (memcmp(&LBUFF[++IPTR], &EOL, sizeof(ITYPE)) != 0)
@END
@TITLE MSL05.12.2(1,11)
@COL 9T-10T-11R-12T-13R
@COL 1S-8T-2T-3R-4F
@COL 5T-6T-7R
@ROW 9-2
@ROW 3-5
@FLOW 1-8N-2N-3-4
@FLOW 8Y-9Y-10N-11-4
@FLOW 2Y-5N-6Y-7-4
@FLOW 9N-13
@FLOW 10Y-12N-13
@FLOW 12Y-4
@FLOW 5Y-7
@FLOW 6N-3
@BOX1.0
PROCESS DVEC ELEMENT
@BOX8.0
IS DATAVEC OF
TYPE LABEL ?
@BOX2.0
IS NEXT ITEM A NAME
AND MUTL NAME SET?
@BOX3.0
EVALUATE LITERAL
[MSL05.20]
IN TYPE OF DATAVEC
AND NOTE MUTL NAME
@BOX4.0
END
@BOX9.0
IS THE NEXT
ITEM A NAME ?
@BOX10.0
IS THE NAME LOCALLY
DEFINED ?
@BOX11.0
DECLARE IT AS A LABEL
AND NOTE MUTL NAME
@BOX12.0
NOTE MUTL NAME
IS IT A LABEL ?
@BOX13.0
FAULT
@BOX5.0
IS IT A PROC NAME AND
DATAVEC TYPE IS ADDR OR ADDR PROC?
@BOX6.0
IS IT A DATAVEC NAME
AND TYPE CORRECT?
@BOX7.0
NOTE MUTL NAME
@BOX1.1
BEGIN
@BOX1.2
{
@BOX8.1
IF DVT = %2C
@BOX8.2
if (DVT == 0x2C)
@BOX2.1
IF TAG OF LBUFF[IPTR] = 1
AND MUTLN(IND OF LBUFF[IPTR]) => N > 1
@BOX2.2
N = MUTLN(LBUFF[IPTR].IND);
if (LBUFF[IPTR].TAG == 1 &&  N > 1)
@BOX3.1
1 -> IPTR;
EVAL.LIT(1,DVT) => N;
@BOX3.2
IPTR--;
N = EVALLIT(1,DVT);
@BOX4.1
END
@BOX4.2
;
// BOX 4.2
}
@BOX9.1
IF TAG OF LBUFF[IPTR] /= 1
@BOX9.2
if (LBUFF[IPTR].TAG != 1)
@BOX10.1
IND OF LBUFF[IPTR] => ID;
IF MUTLN(ID) => N >= CURBLK
@BOX10.2
ID = LBUFF[IPTR].IND;
N = MUTLN(ID);
if (N >= CURBLK)
@BOX11.1
DECLARE.N(ID,KLAB.REF,0) => N;
@BOX11.2
N = DECLAREN(ID,KLABREF,0);
@BOX12.1
IF K OF PLIST[N] >= KLAB
@BOX12.2
if (PLIST[N].K >= KLAB)
@BOX13.1
MONITOR(0);
@BOX13.2
MONITOR(0);
@BOX5.1
IF [DVT = TADPROC OR DVT = TBYADDR]
AND K OF PLIST[N] =< KPROC
@BOX5.2
if ((DVT == TADPROC || DVT == TBYADDR) && (PLIST[N].K <= KPROC))
@BOX6.1
IF K OF PLIST[N] /= KDVEC
OR T OF PLIST[N] & %3FFF ! 3 /= DVT
@BOX6.2
if (PLIST[N].K != KDVEC || ((PLIST[N].T & 0x3FFF | 3) != DVT))
@BOX7.1
::ALREADY IN N
@BOX7.2
//ALREADY IN N
@END
@TITLE MSL05.14(1,7)
@COL 1S-2R-3R-4T-5R-6T-7F
@COL 8R
@ROW 5-8
@FLOW 1-2-3-4Y-5-6N-7
@FLOW 4N-8
@FLOW 6Y-4
@BOX1.0
DECLARE IMPORT
@BOX3.0
NOTE IMPORT KIND
@BOX4.0
IS THE NEXT ITEM A NAME?
@BOX5.0
DECLARE IMPORT TO MUTL
@BOX6.0
IS THE NEXT ITEM A COMMA
@BOX7.0
END
@BOX8.0
FAULT
@BOX1.1
$PR DECL.IMP;
@BOX1.2
void DECLIMP(void)
{
@BOX2.1
$IN IMP.KIND,ID,NAME,I,TV;
@BOX2.2
int IMPKIND,ID,NAME,I,TV;
@BOX3.1
$IF LBUFF[1+>IPTR] = DTY
$TH 0 => IMP.KIND
$EL $IF LBUFF[IPTR] = DLA
$TH 3 => IMP.KIND
$EL $IF LBUFF[IPTR] = DVSTORE
$TH 1 => IMP.KIND $EL 2 => IMP.KIND FI
IF TAG OF LBUFF[IPTR+1] = TDELIM AND
DLIST[IND OF LBUFF[IPTR+1]] & %200 /= 0 THEN
1 +> IPTR;
ST OF LBUFF[IPTR] => TV;
ELSE IF LBUFF[IPTR+1] = DADDR THEN
       1 +> IPTR;
       TBYADDR => TV;
     ELSE
       TVST => TV FI FI
 $FI $FI
@BOX3.2
if (memcmp(&LBUFF[++IPTR], &DTY, sizeof(ITYPE)) == 0)
{
  IMPKIND = 0;
}
else if (memcmp(&LBUFF[IPTR], &DLA, sizeof(ITYPE)) == 0)
{
  IMPKIND = 3;
}
else if (memcmp(&LBUFF[IPTR], &DVSTORE, sizeof(ITYPE)) == 0)
{
  IMPKIND = 1;
}
else
{
  IMPKIND = 2;
}
if (LBUFF[IPTR+1].TAG == TDELIM && (DLIST[LBUFF[IPTR+1].IND] & 0x200) != 0)
{
  IPTR++;
  TV = LBUFF[IPTR].ST;
}
else if (memcmp(&LBUFF[IPTR+1], &DADDR, sizeof(ITYPE)) == 0)
{
  IPTR++;
  TV = TBYADDR;
}
else
{
  TV = TVST;
}
// FI FI??
@BOX4.1
$IF TAG OF LBUFF[1 +> IPTR] /= 1
@BOX4.2
if (LBUFF[++IPTR].TAG != 1)
@BOX5.1
IND OF LBUFF[IPTR] => ID;
$AL IMP.KIND $FR
BEGIN
 DECLARE.N(ID,KTREF,0);
TL.TYPE(GENN(ID),%9000);
END
BEGIN
 DECLARE.N(ID,KVAR,TV) => NAME;
$IF LBUFF[IPTR+1] = LSB
$AN LBUFF [IPTR+2] = RSB $TH
2 +> IPTR;
%4000 !> T OF PLIST[NAME];
-1 => I;
ELSE
0 => I;
$FI
TL.VDECL(GENN(ID),0,0,0,TV!%8000,I);
END
BEGIN
 DECLARE.N(ID,KLIT,TV) => NAME;
0-NAME => DETAIL OF PLIST[NAME];
TL.LIT(GENN(ID),TV!%8000);
END
 DECLARE.N(ID,KIMP.LAB,0);
END
@BOX5.2
ID = LBUFF[IPTR].IND;
switch (IMPKIND)
{
  case 0:
    {
    DECLAREN(ID,KTREF,0);
    TLTYPE(GENN(ID),0x9000);
	break;
    }
  case 1:
    {
    NAME = DECLAREN(ID,KVAR,TV);
    if (memcmp(&LBUFF[IPTR+1], &LSB, sizeof(ITYPE)) == 0 && memcmp(&LBUFF[IPTR+2], &RSB, sizeof(ITYPE)) == 0)
    {
	  IPTR += 2;
	  PLIST[NAME].T |= 0x4000;
	  I = -1;
    }
	else
	{
	  I = 0;
	}
    TLVDECL(GENN(ID),0,0,0,TV | 0x8000,(void *)I);
	break;
    }
  case 2:
    {
    NAME = DECLAREN(ID,KLIT,TV);
    PLIST[NAME].DETAIL = 0-NAME;
    TLLIT(GENN(ID),TV | 0x8000);
	break;
    }
  case 3:
    {
    DECLAREN(ID,KIMPLAB,0);
	break;
	}
}
@BOX6.1
$IF LBUFF[1 +> IPTR] = COMMA
@BOX6.2
if (memcmp(&LBUFF[++IPTR], &COMMA, sizeof(ITYPE)) == 0)
@BOX7.1
1 -> IPTR;
$EN
@BOX7.2
IPTR--;
}
@BOX8.1
MONITOR(0);
@BOX8.2
MONITOR(0);
@END
@TITLE MSL05.15(1,7)
@COL 15R-10R
@COL 1S-14T-2R-3T-4T-5T-6R-7R-8R-9F
@COL 11R-12R-13R
@ROW 4-11
@ROW 15-3
@ROW 10-6
@FLOW 1-14N-2-3N-4N-5Y-6-7-8-9
@FLOW 14Y-15-10
@FLOW 5N-10-9
@FLOW 3Y-11-12-13-9
@FLOW 4Y-12
@BOX 1.0
END.ST
@BOX 2.0
PERFORM END CHECKS
@BOX 3.0
IS CONTEXT ALT
@BOX 4.0
IS CONTEXT BEGIN
@BOX 5.0
IS CONTEXT PROC
@BOX 6.0
TL PLANT
ASSIGN RESULT
AND RETURN
@BOX 7.0
REMOVE CONSTK
ENTRY AND RESET
CURLEV, CURBLK,
CURRES, CURPROC,
GLEV
@BOX 8.0
PRINT END MESSAGE
DECLARE PROC END TO MUTL
@BOX 9.0
EXIT
@BOX 10.0
FAULT
@BOX 11.0
END ALTERNATIVE
CONSTRUCT
@BOX 12.0
REMOVE CONSTACK
ENTRY RESET
CURBLK
@BOX 13.0
DECLARE END TO
MUTL
@BOX 14.0
IS CONTEXT DATAVEC
@BOX 15.0
REMOVE ENTRY ON CONSTACK
@BOX 1.1
$PR ENDST;
$IN I;
@BOX 1.2
void ENDST(void)
{
int I;
@BOX 2.1
END.CHECKS();
@BOX 2.2
ENDCHECKS();
@BOX 3.1
$IF CON.STK[CON.PTR] >= 9
@BOX 3.2
if (CONSTK[CONPTR] >= 9)
@BOX 4.1
$IF CON.STK[CON.PTR] = 5
@BOX 4.2
if (CONSTK[CONPTR] == 5)
@BOX 5.1
$IF CONSTK[CONPTR] /= 4
@BOX 5.2
if (CONSTK[CONPTR] != 4)
@BOX 6.1
IF T OF PLIST[CURPROC] => I /=  0 THEN
IF I & %8000 /= 0 THEN
TADPROC => I;
FI
TL.PL(%46,I);
TL.PL(%22,CURRES);
AOPD=>I;
FI
TL.PL(%43,I);
@BOX 6.2
I = PLIST[CURPROC].T;
if (I != 0)
{
  if ((I & 0x8000) != 0)
  {
    I = TADPROC;
  }
  TLPL(0x46,I);
  TLPL(0x22,CURRES);
  I = AOPD;
}
TLPL(0x43,I);
@BOX 7.1
1 -> PROCLEV;
CONSTK[1->CONPTR] => LASTCH;
CONSTK[1->CONPTR]=> LASTN;
CONSTK[1->CONPTR] => GLEV;
CONSTK[1->CONPTR] => CURBLK;
CONSTK[1->CONPTR] => CURPROC;
CONSTK[1->CONPTR] => CURRES;
CONSTK[1->CONPTR] => CURLEV;
TL.DATA.AREA(CONSTK[1->CONPTR]=>CUR.GLB);
1 -> CONPTR;
@BOX 7.2
PROCLEV = 1;
LASTCH = CONSTK[--CONPTR];
LASTN = CONSTK[--CONPTR];
GLEV = CONSTK[--CONPTR];
CURBLK = CONSTK[--CONPTR];
CURPROC = CONSTK[--CONPTR];
CURRES = CONSTK[--CONPTR];
CURLEV = CONSTK[--CONPTR];
CURGLB = CONSTK[--CONPTR];
TLDATAAREA(CURGLB);
CONPTR--;
@BOX 8.1
MONITOR(201);
TL.END.PROC();
@BOX 8.2
MONITOR(201);
TLENDPROC();
@BOX 9.1
$EN
@BOX 9.2
;
// BOX 9.2
}
@BOX 10.1
MONITOR(10);
@BOX 10.2
MONITOR(10);
@BOX 11.1
TRANS.END.ALT();
@BOX 11.2
TRANSENDALT();
@BOX 12.1
CONSTK[1->CONPTR] => LASTCH;
CONSTK[1->CONPTR] => LASTN;
CONSTK[1->CONPTR] => CURBLK;
1 -> CONPTR;
@BOX 12.2
LASTCH = CONSTK[--CONPTR];
LASTN = CONSTK[--CONPTR];
CURBLK = CONSTK[--CONPTR];
CONPTR--;
@BOX 13.1
TL.END.BLOCK();
@BOX 13.2
TLENDBLOCK();
@BOX 14.1
$IF CONSTK[CONPTR] = 0
@BOX 14.2
if (CONSTK[CONPTR] == 0)
@BOX 15.1
1 -> CONPTR;
@BOX 15.2
CONPTR--;
@END
@TITLE MSL05.16(1,11)
@COL 17R
@COL 1S-2R-3T-5R-16T-6R-7T-8T-9R-10T-11T-12R-13R-14F
@COL 15R
@ROW 17-6
@ROW 12-15
@FLOW 1-2-3Y-5-16N-6-7Y-8Y-9-10Y-11Y-12-13-14
@FLOW 16Y-17-7
@FLOW 3N-15
@FLOW 7N-10
@FLOW 8N-15
@FLOW 10N-13
@FLOW 11N-15
@BOX1.0
DECLARE VSTORE
@BOX3.0
IS THE NEXT ITEM A NAME?
@BOX5.0
EVALUATE SUBSCRIPT
@BOX6.0
EVALUATE CONSTANT
AND NOTE IT AS VADDR
@BOX7.0
IS THE NEXT ITEM A '<'?
@BOX8.0
IS THE NEXT ITEM A NAME?
@BOX9.0
DECLARE AS SUBROUTINE
AND NOTE AS PRE-PROC
@BOX10.0
IS THE NEXT ITEM A '>'?
@BOX11.0
IS THE NEXT ITEM A NAME?
@BOX12.0
DECLARE AS SUBROUTINE
AND NOTE AS POST PROC
@BOX13.0
CREATE MUTLN
MAKE PLIST ENTRY
AND DECLARE IT TO MUTL
@BOX14.0
END
@BOX15.0
FAULT
@BOX 16.0
IS THE NEXT ITEM A NAME
@BOX 17.0
NOTE IT AS VNAME
::CHECKS MISSING
@BOX1.1
$PR DECL.VSTORE;
@BOX1.2
void DECLVSTORE(void)
{
@BOX2.1
$IN VNAME,PREP,POSTP,NAME,VT;
ADDR DIM;
0 => PREP => POSTP => VT;
@BOX2.2
int VNAME,PREP,POSTP,NAME,VT;
void *DIM;
PREP = 0;
POSTP = 0;
VT = 0;
@BOX3.1
$IF TAG OF LBUFF[1+>IPTR] /= 1
@BOX3.2
if (LBUFF[++IPTR].TAG != 1)
@BOX5.1
IND OF LBUFF[IPTR] => NAME;
IF COMP.DIM() => DIM /= 0 $TH
%4000 => VT FI
@BOX5.2
NAME = LBUFF[IPTR].IND;
DIM = COMPDIM();
if (DIM != 0)
{
  VT = 0x4000;
}
@BOX6.1
EVAL.LIT(1,TBYADDR) => VNAME;
TVST !> VT;
@BOX6.2
VNAME = EVALLIT(1,TBYADDR);
VT |= TVST;
@BOX7.1
$IF LBUFF[1 + IPTR] /= LTHAN
@BOX7.2
if (memcmp(&LBUFF[1 + IPTR], &LTHAN, sizeof(ITYPE)) != 0)
@BOX8.1
$IF TAG OF LBUFF[2+>IPTR] /= 1
@BOX8.2
IPTR += 2;
if (LBUFF[IPTR].TAG != 1)
@BOX9.1
DECLARE.N(IND OF LBUFF[IPTR],KPSPEC,0) => PREP;
0=>DETAIL OF PLIST[PREP];
TL.PROC.SPEC(NIL,%4002);
TL.PROC.RESULT(0);
@BOX9.2
PREP = DECLAREN(LBUFF[IPTR].IND,KPSPEC,0);
PLIST[PREP].DETAIL = 0;
TLPROCSPEC(NIL,0x4002);
TLPROCRESULT(0);
@BOX10.1
$IF LBUFF[1+IPTR] /= GTHAN
@BOX10.2
if (memcmp(&LBUFF[1 + IPTR], &GTHAN, sizeof(ITYPE)) != 0)
@BOX11.1
$IF TAG OF LBUFF[2+>IPTR] /= 1
@BOX11.2
IPTR += 2;
if (LBUFF[IPTR].TAG != 1)
@BOX12.1
DECLARE.N(IND OF LBUFF[IPTR],KPSPEC,0) => POSTP;
TL.PROC.SPEC(NIL,%4002);
0 => DETAIL OF PLIST[POSTP];
TL.PROC.RESULT(0);
@BOX12.2
POSTP = DECLAREN(LBUFF[IPTR].IND,KPSPEC,0);
TLPROCSPEC(NIL,0x4002);
PLIST[POSTP].DETAIL = 0;
TLPROCRESULT(0);
@BOX13.1
DECLARE.N(NAME,KVAR,VT);
TL.V.DECL(GENN(NAME),VNAME,PREP,POSTP,VT!IX,DIM);
@BOX13.2
DECLAREN(NAME,KVAR,VT);
TLVDECL(GENN(NAME),VNAME,PREP,POSTP,VT | IX,DIM);
@BOX14.1
$EN
@BOX14.2
;
// BOX 14.2
}
@BOX15.1
MONITOR(0);
@BOX15.2
MONITOR(0);
@BOX 16.1
$IF TAG OF LBUFF[IPTR+1] = 1
@BOX 16.2
if (LBUFF[IPTR+1].TAG == 1)
@BOX 17.1
MUTLN(IND OF LBUFF[1+>IPTR]) => VNAME;
T OF PLIST[VNAME] !> VT;
@BOX 17.2
VNAME = MUTLN(LBUFF[++IPTR].IND);
VT |= PLIST[VNAME].T;
@END
@TITLE MSL05.17(1,7)
@COL 13R-14T-15R-21T-22R-16R
@COL 1S-2R-3T-4T-23T-5T-6T-18T-19T-20R-7R-8T-9T-12F
@COL 17R-24R
@ROW 13-4
@ROW 15-6-17
@ROW 16-12
@ROW 21-20
@FLOW 1-2-3OTHER-4N-23N-5Y-6Y-18N-19Y-20-12
@FLOW 3ADDR-13-14Y-15-4
@FLOW 4Y-17-8Y-9Y-12
@FLOW 5N-21Y($AD,$AD[L ect)-22-12
@FLOW 6N-21N-16
@FLOW 18Y-7-8
@FLOW 19N-21
@FLOW 8N-12
@FLOW 9N-16
@FLOW 14N-4
@FLOW 23Y-24-8
@BOX1.0
COMPUTE TYPE
@BOX2.0
CLEAR TYPE/DIM IN RESULT
@BOX3.0
TEST NEXT ITEM
@BOX4.0
IS NEXT ITEM A BASIC TYPE
@BOX5.0
IS NEXT ITEM A NAME
@BOX6.0
IS THERE A MUTL NAME
FOR THIS MUSL NAME?
@BOX18.0
IS IT A TYPE NAME
@BOX19.0
IS IT A PROC
AND ADDR SET?
@BOX20.0
SET PROC TYPE IN RESULT
@BOX7.0
SET USER TYPE IN RESULT
@BOX9.0
IS NEXT ITEM ']'
@BOX8.0
IS RESULT BOUNDED POINTER
@BOX12.0
END
@BOX13.0
SET POINTER IN RESULT
@BOX14.0
IS NEXT ITEM '['
@BOX15.0
SET BOUNDED POINTER
IN RESULT
@BOX16.0
FAULT
@BOX17.0
SET BASIC TYPE IN RESULT
@BOX 21.0
IS ADDR SET
@BOX 22.0
SET TYPE TO
"BYTE ADDRESS"
@BOX 23.0
IS NEXT ITEM ADDR
@BOX 24.0
SET TYPE "BYTE ADDR"
IN RESULT
@BOX 1.1
$PR COMP.TYPE;
@BOX 1.2
int COMPTYPE(void)
{
int result;
@BOX 2.1
$IN VTYPE,N,KK; 0 => VTYPE;
@BOX 2.2
int VTYPE,N,KK;
VTYPE = 0;
@BOX 3.1
$IF LBUFF[1+>IPTR]=DADDR
@BOX 3.2
if (memcmp(&LBUFF[++IPTR], &DADDR, sizeof(ITYPE)) == 0)
@BOX 4.1
$IF TAG OF LBUFF[IPTR]=0
$AN DLIST[IND OF LBUFF[IPTR]] & %200 /= 0
@BOX 4.2
if (LBUFF[IPTR].TAG == 0 && (DLIST[LBUFF[IPTR].IND] & 0x200) != 0)
@BOX 5.1
$IF TAG OF LBUFF[IPTR]/=1
@BOX 5.2
if (LBUFF[IPTR].TAG != 1)
@BOX 6.1
$IF MUTLN(IND OF LBUFF[IPTR]) => N =< 1
@BOX 18.1
$IF K OF PLIST[N] => KK = KTYPE OR KK = KTREF
@BOX 18.2
KK = PLIST[N].K;
if (KK == KTYPE || KK == KTREF)
@BOX19.1
IF KK /= KPSPEC AND KK /= KPROC
OR VTYPE /= 1
@BOX19.2
if ((KK != KPSPEC && KK != KPROC) || VTYPE != 1)
@BOX20.1
%8000 ! N => VTYPE;
@BOX20.2
VTYPE = 0x8000 | N;
@BOX 7.1
N+64<<- 2!>VTYPE;
@BOX 7.2
VTYPE |= (N+64) << 2;
@BOX 9.1
$IF LBUFF[1+>IPTR]/=RSB
@BOX 9.2
if (memcmp(&LBUFF[++IPTR], &RSB, sizeof(ITYPE)) != 0)
@BOX 8.1
$IF VTYPE & 3 /= 3
@BOX 8.2
if ((VTYPE & 3) != 3)
@BOX 12.1
VTYPE => COMP.TYPE;
$EN
@BOX 12.2
result = VTYPE;
return result;
}
@BOX 13.1
1 => VTYPE;
@BOX 13.2
VTYPE = 1;
@BOX 14.1
$IF LBUFF[1+>IPTR] /= LSB
@BOX 14.2
if (memcmp(&LBUFF[++IPTR], &LSB, sizeof(ITYPE)) != 0)
@BOX 15.1
3 => VTYPE;
1+> IPTR;
@BOX 15.2
VTYPE = 3;
IPTR++;
@BOX 16.1
MONITOR(0);
@BOX 16.2
MONITOR(0);
@BOX 17.1
ST OF LBUFF[IPTR] !> VTYPE;
@BOX 17.2
VTYPE |= LBUFF[IPTR].ST;
@BOX 21.1
IF VTYPE&1 /= 1
@BOX 21.2
if ((VTYPE & 1) != 1)
@BOX22.1
VTYPE ->> 1 + 1 -> IPTR;
TBYADDR => VTYPE;
@BOX22.2
IPTR = (VTYPE >> 1) + 1;
VTYPE = TBYADDR;
@BOX 23.1
IF LBUFF[IPTR] = DADDR
@BOX 23.2
if (memcmp(&LBUFF[IPTR], &DADDR, sizeof(ITYPE)) != 0)
@BOX 24.1
TBYADDR !> VTYPE;
@BOX 24.2
VTYPE |= TBYADDR;
@END
@TITLE MSL05.18(1,11)
@COL 9R
@COL 1S-2R-3T-4R-5T-6R-7F
@COL 8R
@ROW 9-6-8
@FLOW 1-2-3Y-4-5Y-6-7
@FLOW 3N-8-7
@FLOW 5N-9
@BOX 1.0
COMPILE DIMENSION
@BOX 3.0
IS THE NEXT ITEM '['
@BOX 4.0
EVALUATE CONST
@BOX 5.0
IS THE NEXT ITEM ']'
@BOX 6.0
RETURN CONST AS RESULT
@BOX 7.0
EXIT
@BOX 8.0
RETURN ZERO AS RESULT
@BOX 9.0
FAULT
@BOX 1.1
$PR COMP.DIM;
@BOX 1.2
void *COMPDIM(void)
{
void *result;
@BOX 2.1
ADDR CONST;
@BOX 2.2
void *CONST;
@BOX 3.1
$IF LBUFF[1+>IPTR]/=LSB
@BOX 3.2
if (memcmp(&LBUFF[++IPTR], &LSB, sizeof(ITYPE)) != 0)
@BOX 4.1
EVAL.CONST()=>CONST;
@BOX 4.2
CONST = (void *)EVALCONST();
@BOX 5.1
$IF LBUFF[1+>IPTR]/=RSB
@BOX 5.1
if (memcmp(&LBUFF[++IPTR], &RSB, sizeof(ITYPE)) != 0)
@BOX 6.1
CONST => COMP.DIM;
@BOX 6.2
result = CONST;
@BOX 7.1
$EN
@BOX 7.2
;
// BOX 7.2
return result;
}
@BOX 8.1
1 -> IPTR;
0 => COMP.DIM;
@BOX 8.2
IPTR--;
result = 0;
@BOX 9.1
MONITOR(0);
@BOX 9.2
MONITOR(0);
@END
@TITLE MSL05.19(1,6)
@COL 1S-2R-3F
@FLOW 1-2-3
@BOX1.0
CHECK.LIT(LIT.TYPE,REQD.TYPE)
@BOX2.0
SET RESULT TO 0 IF LIT TYPE OK
SET RESULT TO 1 OTHERWISE
@BOX3.0
EXIT
@BOX1.1
$PR CHECK.LIT(LT,REQDT);
@BOX1.2
int CHECKLIT(int LT, int REQDT)
{
int result;
@BOX2.1
IF LT & %3F =< REQDT & %3F
AND [LT & %C0 = REQDT & %C0
OR LT & %C1 = TLO0 AND REQDT & %C0 = TINT0
OR LT = TLO0 AND REQDT = TLO1]
THEN 0 => CHECK.LIT
ELSE IF  LT & %FFC3 = TRE0 AND REQDT & %FFC3 = TRE0
THEN 0 => CHECK.LIT
ELSE 1 => CHECK.LIT FI FI
@BOX2.2
if ((LT & 0x3F) <= (REQDT & 0x3F) && ((LT & 0xC0) == (REQDT & 0xC0) || ((LT & 0xC1) == TLO0) && (REQDT & 0xC0) == TINT0) || ((LT == TLO0) && (REQDT == TLO1)))
{
  result = 0;
}
else if ((LT & 0xFFC3) == TRE0 && (REQDT & 0xFFC3) == TRE0)
{
  result = 0;
}
else
{
  result = 1;
}
@BOX3.1
END
@BOX3.2
;
// BOX 3.2
return result;
}
@END
@TITLE MSL05.20(1,7)
@COL 10R
@COL 1S-2R-3T-4T-5T-6R-7R-8R-9F
@COL 11T-12T-19T-13R-16R-14R-15N
@COL 17T-18R
@ROW 10-6
@ROW 4-11
@ROW 13-17
@FLOW 1-2-3Y-4Y-5Y-6-7-8-9
@FLOW 3N-11Y-12N-19Y-13
@FLOW 4N-19N-16-9
@FLOW 5N-10-9
@FLOW 11N-19
@FLOW 12Y-17N-18-15-9
@FLOW 17Y-14-15
@BOX1.0
EVAL.LIT(MODE,LIT.TYPE)
@BOX2.0
DECLARATIONS &
INITIALISATION
@BOX3.0
NEXT ITEM
A CONSTANT?
@BOX4.0
IS IT OF
CORRECT TYPE?
@BOX5.0
VALUE REQUIRED?
@BOX6.0
SET VALUE TO 0
(OR -1 IF SIGNED)
@BOX7.0
COMPUTE VALUE FROM
BYTES ON CLIST
@BOX8.0
SET RESULT AS VALUE
@BOX9.0
EXIT
@BOX10.0
DECLARE CONST
TO MUTL AS
CURRENT LITERAL
SET RESULT TO 0
@BOX11.0
IS IT THE NAME
OF A LITERAL?
@BOX12.0
IS IT OF
CORRECT TYPE?
@BOX19.0
SET RESULT -VE
IS ERROR DETECTION
REQUIRED?
@BOX13.0
FAULT 3
@BOX16.0
ADJUST POINTER IN
ITEMISED LINE
@BOX14.0
SET RESULT FROM
VALUE IN PLIST
FOR LITERAL
@BOX17.0
VALUE REQUIRED?
@BOX18.0
SET RESULT TO
MUTLN OF LITERAL
@BOX1.1
$PR EVAL.LIT(MODE,LIT.TYPE);
@BOX1.2
int32 EVALLIT(int MODE, int LITTYPE)
{
int32 result;
@BOX2.1
$IN I,ST,N;
@BOX2.2
int I,ST,N;
@BOX3.1
IF TAG OF LBUFF[1+>IPTR] => I /= TCONST
@BOX3.2
I = LBUFF[++IPTR].TAG;
if (I != TCONST)
@BOX4.1
ST OF LBUFF[IPTR] => ST ->>2 & %F => N;
IND OF LBUFF[IPTR] => I;
IF CHECK.LIT(ST,LIT.TYPE) /= 0
@BOX4.2
ST = LBUFF[IPTR].ST;
N = (ST >> 2) & 0xF;
I = LBUFF[IPTR].IND;
if (CHECKLIT(ST,LITTYPE) != 0)
@BOX5.1
IF MODE /= 0
@BOX5.2
if (MODE != 0)
@BOX6.1
IF ST & %C0 = %40 THEN
-1 => EVAL.LIT ELSE
0 => EVAL.LIT FI
@BOX6.2
if ((ST & 0xC0) == 0x40)
{
  result = -1;
}
else
{
  result = 0;
}
@BOX7.1
1 -> I;
FOR N + 1 DO
EVAL.LIT <<- 8 + CLIST[1+>I] => EVAL.LIT OD
@BOX7.2
I--;
for (int i = 0; i < N + 1; i++)
{
  result = (result << 8) + CLIST[++I];
}
@BOX8.1
::DONE IN BOX 7
@BOX8.2
//DONE IN BOX 7
@BOX9.1
END
@BOX9.2
;
// BOX 9.2
return result;
}
@BOX10.1
TL.C.LIT.S(ST,PART(^CLIST,I,I+N));
0 => EVAL.LIT;
@BOX10.2
TLCLITS(ST,PART(CLIST,I,I+N));
result = 0;
@BOX11.1
IF I /= TNAME
OR MUTLN(IND OF LBUFF[IPTR]) => I =< 1
OR K OF PLIST[I] /= KLIT
@BOX11.2
if (I != TNAME || (I = MUTLN(LBUFF[IPTR].IND)) <= 1 || PLIST[I].K != KLIT)
@BOX12.1
IF CHECK.LIT(T OF PLIST[I],LIT.TYPE) = 0
@BOX12.2
if (CHECKLIT(PLIST[I].T, LITTYPE) == 0)
@BOX19.1
-1 => EVAL.LIT;
IF MODE = 2
@BOX19.2
result = -1;
if (MODE==2)
@BOX13.1
MONITOR(3);
@BOX13.2
MONITOR(3);
@BOX16.1
1 -> IPTR;
@BOX16.2
IPTR--;
@BOX14.1
DETAIL OF PLIST[I] => EVAL.LIT;
@BOX14.2
result = PLIST[I].DETAIL;
@BOX17.1
IF MODE = 0
@BOX17.2
if (MODE == 0)
@BOX18.1
I => EVAL.LIT;
@BOX18.2
result = I;
@END
@TITLE MSL05.21(1,7)
@COL 1S-2T-3R-4T-5R-6T-7T-8R-9R
@COL 10F
@ROW 7-10
@FLOW 1-2Y-3-4Y-5-2
@FLOW 2N-4-2
@FLOW 4N-6Y-7Y-8-9-6
@FLOW 6N-10
@FLOW 7N-9
@BOX 1.0
END.CHECKS
@BOX 2.0
IS CONTEXT FOR/WHILE
@BOX 3.0
FAULT
GENERATE DUMMY OD
@BOX 4.0
IS CONTEXT THEN/ELSE
@BOX 5.0
FAULT
GENERATE DUMMY FI
@BOX 6.0
IS LAST ASSIGNED MUTLN LOCAL
@BOX 7.0
IS IT UNDEF LAB OR PROC
@BOX 8.0
FAULT
@BOX 9.0
RELEASE MUTLN
@BOX 10.0
EXIT
@BOX 1.1
$PR END.CHECKS;
$IN I;
0 => I;
IF LASTMN > MAXMUTLN THEN
LASTMN => MAXMUTLN FI
IF LASTN > MAXN THEN
LASTN => MAXN FI
IF LASTCH > MAXCH THEN
LASTCH => MAXCH FI
@BOX 1.2
void ENDCHECKS(void)
{
int I;
I = 0;
if (LASTMN > MAXMUTLN)
{
  MAXMUTLN = LASTMN;
}
if (LASTN > MAXN)
{
  MAXN = LASTN;
}
if (LASTCH > MAXCH)
{
  MAXCH = LASTCH;
}
@BOX 2.1
$IF CONSTK[CONPTR] /= 3 /= 9
@BOX 2.2
if (CONSTK[CONPTR] != 3 && CONSTK[CONPTR] != 9)
@BOX 3.1
MONITOR(143);
TRANS.OD();
@BOX 3.2
MONITOR(143);
TRANSOD();
@BOX 4.1
$IF CONSTK[CONPTR] /= 1
@BOX 4.2
if (CONSTK[CONPTR] != 1)
@BOX 5.1
MONITOR(141);
TRANS.FI();
@BOX 5.2
MONITOR(141);
TRANSFI();
@BOX 6.1
$IF LASTMN < CURBLK
@BOX 6.2
if (LASTMN < CURBLK)
@BOX 7.1
$IF K OF PLIST[LASTMN] /= KPSPEC
$AN K OF PLIST[LASTMN] /= KLABREF
@BOX 7.2
if (PLIST[LASTMN].K != KPSPEC && PLIST[LASTMN].K != KLABREF)
@BOX 8.1
IF I = 0 THEN
MONITOR(129);
1 => I;
FI
SELECTOUTPUT(MSTR);
NEWLINES(1);
CAPTION(GENN(INTID OF PLIST[LASTMN]));
@BOX 8.2
if (I == 0)
{
  MONITOR(129);
  I = 1;
}
SELECTOUTPUT(MSTR);
NEWLINES(1);
CAPTION(GENN(PLIST[LASTMN].INTID));
@BOX 9.1
$IF K OF PLIST[LASTMN] /= KDUMMY $TH
PREVN OF PLIST[LASTMN] => MUTLN
OF NLIST[INTID OF PLIST[LASTMN]] $FI
1 -> LASTMN;
@BOX 9.2
if (PLIST[LASTMN].K != KDUMMY)
{
  NLIST[PLIST[LASTMN].INTID].MUTLN = PLIST[LASTMN].PREVN;
}
LASTMN--;
@BOX 10.1
$EN
@BOX 10.2
;
// BOX 10.2
}
@END
@TITLE MSL05.22(1,11)
@COL 1S-2R-3F
@FLOW 1-2-3
@BOX1.0
EVAL.CONST
@BOX2.0
EVALUATE LITERAL
AS INTEGER CONSTANT
AND RETURN VALUE
AS RESULT
@BOX3.0
EXIT
@BOX1.1
$PR EVAL.CONST;
@BOX1.2
int32 EVALCONST(void)
{
@BOX2.1
EVAL.LIT(0,TINT32) => EVAL.CONST;
@BOX2.2
return EVALLIT(0,TINT32);
@BOX3.1
END
@BOX3.2
;
// BOX 3.2
}
@END


