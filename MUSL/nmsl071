@X @~
~V7 56 2 -5
~D10
~H                    MUSS
~
~
~D10
~H            NMSL071
~D10
~MMANCHESTER UNIVERSITY  -  CONFIDENTIAL~
~
~
~V2 -16
                                                                      ISSUE 11~
~V2 0
~V9 -1
~P
~V9 1
~YMSL071
~S1~M~LMSL IMPLEMENTATION DESCRIPTION
~S1~M~LSection 7   Version 1
~S1~LSection 7.1 Computation Processing
~S1~L1. General Description
~BThis section is concerned with the processing of
COMPUTATIONs, CONDITIONs and their component parts.
Firstly COMPUTATIONs and CONDITIONs are analysed
completely and an analysis record is produced in the
vector AR. This analysis record is then used to
produce MUTL/MUBL code.~
~S1~L2. Interfaces
~
Procedural interface~
~
1) PREPROCESS.COMP($IN)$IN~
2) PREPROCESS.COND()~
3) COMPILE.COMP($IN,$IN)~
4) COMPILE.COND(IF.OR.UN,DEST.LAB,NEXT.LAB)~
5) COMPILE.AND(IF.OR.UN,DEST.LAB,NEXT.LAB)~
6) COMPILE.TEST(IF.OR.UN,DEST.LAB,NEXT.LAB)~
~
Data structure interface~
~
1) AR~
2) AP~
3) REGS.IU~
4) A.TYPE~
5) D.TYPE~
~S1~L2.1 Software Interface
~
~
1) PREPROCESS.COMP($IN)$IN~
~BThis procedure produces an analysis record in AR of a
COMPUTATION in LBUFF. The form of the
analysis record is described later. It returns as a result
the final TYPE of the computation.
The parameter defines the required final type of the
computation (e.g. for parameters) or 0 if none.~
~
~
2) PREPROCESS.COND()~
~BCONDITIONs in MUSL consist of an arbitrary number of TESTs
separated by ANDs and ORs, as described in Chapter 6. This
procedure produces an analysis record in AR of CONDITIONs
which enables its composition in terms of AND and OR clauses
to be immediately apparent, the form of the contained TESTs
is also resolved. Again the structure of the analysis record is
described later.~
~S1~L3. Implementation
~S1~L3.2 Data Structures
~T# 8
~
~
AR~IThis is the main data structure of this section. It is used for
the encoded analysis record of both CONDITION's and COMPUTATION's.
Its declared structure is simple, it is a vector of 16-bit
integers, but the way it is encoded will require some description.
The analysis record for COMPUTATIONs consists of an
initial fixed part and a variable part
dependant on the composition of the computation in
terms of its operators and operands. The initial part
contains 3 words thus:~
~
#1) Kind of COMPUTATION. This is coded with:~
~
#%100 = 1 if expression is part of a~
~V1 17
~V2 27
comparison, a parameter
expression or contains a
procedure call i.e. cases
where if the expression is a
single operand and of address
type it should be evaluated in
A not D~
~V1 0
~V2 0
# %80 = 1 if single operand~
# %40 = 1 if computation destroys D~
# %20 = 1 if computation destroys A~
# %10 = 1 if computation destroys B~
~
#2) Initial TYPE for evaluation of COMPUTATION~
~
#3) Analysis record for first operand.~
~
~
~IThe variable part describes a COMPUTATION as an
operator operand sequence. If there is any departure
from this sequence it is indicated by an operator word
whose most significant bit is 1. The main reason for a
departure from strict operator operand sequencing is
when a type change is required. In this case the rest of
the word whose most significant bit is set contains the
MUTL type descriptor for the new type. This 'unary
type conversion operator' is followed by a normal
operator. The sequence is terminated by
the delimiter terminating the COMPUTATION.~
~
~
~IThe compiler determines the type used for evaluation of expression
by looking ahead up to and including the next 'assigned to' operand
(or the end of an expression). The partial expression
under consideration is then evaluated in the largest type
contained therein. This implies that
a conversion may need to be applied before any assignment
if the type of the expression
does not correspond to the type of the operand
to be assigned to.~
~
~
~IIf an assigned is followed by further
operations the process is repeated and a new type for
the next partial expression is computed. Thus in effect
the accumulator may need to be converted after
an assignment. Parameter expressions are in
effect considered to be followed by an assignment
to a variable of the type of the formal
parameter. This forces the evaluation of the parameter
expression to be in the correct type as dictated
by the MUSL Manual.~
~
~
~IOperators in the analysis record of a computation are
represented by the IND field of the operator entry in
LBUFF. Operand analysis records occupy several words
and have a structure which depends upon the kind of
operand. The first word distinguishes 10 kinds of
operands by the following settings of its least
significant 4 bits.~
~T# 15
~
#0 Named item~
#1 Literal~
#2 Literal (negated literal required)~
#3 Procedure Call~
#4 Library Procedure Call~
#5 (Subexpression)~
#6 (Conditional Computation)~
#7 Built in Function.~
#8 String~
#9 Procedure call by variable~
~T# 8
~
~IThe encoding of the remaining bits in the operand kind word
and
the remainder of the analysis record
of operand is as follows:-~
~T# 15
~
#KIND O) Named item.~
#In this further encoded case Operand Kind is~
#Bit %80 = 1 if reference to variable required~
#Bit %40 = 1 if operand uses D~
#Bit %20 = 1 if operand uses A~
#Bit %10 = 1 if operand uses B~
~T# 8
~
~
~IThis is followed by a word giving a MUTL name
of the item
name which may be followed by further words indicating dereferencing,
selection and subscripting. Otherwise it will be followed
by the next operator (or the computation terminator). Special
operators are therefore introduced to distinguish these forms of
operand access as follows.~
~V1 8
~V2 25
~
Union selection operator
Coded as %CO plus number of
alternative required.~
~
Field selection operator
Coded as %80 plus number of field
required.~
~
Dereference operator coded as %7F.~
~
Subscript operator coded as %7E
followed by a word giving
the type of the D register
immediately before the subscript
followed by the analysis record
for subscript expression.~
~V1 0
~V2 0
~
~
~I   The special operands e.g. VSUB are also coded up in this
way, the appropriate MUTL name being planted out in the analysis
record e.g. %1002.~
~V1 8
~V2 25
~
KINDS 1) 2) Literals~
In this case Operand Kind is further
encoded with the next 8 bits
giving type and size of literal as
defined in section 3 and a further
word gives the IND of the literal.~
~
KIND 3) Procedure Call~
This is followed by:~
~
MUTL name of procedure~
~
Result type of procedure~
~
Number of parameters~
~
Anaysis record for each~
parameter computation which
may be absent or repeated.~
~
KIND 4) Library procedure call~
This is followed by:~
~
MUTL name of LSPEC generated for procedure~
~
Result type of procedure~
~
Number of parameters~
~
Analysis record for each
parameter computation which
may be absent or repeated.~
~
KIND 5) (Subexpression)~
~
This is followed by an analysis record
for the subexpression computation
(terminated by ')').~
~
KIND 6) (Conditional Computation)~
~
This is followed by an analysis record
for a CONDITION followed by an
analysis record of the first
COMPUTATION followed by the
analysis record of the second
COMPUTATION. Each of the above
is terminated by a zero.~
~
KIND 7) Built in Function~
~
This is followed by a word giving
the Built in function number. Coded
with least significant 4 bits.~
 0 - BYTE~
 1 - MAKE~
 2 - POSN~
 3 - PART~
 4 - SIZE~
 5 - LLST~
 6 - LPST~
 7 - LENT~
& %80 set if a scalar
MAKE is required
%40 set if a byte address
type MAKE is required
and analysis record for each
parameter repeated as necessary.~
~
KIND 8) String~
~
This is followed by a word given the
MUTL name of the data vector of
characters planted for the string.~
~
KIND 9) Procedure call by variable~
~
Coded as for KIND 3) except that the
first item gives the MUTL name of the
procedure variable.~
~V2 0
~
~
The analysis record for CONDITIONs has the following components:-~
~V2 25
~
Number of 'OR's in CONDITION~
i.e. Number of AND clauses -1~
~
Analysis record for first
AND clause.~
~
'OR' followed by the analysis
record for subsequent AND
clauses repeated as necesary.~
~V2 0
~
~
The analysis record for an AND clause
starts with the number of AND's that it contains followed
by an analysis record for each TEST separated by 'AND''s.~
~
~
The analysis record for a TEST can take one or two forms,
distinguished by the first word.~
~V2 25
~
= 0 - indicating~
TEST is [<CONDITION>]
followed by an analysis record for
CONDITION. Note that this will
contain ']' as the CONDITION
terminator.~
~
/= 0 indicating~
COMPUTATION/COMPARISION
form of TEST. Here the first word
gives number of right hand
sides for comparison. This is
followed by a word giving the
TYPE to be used to evaluate
comparisons, which is followed
by the analysis record for left
hand side COMPUTATION. A sequence
of comparator/analysis record
for right hand side of comparison
follow this.~
~V1 0
~V2 0
~Y
~P
~V9 -1
~D15
~HFLOWCHARTS
~
~
~H              NMSL071
~V9 -1
~F
@TITLE MSL07(1,10)
@COL 1S-2R-3R-4R-5F
@FLOW 1-2-3-4-5
@B1.0
COMPUTATION
PROCESSING
SECTION
@B2.0
.
@B3.0
.
@B4.0
PROCEDURES IN SECTION
PREPROCESS.COMP MSL07.1
PREPROCESS.COND MSL07.2
COMPILE.COMP MSL07.3
COMPILE.COND MSL07.4
COMPILE.AND  MSL07.5
COMPILE.TEST MSL07.6
STACK.REGS MSL07.7
UNSTACK.REGS MSL07.8
REG.FROM.TYPE MSL07.9
CHECK.TYPE MSL07.10
PRINT.AR MSL07.11
@B5.0
END
@B1.1
::COMPUTATION PROCESSING SECTION;
#MSL07/1
MODULE(PREPROCESS.COMP,PREPROCESS.COND,COMPILE.COMP,COMPILE.COND,COMPILE.AND,
      COMPILE.TEST,PRINT.AR,AR,AP,REGS.IU,REG.TYPE,FPTR,STPTR,AOPD,DIND,B.REQD);
@B1.2
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include "nmsl021.h"
//COMPUTATION PROCESSING SECTION;
#MSL07/1
@B2.1
::TYPE DECLARATIONS
@B2.2
//TYPE DECLARATIONS
@B3.1
*GLOBAL 5;
$LI REF.BIT = %80,VEC =16,DREG=4,AREG=2,BREG=1,A.B.D=7,B.D=5;
$LI/ITYPE DAND= 0\0\%2B, DOR= 0\0\%2C;
$LI B.REQD = -1,AOPD=%3000,BOPD=%2000,STK.SEL=%1005,UNSTK=%1003,DIND=%1004,CLIT=
0;
::PDP *CODE 2
*GLOBAL 1;
$DA REV.OP($LO8)
51 52 56 54 57 53 55 58 59 60
$EN
$DA TL.FN($LO8)
2 8 9 11 12 10 13 4 5 3 0 24 26
27 29 25 28 20 21 19 15 7 6
$EN
$DA TL.TST.FN($LO8)
11 13 14 12 10  9
$EN
$DA REV.COMP($LO8)
 9 10 13 14 11 12
$EN
$DA INV.TST($LO8)
10  9 12 11 14 13
$EN
*GLOBAL 5;
$LO16 [256] AR;$IN AP;
$IN REGS.IU,ATYPE,BTYPE,DTYPE,LAST.REG;
$LO8 [16] FIELDS;$IN FPTR;
$LO16 [16] STACK.TYPE;$IN ST.PTR;
@B3.2
//*GLOBAL 5;
const int REFBIT = 0x80;
const int VEC =16;
const int DREG=4;
const int AREG=2;
const int BREG=1;
const int ABD=7;
const int BD=5;
//$LI/ITYPE DAND= 0\0\%2B, DOR= 0\0\%2C;
//$LI B.REQD = -1,AOPD=%3000,BOPD=%2000,STK.SEL=%1005,UNSTK=%1003,DIND=%1004,CLIT=0;
//PDP *CODE 2
//*GLOBAL 1;
uint8 REVOP[] = {51, 52, 56, 54, 57, 53, 55, 58, 59, 60};
uint8 TLFN[] = {2, 8, 9, 11, 12, 10, 13, 4, 5, 3, 0, 24, 26, 27, 29, 25, 28, 20, 21, 19, 15, 7, 6 };
uint8 TLTSTFN[] = {11, 13, 14, 12, 10,  9 };
uint8 REVCOMP[] = {9, 10, 13, 14, 11, 12 };
uint8 INVTST[] = {10,  9, 12, 11, 14, 13 };
//*GLOBAL 5;
uint16 AR[256];
int AP;
int REGSIU,ATYPE,BTYPE,DTYPE,LASTREG;
uint8 FIELDS[16];
int FPTR;
uint16 STACKTYPE[16];
int STPTR;
@B4.1
$PS PREPROCESS.COMP($IN)/$IN;
$PS PREPROCESS.COND();
$PS COMPILE.COMP($IN,$IN)/$IN;
$PS COMPILE.COND($IN,$IN,$IN);
$PS COMPILE.AND($IN,$IN,$IN);
$PS COMPILE.TEST($IN,$IN,$IN);
$PS STACK.REGS($IN);
$PS UNSTACK.REGS($IN);
$PS REG.FROM.TYPE($IN,$IN)/$IN;
$PS CHECK.TYPE($IN,$IN,$IN)/$IN;
$PS PRINT.AR();
::PDP *CODE 3;
#MSL07.1
::PDP *CODE 1;
#MSL07.2
#MSL07.3
#MSL07.4
#MSL07.5
#MSL07.6
#MSL07.7
#MSL07.8
#MSL07.9
#MSL07.10
#MSL07.11
@B4.2
int PREPROCESSCOMP(int);
void PREPROCESSCOND();
int COMPILECOMP(int,int);
void COMPILECOND(int,int,int);
void COMPILEAND(int,int,int);
void COMPILETEST(int,int,int);
void STACKREGS(int);
void UNSTACKREGS(int);
int REGFROMTYPE(int,int);
int CHECKTYPE(int,int,int);
void PRINTAR();
//PDP *CODE 3;
#MSL07.1
//PDP *CODE 1;
#MSL07.2
#MSL07.3
#MSL07.4
#MSL07.5
#MSL07.6
#MSL07.7
#MSL07.8
#MSL07.9
#MSL07.10
#MSL07.11
@B5.1
$PS INIT.S7();
PROC INIT.S7;
END
*END
@B5.2
void INITS7(void);
void INITS7(void)
{}
//*END
@END
@TITLE MSL07/1(1,11)
@COL 1S
@BOX1.0
EXTERNAL ENVIRONMENT
@B1.1
::EXTERNAL ENVIRONMENT
$LS SELECT.OUTPUT($IN);
$LS NEWLINES($IN);
$LS OUTHEX($LO32,$IN);
$LS SPACES($IN);
$LS CAPTION(ADDR[$LO8]);
$LS TL.ASS($IN,$IN);
$LS TL.ASS.VALUE($IN,$IN);
$LS TL.C.LIT.16($IN,$IN16);
$LS TL.C.LIT.S($IN,ADDR[$LO8]);
$LS TL.ASS.END();
$LS TL.PL($IN,$IN);
$LS TL.REG($IN);
$LS TL.MAKE($IN,$IN,ADDR);
$LS TL.D.TYPE($IN,ADDR);
$LS TL.LABEL.SPEC(ADDR[$LO8],$IN);
$LS TL.LABEL($IN);
$LS TL.SELECT.VAR();
$LS TL.SELECT.FIELD($IN,$IN,$IN);
$LS TL.S.DECL(ADDR[$LO8],$IN,ADDR);
$IM $LI ILOAD,LBUFFZ,SDLIST,PLISTZ,PARAMSZ;
$TY ITYPE IS $LO8 TAG,ST $LO16 IND;
ITYPE[LBUFFZ] LBUFF;
$IN MSTR,MUTLSTR,IPTR,CURLEV,GLEV,TINT,TRE,TBYADDR,CURPROC,CURRES;
$LO16[SDLIST] DLIST;
$TY PLIST.ENT IS $LO16 INTID,PREVN,K,T $IN32 DETAIL;
PLIST.ENT[PLISTZ] PLIST;
$IN [PARAMSZ] PARAMS;
$IM $LI TADPROC,KVAR,TLO0,TRE0,CLISTZ,TINT0,TINT64;
$LO8 [CLISTZ] CLIST;
$IM $LI KSPACE,ICOMP,TNAME,TCONST,KPROC,KFIELD,TLISTZ;
$IN [TLISTZ] TLIST;
$IM $LI TSTRING,STRING.TYPE,TDELIM,TLAB,TLO32,IBYTE,KPSPEC,TLO8;
$LI/ADDR[$LO8] NIL =;
$IN CMODE;
$PS MONITOR($IN);
$PS DUMMY()/$LO16;
$PS MUTLN($LO16)/$LO16;
$PS ADD.LSPEC($LO16)/$LO16;
$PS COMP.TYPE()/$IN;
$IM $LI IMIN.COMP,ISTORE,IEOS;
ITYPE MINUS,DIF,DTHEN,DELSE,LB,RB,COMMA,LSB,DOF,RSB,EOS,DEREF,REF;
@B1.2
////EXTERNAL ENVIRONMENT
//$LS SELECT.OUTPUT($IN);
//$LS NEWLINES($IN);
//$LS OUTHEX($LO32,$IN);
//$LS SPACES($IN);
//$LS CAPTION(ADDR[$LO8]);
//$LS TL.ASS($IN,$IN);
//$LS TL.ASS.VALUE($IN,$IN);
//$LS TL.C.LIT.16($IN,$IN16);
//$LS TL.C.LIT.S($IN,ADDR[$LO8]);
//$LS TL.ASS.END();
//$LS TL.PL($IN,$IN);
//$LS TL.REG($IN);
//$LS TL.MAKE($IN,$IN,ADDR);
//$LS TL.D.TYPE($IN,ADDR);
//$LS TL.LABEL.SPEC(ADDR[$LO8],$IN);
//$LS TL.LABEL($IN);
//$LS TL.SELECT.VAR();
//$LS TL.SELECT.FIELD($IN,$IN,$IN);
//$LS TL.S.DECL(ADDR[$LO8],$IN,ADDR);
//$IM $LI ILOAD,LBUFFZ,SDLIST,PLISTZ,PARAMSZ;
//$TY ITYPE IS $LO8 TAG,ST $LO16 IND;
//ITYPE[LBUFFZ] LBUFF;
//$IN MSTR,MUTLSTR,IPTR,CURLEV,GLEV,TINT,TRE,TBYADDR,CURPROC,CURRES;
//$LO16[SDLIST] DLIST;
//$TY PLIST.ENT IS $LO16 INTID,PREVN,K,T $IN32 DETAIL;
//PLIST.ENT[PLISTZ] PLIST;
//$IN [PARAMSZ] PARAMS;
//$IM $LI TADPROC,KVAR,TLO0,TRE0,CLISTZ,TINT0,TINT64;
//$LO8 [CLISTZ] CLIST;
//$IM $LI KSPACE,ICOMP,TNAME,TCONST,KPROC,KFIELD,TLISTZ;
//$IN [TLISTZ] TLIST;
//$IM $LI TSTRING,STRING.TYPE,TDELIM,TLAB,TLO32,IBYTE,KPSPEC,TLO8;
//$LI/ADDR[$LO8] NIL =;
//$IN CMODE;
//$PS MONITOR($IN);
//$PS DUMMY()/$LO16;
//$PS MUTLN($LO16)/$LO16;
//$PS ADD.LSPEC($LO16)/$LO16;
//$PS COMP.TYPE()/$IN;
//$IM $LI IMIN.COMP,ISTORE,IEOS;
//ITYPE MINUS,DIF,DTHEN,DELSE,LB,RB,COMMA,LSB,DOF,RSB,EOS,DEREF,REF;
@END
@TITLE MSL07.1(1,6)
@COL 30R-32N-18T-19R
@COL 1S-2R-3R-4T-5T-6T-7R-17R-8R-9R-10T-11R-12R-14T-15R-16R
@COL 21T-22R-23T-24R-25R-26R-27F
@ROW 30-5
@ROW 6-21
@ROW 32-11
@ROW 15-25
@FLOW 1-2-3-4N-8
@FLOW 5N-6Y-7-17-8-9-10Y-11-12-14N-15-16
@FLOW 4Y-30-8
@FLOW 5Y-21Y-22-9
@FLOW 6N-17
@FLOW 10N-32-18N-19
@FLOW 14Y-25-26-27
@FLOW 16-18
@FLOW 18Y-5
@FLOW 21N-23Y-24-25
@FLOW 23N-12
@BOX 1.0
PREPROCESS.COMP(PTYPE)$IN
@BOX 2.0
DECLARATIONS & INITIALISATION
@BOX 3.0
LEAVE SPACE IN AR FOR
EXPRESSION KIND AND INITIAL
PART EXPRESSION TYPE
SET OPERATOR AS LOAD
@BOX 4.0
NEXT ITEM '^'?
@BOX 5.0
OPERATOR A TERMINATOR?
@BOX6.0
OPERATOR A STORE OP?
@BOX7.0
LEAVE SPACE IN AR FOR
PRE STORE CONVERSION
@BOX17.0
COPY OP TO AR
NOTE EXPRESSION NOT SINGLE OPERAND
@BOX8.0
PREPROCESS OPERAND
#MUSL07.1.1
@BOX 9.0
CHECK TYPE OF OPERAND NOTING
LARGEST TYPE IN PART EXPRESSION
NOTE OPERAND REGISTER USAGE
@BOX10.0
OPERATOR A STORE OP OR TERMINATOR?
@BOX11.0
FILL IN PRE STORE CONVERSION
@BOX12.0
FILL IN PART EXPRESSION TYPE
@BOX14.0
OPERATOR A TERMINATOR?
@BOX15.0
NOTE OPERAND TYPE AS NEW LARGEST TYPE
@BOX16.0
LEAVE SPACE IN AR FOR
NEW PART EXPRESSION TYPE
@BOX30.0
SET REF
@BOX18.0
NEXT ITEM => OP
AN OPERATOR OR
COMPUTATION
TERMINATOR?
@BOX19.0
FAULT 0
@BOX21.0
IS COMPUTATION
A PARAMETER ASSIGNMENT?
@BOX22.0
LEAVE SPACE IN AR FOR
PRE ASSIGNMENT CONVERSION
SET OPERAND TYPE
FROM PARAMETER TYPE
MARK EXPRESSION KIND
AS PARAMETER TYPE
@BOX23.0
PREVIOUS OP STORE OP?
@BOX24.0
REMOVE SPACE ON AR FOR
NEXT PART EXPRESSION TYPE
@BOX25.0
COPY COMPUTATION TERMINATOR TO AR
FILL IN EXPRESSION KIND IN AR
@BOX 26.0
SET RESULT TO FINAL TYPE
@BOX 27.0
EXIT
@B1.1
$PR PREPROCESS.COMP(PTYPE);
@B1.2
int PREPROCESSCOMP(int PTYPE)
{
int result;
@B2.1
::DECL & INIT
$IN OP,I,J,F,U,N,MSLN,MTLN;
$IN OK.AP,INIT.AP,PE.AP,PS.AP,DL.OP,DL.PREV;
$IN REFR,USES.B,USES.D,COMP.KIND,SINGLE.OPD;
$IN CMP.TYPE,OPD.TYPE,RTYPE;
0 => CMP.TYPE => COMP.KIND => REFR;
%80 => SINGLE.OPD;
@B2.2
//DECL & INIT
int OP,I,J,F,U,N,MSLN,MTLN;
int OKAP,INITAP,PEAP,PSAP,DLOP,DLPREV;
int REFR,USESB,USESD,COMPKIND,SINGLEOPD;
int CMPTYPE,OPDTYPE,RTYPE;
CMPTYPE =0;
COMPKIND = 0;
REFR = 0;
SINGLEOPD = 0x80;
@B3.1
AP => INIT.AP + 1 => PE.AP + 1 => AP;
ILOAD => OP;
0 => DL.OP => DL.PREV;
@B3.2
INITAP = AP;
PEAP = INITAP + 1;
AP = PEAP + 1;
OP = ILOAD;
DLOP = 0;
DLPREV = 0;
@B4.1
IF LBUFF[IPTR+1] = REF
@B4.2
if (memcmp(&LBUFF[IPTR+1], &REF, sizeof(ITYPE)) == 0)
@B5.1
IF DL.OP & %800 /= 0
@B5.2
if ((DLOP & 0x800) != 0)
@BOX6.1
IF DL.OP & %4 = 0
@BOX6.1
if ((DLOP & 0x4) == 0)
@BOX7.1
AP => PS.AP + 1 => AP;
@BOX7.2
PSAP = AP;
AP = PSAP + 1;
@BOX17.1
OP => AR[AP];
1 +> AP;
0 => SINGLE.OPD;
@BOX17.2
AR[AP]= OP;
AP++;
SINGLEOPD = 0;
@BOX8.1
#MSL07.1.1
@BOX8.2
#MSL07.1.1
@B9.1
CHECK.TYPE(OP,CMP.TYPE,OPD.TYPE) => CMP.TYPE;
USES.B ! USES.D !> COMP.KIND;
0 => REFR;
@B9.2
CMPTYPE = CHECKTYPE(OP,CMPTYPE,OPDTYPE);
COMPKIND |= USESB | USESD;
REFR = 0;
@BOX10.1
IF DL.OP & %804 = 0
@BOX10.2
if ((DLOP & 0x804) == 0)
@BOX11.1
OPD.TYPE ! %80(3) => AR[PS.AP];
@BOX11.2
AR[PSAP] = OPDTYPE | 0x8000;
@BOX12.1
CMP.TYPE ! %80(3) => AR[PE.AP];
@BOX12.2
AR[PEAP] = CMPTYPE | %8000;
@BOX14.1
IF DL.OP & %800 /= 0
@BOX14.2
if ((DLOP & 0x800) != 0)
@BOX15.1
OPD.TYPE => CMP.TYPE;
@BOX15.2
CMPTYPE = OPDTYPE;;
@BOX16.1
AP => PE.AP + 1 => AP;
@BOX16.2
PEAP = AP;
AP = PEAP + 1;
@BOX30.1
1 +> IPTR;
REF.BIT => REFR;
@BOX30.2
IPTR++;
REFR = REFBIT;
@BOX18.1
DL.OP => DL.PREV;
IF TAG OF LBUFF[1+>IPTR] = TDELIM
AND DLIST[IND OF LBUFF[IPTR] => OP]
=> DL.OP & %810 /= 0
@BOX18.2
DLPREV = DLOP;
DLOP = DLIST[(OP = LBUFF[IPTR].IND)];
if (LBUFF[++IPTR].TAG == TDELIM && (DLOP & 0x810) != 0)
@BOX19.1
MONITOR(0);
@BOX19.2
MONITOR(0);
@BOX21.1
IF PTYPE = 0
@BOX21.2
if (PTYPE == 0)
@BOX22.1
AP => PS.AP + 1 => AP;
PTYPE => OPD.TYPE;
%100 !> COMP.KIND;
@BOX22.2
PSAP = AP;
AP = PSAP + 1;
OPDTYPE = PTYPE;
COMPKIND |= 0x100;
@BOX23.1
IF DL.PREV & %4 = 0
@BOX23.2
if ((DLPREV & 0x4) == 0)
@BOX24.1
1 -> AP;
@BOX24.2
AP--;
@BOX25.1
OP => AR[AP];
1 +> AP;
COMP.KIND ! SINGLE.OPD => AR[INIT.AP];
@BOX25.2
AR[AP] = OP;
AP++;
AR[INITAP] = COMPKIND | SINGLE.OPD;
@BOX26.1
CMP.TYPE => PREPROCESS.COMP;
@BOX26.2
result = CMPTYPE;
@BOX27.1
END
@BOX27.2
return result;
}
@END
@TITLE MSL07.1.1(1,6)
@COL 12R-30R-13R-14R-15R-16N
@COL 1S-2R-3T-4T-5T-6T-7T-8R-9T-10R-11R-37F
@COL 17T-18T-19R-33T-20T-21T-22R-23N
@COL 35T-36R-24R-25R-26N-31T-32R-27R-28N
@ROW 4-17
@ROW 12-5
@ROW 18-35
@ROW 30-6
@ROW 15-10
@ROW 16-11-23-28
@FLOW 1-2-3N-4N-5N-6Y-7Y-8-13
@FLOW 3Y-17Y-18N-19-26-28
@FLOW 17N-35Y-36-18
@FLOW 35N-24-28-23
@FLOW 18Y-25
@FLOW 4Y-12
@FLOW 5Y-30-13-16-11-37
@FLOW 6N-33N-20N-21Y-22-23-11
@FLOW 20Y-9N-10-11
@FLOW 9Y-15-16-11
@FLOW 21N-31Y-32-23
@FLOW 31N-27
@FLOW 7N-14
@FLOW 33Y-25
@BOX 1.0
PREPROCESS
OPERAND
@BOX 2.0
INITIALISE FOR
EACH OPERAND
LEAVE SPACE IN AR
FOR OPERAND KIND
@BOX 3.0
NEXT ITEM
A NAME?
@BOX 4.0
REF SET OR
OPERATOR A
STORE OP?
@BOX 5.0
NEXT ITEM
A CONSTANT?
@BOX 6.0
NEXT ITEM '-'
FIRST OPERAND?
@BOX 7.0
NEXT ITEM A
REAL OR LOGICAL
LITERAL?
@BOX 8.0
SET OPERAND
KIND AS NEGATIVE
LITERAL
@BOX 9.0
NEXT ITEM
'IF'?
@BOX 10.0
PREPROCESS
SUBEXPRESSION
#MSL07.1.1.5
@BOX 11.0
ADJUST TYPE
IF ADDR PROC
@BOX37.0
END
@BOX 12.0
FAULT 6
@BOX 13.0
PREPROCESS
LITERAL
#MSL07.1.1.1
@BOX 14.0
FAULT 4
@BOX 15.0
PREPROCESS
CONDITIONAL
COMPUTATION
#MSL07.1.1.4
@BOX 17.0
NEXT ITEM '('?
@BOX 18.0
REF SET OR
OPERATOR A
STORE OR SHIFT OP?
@BOX 19.0
PREPROCESS
PROC CALL
#MSL07.1.1.3
@BOX 20.0
NEXT ITEM
'('?
@BOX 21.0
NEXT ITEM
BUILT IN FUNCTION
DELIMITER?
@BOX 22.0
PREPROCESS BUILT IN
FUNCTION
#MSL07.1.1.6
@BOX35.0
NEXT TWO ITEMS
'^' AND '(' ?
@BOX36.0
NOTE CALL BY
PROC VARIABLE
@BOX 24.0
PREPROCESS
NAMED ITEM
#MSL07.1.1.2
@BOX 25.0
FAULT 6
@BOX 31.0
NEXT ITEM
A STRING?
@BOX 32.0
PREPROCESS
STRING
#MSL07.1.1.7
@BOX 27.0
FAULT 0
@BOX 30.0
SET OPERAND
KIND AS
LITERAL
@BOX33.0
OPERATOR A
SHIFT OP?
@B1.1
BEGIN
::PREPROCESS OPERAND
@B1.2
{
//PREPROCESS OPERAND
@B2.1
0 => USES.B => USES.D;
AP => OK.AP + 1 => AP;
@B2.2
USESB = 0;
USESD = 0;
OKAP = AP;
AP = OKAP + 1;
@B3.1
IF TAG OF LBUFF[IPTR+1] => I = TNAME
@B3.2
I = LBUFF[IPTR+1].TAG;
if (I == TNAME)
@B4.1
IF REFR /= 0 OR DL.OP & %4 /= 0
@B4.2
if (REFR != 0 || (DLOP & 0x4) != 0)
@B5.1
IF I = TCONST
@B5.2
if (I == TCONST)
@B6.1
IF LBUFF[IPTR+1] /= MINUS
OR SINGLE.OPD = 0
@B6.2
if (memcmp(&LBUFF[IPTR+1], &MINUS, sizeof(ITYPE)) != 0 || SINGLEOPD == 0)
@B7.1
IF TAG OF LBUFF[1+>IPTR+1] /= TCONST
OR ST OF LBUFF[IPTR+1] ->> 6 = 1
@B7.2
if (LBUFF[++IPTR+1].TAG != TCONST) || (LBUFF[IPTR+1].ST >> 6) == 1)
@B8.1
2 => AR[OK.AP]
@B8.2
AR[OKAP] = 2;
@B9.1
$IF LBUFF[1+>IPTR+1] = DIF
@B9.2
if (memcmp(&LBUFF[++IPTR+1], &DIF, sizeof(ITYPE)) == 0)
@B10.1
#MSL07.1.1.5
@B10.2
#MSL07.1.1.5
@B11.1
IF OPD.TYPE & %8000 /= 0 THEN
TADPROC => OPD.TYPE FI
@B11.2
if ((OPDTYPE & 0x8000) != 0)
{
  OPDTYPE = TADPROC;
}
@B37.1
END::7.1.1
@B37.2
}//7.1.1
@B12.1
MONITOR(6);
@B12.2
MONITOR(6);
@B30.1
1 => AR[OK.AP];
@B30.2
AR[OKAP] = 1;
@B13.1
#MSL07.1.1.1
@B13.2
#MSL07.1.1.1
@B14.1
MONITOR(4);
@B14.2
MONITOR(4);
@B15.1
#MSL07.1.1.4
@B15.2
#MSL07.1.1.4
@B17.1
3 => U;
IND OF LBUFF[IPTR+1] => MSLN;
IF LBUFF[IPTR+2] /= LB
@B17.2
U = 3;
MSLN = LBUFF[IPTR+1].IND;
if (memcmp(&LBUFF[IPTR+2], &LB, sizeof(ITYPE)) != 0)
@B18.1
2 +> IPTR
IF REFR /= 0 OR DL.OP & %1004 /= 0
@B18.2
IPTR += 2;
if (REFR != 0 || (DLOP & 0x1004) != 0)
@B19.1
#MSL07.1.1.3
@B19.2
#MSL07.1.1.3
@B20.1
IF LBUFF[IPTR+1] = LB
@B20.2
if (memcmp(&LBUFF[IPTR+1], &LB, sizeof(ITYPE)) == 0)
@B21.1
IF I /= TDELIM
OR DLIST[IND OF LBUFF[IPTR+1] => I] & %400 = 0
@B21.2
if (I != TDELIM || (DLIST[(I = LBUFF[IPTR+1].IND)] & 0x400) == 0)
@B22.1
#MSL07.1.1.6
@B22.2
#MSL07.1.1.6
@B35.1
IF LBUFF[IPTR+2] /= DEREF
OR LBUFF[IPTR+3] /= LB
@B35.2
if (memcmp(&LBUFF[IPTR+2], &DEREF, sizeof(ITYPE)) != 0 || memcmp(&LBUFF[IPTR+3], &LB, sizeof(ITYPE)) != 0)
@B36.1
1 +> IPTR;
9 => U;
@B36.2
IPTR++;
U = 9;
@B24.1
#MSL07.1.1.2
@B24.2
#MSL07.1.1.2
@B25.1
MONITOR(6);
@B25.2
MONITOR(6);
@B31.1
IF I /= TSTRING
@B31.2
if (I != TSTRING)
@B32.1
#MSL07.1.1.7
@B32.2
#MSL07.1.1.7
@B27.1
MONITOR(0);
@B27.2
MONITOR(0);
@BOX33.1
IF DL.OP & %1000 /= 0
@BOX33.2
if ((DLOP & 0x1000) != 0)
@END
@TITLE MSL07.1.1.1(1,6)
@COL 1S-2R-3R-4F
@FLOW 1-2-3-4
@BOX 1.0
PREPROCESS
LITERAL
@BOX 2.0
PUT LITERAL
TYPE AND SIZE
WITH OPERAND
KIND IN AR
AND SET OPERAND
TYPE FROM IT
@BOX 3.0
COPY LITERAL
INDEX TO AR
@BOX 4.0
END
@BOX 1.1
::PREPROCESS LITERAL
@BOX 1.2
//PREPROCESS LITERAL
@BOX 2.1
ST OF LBUFF[1+>IPTR] => OPD.TYPE <<- 4 !> AR[OK.AP];
IF OPD.TYPE & %C0 = TRE0 THEN
TRE => OPD.TYPE FI
@BOX 2.2
OPDTYPE = LBUFF[++IPTR].ST;
 R[OK.AP] |= OPDTYPE << 4;
if ((OPDTYPE & 0xC0 == TRE0)
{
  OPDTYPE = TRE;
}
@BOX 3.1
IND OF LBUFF[IPTR] => AR[AP];
1 +> AP;
@BOX 3.2
AR[AP] = LBUFF[IPTR].IND;
AP++;
@BOX 4.1
::END 7.1.1.1
@BOX 4.2
//END 7.1.1.1
@END
@TITLE MSL07.1.1.2(1,6)
@COL 1S-2R-3R-4R-6T-7T-8T-9R-15R-10R-11F
@COL 12R-13R-14R
@ROW 7-12
@FLOW 1-2-3-4-6N-7N-8N-9-15-10-11
@FLOW 6Y-12-6
@FLOW 7Y-13-6
@FLOW 8Y-14-6
@BOX 1.0
PREPROCESS
NAMED ITEM
@BOX 2.0
SET POINTERS TO
FIELDS OF OPERAND
IN LBUFF IN
FIELDS VECTOR
#MSL07.1.1.2.1
@BOX 3.0
NOTE FINAL VALUE
FOR IPTR THEN
RESET TO RIGHTMOST
'FIELD'
@BOX 4.0
FORM BASE OPERAND
AND TYPE
#MSL07.1.1.2.2
@BOX 6.0
NEXT ITEM '^'?
@BOX 7.0
NEXT ITEM '['?
@BOX 8.0
ANY MORE
SUBFIELDS?
@BOX 9.0
SET OPERAND KIND
AS NAMED ITEM
WITH B/D
AND REF INFO
@BOX 15.0
ADJUST TYPE
IF REF SET
AND NOT ADDR PROC
AND NOT LABEL
@BOX 10.0
SET IPTR TO
FINAL VALUE
@BOX 11.0
END
@BOX 12.0
DEREFERENCE
#MSL07.1.1.2.3
@BOX 13.0
SUBSCRIPT
#MSL07.1.1.2.4
@BOX 14.0
SELECT FIELD
#MSL07.1.1.2.5
@B1.1
BEGIN
::PREPROCESS NAMED ITEM
$IN INIT.FPTR,END.IPTR;
@B1.2
{
//PREPROCESS NAMED ITEM
int INITFPTR,ENDIPTR;
@B2.1
FPTR => INIT.FPTR;
#MSL07.1.1.2.1
@B2.2
INITFPTR = FPTR;
#MSL07.1.1.2.1
@B3.1
IPTR => END.IPTR;
FIELDS[FPTR -1 => FPTR] => IPTR;
@B3.2
ENDIPTR = IPTR;
IPTR = FIELDS[--FPTR];
@B4.1
#MSL07.1.1.2.2
@B4.2
#MSL07.1.1.2.2
@B6.1
IF LBUFF[IPTR+1] = DEREF
@B6.2
if (memcmp(&LBUFF[IPTR+1], &DEREF, sizeof(ITYPE)) == 0)
@B7.1
IF LBUFF[IPTR+1] = LSB
@B7.2
if (memcmp(&LBUFF[IPTR+1], &LSB, sizeof(ITYPE)) == 0)
@B8.1
IF FPTR /= INIT.FPTR
@B8.2
if (FPTR != INITFPTR)
@B9.1
REFR ! USES.D ! USES.B => AR[OK.AP];
@B9.2
AR[OKAP] = REFR || USESD || USESB;
@BOX 15.1
IF REFR /= 0 AND OPD.TYPE & %8000 = 0
AND OPD.TYPE /= TLAB THEN
IF OPD.TYPE & 3 /= 0 THEN
CAPTION(%"MSL07.1.1.2 BOX 15");
MONITOR(3);
FI
IF OPD.TYPE > %4000 THEN
OPD.TYPE & %3FFC ! 3 => OPD.TYPE
ELSE
OPD.TYPE ! 1 => OPD.TYPE
FI
FI
@BOX 15.2
if (REFR != 0 && (OPDTYPE & 0x8000) == 0 && OPDTYPE != TLAB)
{
  if ((OPDTYPE & 3) != 0)
  {
    CAPTION("MSL07.1.1.2 BOX 15");
    MONITOR(3);
  }
  if (OPDTYPE > 0x4000)
  {
    OPDTYPE = (OPDTYPE & 0x3FFC) | 3;
  }
  else
  {
    OPDTYPE = OPDTYPE | 1;
  }
}
@BOX 10.1
END.IPTR => IPTR;
@BOX 10.2
IPTR = ENDIPTR;
@B11.1
END::7.1.1.2
@B11.2
}//7.1.1.2
@B12.1
1 +> IPTR;
#MSL07.1.1.2.3
@B12.2
IPTR++;
#MSL07.1.1.2.3
@B13.1
1 +> IPTR;
#MSL07.1.1.2.4
@B13.2
IPTR++;
#MSL07.1.1.2.4
@B14.1
#MSL07.1.1.2.5
@B14.2
#MSL07.1.1.2.5
@END
@TITLE MSL07.1.1.2.1(1,6)
@COL 1S-2R-3T-4T-5T-6T-7R
@COL 8R-9T-10T-11T-12N-13F
@COL 14R-15T-16R
@COL 17R
@ROW 5-8
@ROW 7-10-14
@ROW 12-16-17
@FLOW 1-2-3N-4N-5Y-6Y-2
@FLOW 6-7
@FLOW 3Y-3
@FLOW 4Y-8-9N-10Y-11Y-12-3
@FLOW 5N-13
@FLOW 11N-9
@FLOW 9Y-14-9
@FLOW 10N-15N-16-9
@FLOW 15Y-17
@BOX 1.0
SET POINTERS TO
FIELDS OF OPERAND
@BOX 2.0
SET POINTER
TO FIELD
@BOX 3.0
NEXT ITEM
'^'?
@BOX 4.0
NEXT ITEM
'['?
@BOX 5.0
NEXT ITEM
'OF'
@BOX 6.0
NEXT ITEM
A NAME?
@BOX 7.0
FAULT 0
@BOX 8.0
1 => COUNT
@BOX 9.0
NEXT ITEM
'['?
@BOX 10.0
NEXT ITEM
']'?
@BOX 11.0
COUNT -1
=> COUNT = 0?
@BOX 13.0
END
@BOX 14.0
1 +> COUNT
@BOX 15.0
NEXT ITEM
EOS?
@BOX 16.0
SKIP ITEM
@BOX 17.0
FAULT 0
@B1.1
BEGIN
::SET POINTERS TO FIELDS OF OPERAND
@B1.2
{
//SET POINTERS TO FIELDS OF OPERAND
@B2.1
IPTR => FIELDS[FPTR];
1 +> FPTR;
@B2.2
FIELDS[FPTR] = IPTR;
FPTR++;
@B3.1
IF LBUFF[1+>IPTR+1] = REF
@B3.2
if (memcmp(&LBUFF[++IPTR+1], &REF, sizeof(ITYPE)) == 0)
@B4.1
IF LBUFF[IPTR+1] = LSB
@B4.2
if (memcmp(&LBUFF[IPTR+1], &LSB, sizeof(ITYPE)) == 0)
@B5.1
IF LBUFF[IPTR+1] /= DOF
@B5.2
if (memcmp(&LBUFF[IPTR+1], &DOF, sizeof(ITYPE)) != 0)
@B6.1
IF TAG OF LBUFF[1+>IPTR+1] = TNAME
@B6.2
if (LBUFF[++IPTR+1].TAG == TNAME)
@B7.1
MONITOR(0);
@B7.2
MONITOR(0);
@B8.1
1 => I;
@B8.2
I = 1;
@B9.1
IF LBUFF[1+>IPTR+1] = LSB
@B9.2
if (memcmp(&LBUFF[++IPTR+1], &LSB, sizeof(ITYPE)) == 0)
@B10.1
IF LBUFF[IPTR+1] /= RSB
@B10.2
if (memcmp(&LBUFF[IPTR+1], &RSB, sizeof(ITYPE)) != 0)
@B11.1
IF I -1 => I /= 0
@B11.2
if (--I != 0)
@B13.1
END::7.1.1.2.1
@B13.2
}//7.1.1.2.1
@B14.1
1 +> I;
@B14.2
I++;
@B15.1
IF LBUFF[IPTR+1] = EOS
@B15.2
if (memcmp(&LBUFF[IPTR+1], &EOS, sizeof(ITYPE)) == 0)
@B16.1
::DONE IN BOX 9
@B16.2
//DONE IN BOX 9
@B17.1
MONITOR(0);
@B17.2
MONITOR(0);
@END
@TITLE MSL07.1.1.2.2(1,6)
@COL 9R-10R-18R-19T-25R-26T-27R
@COL 1S-2T-3T-20T-4R-5R-6R-7R-8F
@COL 21R-17R-24R-11R-12R-23R-13R
@COL 14R-22T-15T-16R
@ROW 3-21
@ROW 9-5-11-14
@FLOW 1-2Y-3Y-20N-4
@FLOW 5-6-7-8
@FLOW 2N-21
@FLOW 3N-17
@FLOW 20Y-24-7
@FLOW 9-10
@FLOW 11-12-6
@FLOW 14-22N-15N-16
@FLOW 22Y-23-7
@FLOW 15Y-13-6
@FLOW 18-19N-6
@FLOW 19Y-10
@FLOW 25-26Y-27-7
@FLOW 26N-10
@BOX 1.0
FORM BASE
OPERAND
AND TYPE
@BOX 2.0
IS THERE A
MUTL NAME
FOR THE
MUSL NAME?
@BOX 3.0
IS IT IN
SCOPE?
@BOX20.0
IS IT A
SPECIAL NAME?
@BOX 4.0
SWITCH ON
KIND OF PLIST
FOR MUTL NAME
@BOX 5.0
VARIABLE
SPACE
VSTORE
@BOX 6.0
GET BASE TYPE
FROM PLIST
@BOX 7.0
COPY MUTL
NAME TO AR
@BOX 8.0
END
@BOX 9.0
TYPE
TYPE REF
EXPORT
@BOX 10.0
FAULT 6
@BOX 11.0
FIELD
@BOX 12.0
NOTE OPERAND
USES D
@BOX 23.0
SET BASE TYPE
AS ADDR PROC
@BOX 13.0
GET MUTL NAME
OF RESULT
VARIABLE
@BOX 14.0
UNDEFINED PROC
UNDEFINED PPROC
PROC
@BOX 22.0
REF REQUIRED?
@BOX 15.0
CURRENT PROC
& A FUNCTION?
@BOX 16.0
FAULT 6
@BOX 17.0
FAULT 2
@BOX24.0
SET MUTL NAME
AND BASE TYPE
@BOX 18.0
LITERAL
DATAVEC
@BOX 19.0
STORE
OPERATOR?
@BOX25.0
RESTART LABEL
LABEL
UNDEFINED LABEL
@BOX26.0
FIRST OPERAND?
@BOX27.0
SET REF REQUIRED
SET BASE TYPE
AS LABEL
@BOX 21.0
FAULT 1
@B1.1
BEGIN
::FORM BASE OPERAND AND TYPE
@B1.2
{
//FORM BASE OPERAND AND TYPE
@B2.1
IND OF LBUFF[1+>IPTR] => MSLN;
IF MUTLN(MSLN) => MTLN = 0
@B2.2
MSLN = LBUFF[++IPTR].IND;
MTLN = MUTLN(MSLN);
if (MTLN == 0)
@B3.1
IF MTLN < CURLEV AND MTLN >= GLEV
AND MTLN /= CURPROC
@B3.2
if (MTLN < CURLEV && MTLN >= GLEV && MTLN != CURPROC)
@B20.1
IF MTLN > %1000
@B20.1
if (MTLN > 0x1000)
@B4.1
SWITCH K OF PLIST[MTLN]-1
\K1,K2,K3,K4,K5,K6,K7,K8,K9,K10,K11,K12,K13,K14,K15;
@B4.2
switch (PLIST[MTLN].K-1)
{
case 0: goto K1;
case 1: goto K2;
case 2: goto K3;
case 3: goto K4;
case 4: goto K5;
case 5: goto K6;
case 6: goto K7;
case 7: goto K8;
case 8: goto K9;
case 9: goto K10;
case 10: goto K11;
case 11: goto K12
case 12: goto K13;
case 13: goto K14;
case 14: goto K15;
}
@B5.1
K4:
K8:
@B5.2
K4:
K8:
@B6.1
T OF PLIST[MTLN] => OPD.TYPE;
@B6.2
OPDTYPE = PLIST[MTLN].T;
@B7.1
MTLN => AR[AP];
1 +> AP;
@B7.2
AR[AP] = MTLN;
AP++;
@B8.1
END::7.1.1.2.2
@B8.2
}//7.1.1.2.2
@B9.1
K6:
K9:
K10:
K12:
@B9.2
K6:
K9:
K10:
K12:
@B10.1
MONITOR(6);
@B10.2
MONITOR(6);
@B18.1
K7:
K11:
@B18.2
K7:
K11:
@B19.1
IF DLIST[OP] & %4 /= 0
@B19.2
if ((DLIST[OP] & 0x4) != 0)
@B25.1
K13:
K14:
K15:
@B25.2
K13:
K14:
K15:
@B26.1
IF SINGLE.OPD = 0
@B26.2
if (SINGLEOPD == 0)
@B27.1
REF.BIT => REFR;
TLAB => OPD.TYPE;
@B27.2
REFR = REFBIT;
OPDTYPE = TLAB;
@B21.1
MONITOR(1);
@B21.2
MONITOR(1);
@B17.1
MONITOR(2);
@B17.2
MONITOR(2);
@B24.1
TINT => OPD.TYPE;
@B24.1
OPDTYPE = TINT;
@B11.1
K5:
@B11.2
K5:
@B12.1
%40 => USES.D;
@B12.2
USESD = 0x40;
@B23.1
%8000 ! MTLN => OPD.TYPE;
@B23.1
OPDTYPE = 0x8000 | MTLN;
@B13.1
CURRES => MTLN;
@B13.1
MTLN = CURRES;
@B14.1
K1:
K2:
K3:
@B14.2
K1:
K2:
K3:
@B22.1
IF REFR /= 0
@B22.2
if (REFR != 0)
@B15.1
IF MTLN = CURPROC
AND T OF PLIST[CURPROC] /= 0
@B15.2
if (MTLN == CURPROC && PLIST[CURPROC].T != 0)
@B16.1
MONITOR(6);
@B16.2
MONITOR(6);
@END
@TITLE MSL07.1.1.2.3(1,6)
@COL 1S-2R-3T-4T-5R-6R-7F
@COL 8R-9R
@ROW 4-8
@FLOW 1-2-3N-4Y-5-6-7
@FLOW 3Y-8
@FLOW 4N-9
@BOX 1.0
DEREFERENCE
@BOX 2.0
NOTE OPERAND
USES D
@BOX 3.0
OPERAND TYPE
A VECTOR?
@BOX 4.0
OPERAND TYPE
A POINTER?
@BOX 5.0
PUT DEREFERENCE
OPERATOR IN AR
@BOX 6.0
ADJUST OPERAND TYPE BY
REMOVING POINTER
@BOX 7.0
END
@BOX 8.0
FAULT 12
@BOX 9.0
FAULT 3
@B1.1
BEGIN
::DEREFERENCE
@B1.2
{
//DEREFERENCE
@B2.1
%40 => USES.D;
@B2.1
USESD = 0x40;
@B3.1
IF OPD.TYPE & %4003 => I >= %4000
@B3.2
I = OPDTYPE & 0x4003;
if (I >= 0x4000)
@B4.1
IF I = 0
@B4.2
if (I == 0)
@B5.1
%7F => AR[AP];
1 +> AP;
@B5.2
AR[AP] = 0x7F;
AP++;
@B6.1
IF I = 1 THEN
0 => I
ELSE
IF I = 3 THEN
%4000 => I
ELSE
CAPTION(%"7.1.1.2.3 - PROC ADDR!0A!");
MONITOR(3);
FI
FI
OPD.TYPE & %3FFC ! I => OPD.TYPE;
@B6.2
if (I==1)
{
  I = 0;
}
else
{
  if (I == 3)
  {
    I = 0x4000;
  }
  else
  {
    CAPTION("7.1.1.2.3 - PROC ADDR!0A!");
    MONITOR(3);
  }
}
OPDTYPE = (OPDTYPE & 0x3FFC) | I;
@B7.1
END::7.1.1.2.3
@B7.2
}//7.1.1.2.3
@B8.1
MONITOR(12);
@B8.2
MONITOR(12);
@B9.1
MONITOR(3);
@B9.2
MONITOR(3);
@END
@TITLE MSL07.1.1.2.4(1,10)
@COL 1S-2R-3T-5R-6R-7R-8T-9T-10R-11F
@COL 13R-14R-15R
@ROW 5-13
@ROW 9-14
@FLOW 1-2-3Y-5-6-7-8Y-9Y-10-11
@FLOW 3N-13
@FLOW 8N-14
@FLOW 9N-15
@BOX 1.0
SUBSCRIPT
@BOX 2.0
NOTE OPERAND
USES D
@BOX 3.0
OPERAND TYPE
A VECTOR?
@BOX 5.0
INSERT SUBSCRIPT OPERATOR
AND TYPE FOR D IN AR
@BOX 6.0
NOTE OPERAND
USES B
@BOX 7.0
PREPROCESS
COMPUTATION
FOR SUBSCRIPT
@BOX 8.0
SUBSCRIPT TYPE
INTEGER OR ADDRESS ?
@BOX 9.0
WAS LAST
ITEM ']'?
@BOX 10.0
ADJUST OPERAND TYPE
BY REMOVING VECTOR
@BOX 11.0
END
@BOX 13.0
FAULT 12
@BOX 14.0
FAULT 9
@BOX 15.0
FAULT 0
@B1.1
BEGIN
::SUBSCRIPT
@B1.2
{
//SUBSCRIPT
@B2.1
%40 => USES.D;
@B2.2
USESD = 0x40;
@B3.1
IF OPD.TYPE & %40(3) = 0
@B3.2
if ((OPDTYPE & 0x4000) == 0)
@B5.1
%7E => AR[AP];
OPD.TYPE => AR[2 +> AP - 1];
@B5.2
AR[AP] = 0x7E;
AP += 2;
AR[AP - 1] = OPDTYPE ;
@B6.1
%10 => USES.B;
@B6.2
USESB = 0x10;
@B7.1
PREPROCESS.COMP(0) => I;
@B7.2
I = PREPROCESSCOMP(0);
@B8.1
IF CHECK.TYPE(0,TINT,I) /= TINT
AND CHECK.TYPE(0,TBYADDR,I) /= TBYADDR
@B8.2
if (CHECKTYPE(0,TINT,I) != TINT && CHECKTYPE(0,TBYADDR,I) != TBYADDR)
@B9.1
IF LBUFF[IPTR] /= RSB
@B9.2
if (memcmp(&LBUFF[IPTR], &RSB, sizeof(ITYPE)) != 0)
@B10.1
OPD.TYPE & %BFFF => OPD.TYPE;
@B10.2
OPDTYPE = OPDTYPE & 0xBFFF;
@B11.1
END::7.1.1.2.4
@B11.2
}//7.1.1.2.4
@B13.1
MONITOR(12);
@B13.2
MONITOR(12);
@B14.1
MONITOR(9);
@B14.2
MONITOR(9);
@B15.1
MONITOR(0);
@B15.2
MONITOR(0);
@END
@TITLE MSL07.1.1.2.5(1,6)
@COL 1S-2T-3T-4R-5R-6T-7T-8T-9R
@COL 14R-15R-10R-11R-12R-16R-13F
@ROW 7-10
@ROW 3-14
@FLOW 1-2N-3Y-4-5-6N-7N-8N-9
@FLOW 6Y-10-11-12-16-13
@FLOW 7Y-6
@FLOW 8Y-6
@FLOW 2Y-14
@FLOW 3N-15
@BOX1.0
SELECT
FIELD
@BOX2.0
DOES OPERAND TYPE HAVE
VECTOR OR POINTERS?
@BOX3.0
IS IT AN
AGGREGATE?
@BOX4.0
GET INDEX OF
TYPE DESCRIPTION
IN TYPE LIST
NOTE IF UNION
@BOX5.0
SET IPTR FROM
FIELDS POINTERS
GET FIELD NAME
@BOX6.0
IS NAME NEXT
ENTRY IN
TYPE LIST?
@BOX7.0
FURTHER FIELDS
IN TYPE DESCRIPTION?
@BOX8.0
FURTHER ALTERNATIVE
FOR UNION TYPE?
@BOX9.0
FAULT 8
@BOX10.0
PUT SELECT
ALTERNATIVE OPERATOR
IN AR IF UNION
@BOX11.0
PUT SELECT FIELD
OPERATOR IN AR
@BOX12.0
SET TYPE FROM
TYPE LIST
@BOX16.0
NOTE OPERAND
USES D
@BOX13.0
END
@BOX14.0
FAULT 12
@BOX15.0
FAULT 3
@B1.1
BEGIN
::SELECT FIELD
$IN UNION;
@B1.2
{
//SELECT FIELD
int UNION;
@B2.1
IF OPD.TYPE & %C000 /= 0
OR OPD.TYPE & 3 /= 0
@B2.2
if ((OPDTYPE & 0xC000) != 0 || (OPDTYPE & 3) != 0)
@B3.1
IF OPD.TYPE < %100
@B3.2
if (OPDTYPE < 0x100)
@B4.1
IF TLIST[DETAIL OF PLIST[OPD.TYPE->> 2 -64] => I] => N & %8000 /= 0 THEN
1 => UNION;
N & %7FFF => N
ELSE
0 => UNION
FI
0 => F => U;
@B4.2
I = PLIST[(OPDTYPE >> 2) -64].DETAIL;
N = TLIST[I];
if ((N & 0x8000) != 0)
{
  UNION = 1;
  N = N & 0x7FFF;
}
else
{
  UNION = 0;
}
F = 0;
U = 0;
@B5.1
FIELDS[FPTR - 1 => FPTR] => IPTR;
IND OF LBUFF[1+>IPTR] => MSLN;
@B5.2
IPTR = FIELDS[--FPTR];
MSLN = LBUFF[++IPTR].IND;
@B6.1
IF MSLN = TLIST[2+>I]
@B6.2
I += 2;
if (MSLN == TLIST[I])
@B7.1
IF 1 +> F < N
@B7.2
F++;
if (F < N)
@B8.1
0 => F;
1 +> U;
IF UNION = 1 THEN
IF TLIST[1+>I] => N & %8000 /= 0 THEN
N & %7FFF => N
ELSE
2 => UNION
FI
ELSE
0 => UNION
FI
IF UNION /= 0
@B8.2
F = 0;
U++;
if (UNION == 1)
{
  N = TLIST[++I];
  if ((N & 0x8000) != 0)
  {
    N = N & 0x7FFF;
  }
  else
  {
    UNION = 2;
  }
}
else
{
  UNION = 0;
}
if (UNION != 0)
@B9.1
MONITOR(8);
@B9.2
MONITOR(8);
@B14.1
MONITOR(12);
@B14.2
MONITOR(12);
@B15.1
MONITOR(3);
@B15.2
MONITOR(3);
@B10.1
IF UNION > 0 THEN
%C0 ! U => AR[AP];
1 +> AP
FI
@B10.2
if (UNION > 0)
{
  AR[AP] = 0xC0 | U;
  AP++;
}
@B11.1
%80 ! F => AR[AP];
1 +> AP;
@B11.2
AR[AP] = 0x80 | F;
AP++;
@B12.1
TLIST[I - 1] => OPD.TYPE;
@B12.2
OPDTYPE = TLIST[I - 1];
@B16.1
%40 => USES.D;
@B16.2
USESD = 0x40;
@B13.1
END::7.1.1.2.5
@B13.2
}//7.1.1.2.5
@END
@TITLE MSL07.1.1.3(1,8)
@COL 12R-13R
@COL 1S-2T-4T-5R-6R-18R-7R-8R-19R-9T-10T-11F
@COL 20T-14T-15R-16N
@COL 21T-22R-17R
@ROW 4-20
@ROW 14-21
@ROW 12-5
@ROW 13-11
@FLOW 1-2N-4Y-5-6-18-7-8-19-9N-10Y-11
@FLOW 2Y-20
@FLOW 4N-12
@FLOW 20N-14Y-15-16-6
@FLOW 20Y-21Y-22-16
@FLOW 21N-17
@FLOW 14N-17
@FLOW 9Y-11
@FLOW 10N-13
@BOX1.0
PREPROCESS
PROC CALL
@BOX2.0
IS THERE A MUTL
NAME FOR THE MUSL NAME?
@BOX4.0
NOT CALL BY PROC VARIABLE
AND AUTOMATIC LSPECS PERMITTED
AND LSPEC ADDED SUCCESSFULLY?
@BOX5.0
SET OPERAND KIND
AS LIB PROC CALL
COPY MUTL NAME
OF LSPEC TO AR
@BOX6.0
GET RESULT TYPE
AND NO OF PARAMS
@BOX7.0
PREPROCESS
ACTUAL PARAMETERS
#MSL07.1.1.3.1
@BOX8.0
SET TYPE FROM
RESULT TYPE
@BOX9.0
IS IT A FUNCTION?
@BOX10.0
ONLY OPERAND
IN COMPUTATION?
@BOX11.0
END
@BOX12.0
FAULT 6
@BOX13.0
FAULT 10
@BOX20.0
CALL BY PROC
VARIABLE?
@BOX14.0
IS IT A
PROC?
@BOX15.0
SET OPERAND KIND
AS PROC CALL
COPY MUTL
NAME TO AR
@BOX21.0
IS IT A VARIABLE
OR SELECTED FIELD
OF TYPE ADDR PROC?
@BOX22.0
COPY MUTL NAME
TO AR
GET ASSOCIATED
PROC SPEC
@BOX17.0
FAULT 10
@BOX 18.0
PUT OPERAND KIND
RESULT TYPE
AND NO OF PARAMS
IN AR
@BOX 19.0
NOTE COMPUTATION
DESTROYS A/B/D
AND MAY HAVE A
RESULT IN A
@B1.1
BEGIN
::PREPROCESS PROC CALL
@B1.2
{
//PREPROCESS PROC CALL
@B2.1
IF MUTLN(MSLN)
=> MTLN /= 0
@B2.2
MTLN = MUTLN(MSLN);
if (MTLN != 0)
@B4.1
IF U = 9 OR CMODE & %40 /= 0
OR ADD.LSPEC(MSLN) => MTLN = 0
@B4.2
if (U == 9 || (CMODE & 0x40) != 0 || (MTLN = ADDLSPEC(MSLN)) == 0)
@B5.1
4 => U;
MTLN => AR[AP];
@B5.2
U = 4;
AR[AP] = MTLN;
@B6.1
T OF PLIST[MTLN] => RTYPE;
PARAMS[DETAIL OF PLIST[MTLN] => F] => N;
@B6.2
RTYPE = T OF PLIST[MTLN];
F = PLIST[MTLN].DETAIL;
N = PARAMS[F];
@B18.1
U => AR[OK.AP];
RTYPE => AR[AP+1];
N => AR[3+>AP-1];
@B18.2
AR[OKAP] = U;
AR[AP+1] = RTYPE;
AP += 3;
AR[AP-1] = N;
@B7.1
#MSL07.1.1.3.1
@B7.2
#MSL07.1.1.3.1
@B8.1
RTYPE => OPD.TYPE;
@B8.2
OPDTYPE = RTYPE;
@B9.1
IF RTYPE /= 0
@B9.2
if (RTYPE != 0)
@B10.1
IF CMP.TYPE /= 0
OR LBUFF[IPTR+1] /= EOS
@B10.2
if (CMPTYPE != 0 || memcmp(&LBUFF[IPTR+1], &EOS, sizeof(ITYPE)) != 0)
@B11.1
END::7.1.1.3
@B11.2
}//7.1.1.3
@B12.1
MONITOR(6);
@B12.2
MONITOR(6);
@B13.1
MONITOR(10);
@B13.2
MONITOR(10);
@B20.1
K OF PLIST[MTLN] => I;
IF U = 9
@B20.2
I = PLIST[MTLN].K;
if (U==9)
@B14.1
IF I /= KPROC
AND I /= KPSPEC
@B14.2
if (I != KPROC && I != KPSPEC)
@B15.1
::OPERAND KIND SET
::IN MSL07.1.1 BOX 17
MTLN => AR[AP];
@B15.2
//OPERAND KIND SET
//IN MSL07.1.1 BOX 17
AR[AP] = MTLN;
@B21.1
IF I /= KVAR /= KFIELD
OR T OF PLIST[MTLN] => I
& %C000 /= %8000
@B21.2
if ((I != KVAR && I != KFIELD) || ((I = PLIST[MTLN].T) && 0xC000) != 0x8000)
@B22.1
MTLN => AR[AP];
I & %3FFF => MTLN;
@B22.2
AR[AP] = MTLN;
MTLN = I & 0x3FFF;
@B17.1
MONITOR(10);
@B17.2
MONITOR(10);
@BOX 19.1
%170 !> COMP.KIND;
@BOX 19.2
COMPKIND |= 0x170;
@END
@TITLE MSL07.1.1.3.1(1,8)
@COL 1S-2T-3R-4R-6T-7T-8R
@COL 9R-10T-11F
@ROW 3-9
@ROW 7-10
@FLOW 1-2Y-3-4-6N-7N-8
@FLOW 2N-9-10Y-11
@FLOW 6Y-10
@FLOW 10N-8
@FLOW 7Y-3
@BOX1.0
PREPROCESS
ACTUAL
PARAMETERS
@BOX2.0
ANY PARAMETERS?
@BOX3.0
GET TYPE OF
NEXT FORMAL PARAMETER
ADJUSTING IF
ADDR PROC
@BOX4.0
PREPROCESS COMPUTATION
FOR ACTUAL PARAMETER
@BOX6.0
ALL PARAMETERS
PROCESSED?
@BOX7.0
WAS LAST
ITEM ','?
@BOX8.0
FAULT 11
@BOX9.0
SKIP ITEM
@BOX10.0
WAS LAST
ITEM ')'?
@BOX11.0
END
@B1.1
BEGIN
::PREPROCESS ACTUAL PARAMETERS
@B1.2
BEGIN
//PREPROCESS ACTUAL PARAMETERS
@B2.1
1 => I;
$IF N = 0
@B2.2
I = 1;
if (N == 0)
@B3.1
PARAMS[F+I]=>J;
IF J & %8000 /= 0 THEN
TADPROC => J FI
@B3.2
J = PARAMS[F+I];
if ((J & 0x8000) != 0)
{
  J = TADPROC;
}
@B4.1
PREPROCESS.COMP(J);
@B4.2
PREPROCESSCOMP(J);
@B6.1
IF 1 +> I > N
@B6.2
if (++I > N)
@B7.1
$IF LBUFF[IPTR] = COMMA
@B7.2
if (memcmp(&LBUFF[IPTR], &COMMA, sizeof(ITYPE)) == 0))
@B8.1
MONITOR(11);
@B8.2
MONITOR(11);
@B9.1
1 +> IPTR;
@B9.2
IPTR++;
@B10.1
IF LBUFF[IPTR] /= RB
@B10.2
if (memcmp(&LBUFF[IPTR], &RB, sizeof(ITYPE)) != 0))
@B11.1
END::7.1.1.3.1
@B11.2
}//7.1.1.3.1
@END
@TITLE MSL07.1.1.4(1,6)
@COL 1S-2R-3T-4R-5T-6R-7T-8T-9R-10F
@COL 11R-12R
@ROW 8-11
@ROW 9-12
@FLOW 1-2-3Y-4-5Y-6-7Y-8Y-9-10
@FLOW 3N-11
@FLOW 7N-11
@FLOW 8N-12
@FLOW 5N-11
@BOX 1.0
PREPROCESS
CONDITIONAL
COMPUTATION
@BOX 2.0
PREPROCESS
CONDITION
@BOX 3.0
LAST ITEM
'THEN'?
@BOX 4.0
PREPROCESS
COMPUTATION
NOTE TYPE
@BOX 5.0
LAST ITEM
'ELSE'
@BOX 6.0
PREPROCESS
COMPUTATION
@BOX 7.0
LAST ITEM
')'?
@BOX 8.0
TYPES OF COMPUTATIONS
THE SAME?
@BOX 9.0
SET OPERAND KIND
AS CONDITIONAL
COMPUTATION
@BOX 10.0
END
@BOX 11.0
FAULT 0
@BOX 12.0
FAULT 3
@B1.1
BEGIN
::PREPROCESS CONDITIONAL COMPUTATION
@B1.2
{
//PREPROCESS CONDITIONAL COMPUTATION
@B2.1
1 +> IPTR;
PREPROCESS.COND();
@B2.2
IPTR++;
PREPROCESSCOND();
@B3.1
IF LBUFF[IPTR] /= DTHEN
@B3.2
if (memcmp(&LBUFF[IPTR], &DTHEN, sizeof(ITYPE)) != 0))
@B4.1
PREPROCESS.COMP(0) => OPD.TYPE;
@B4.2
OPDTYPE = PREPROCESSCOMP(0);
@B5.1
IF LBUFF[IPTR] /= DELSE
@B5.1
if (memcmp(&LBUFF[IPTR], &DELSE, sizeof(ITYPE)) != 0))
@B6.1
PREPROCESS.COMP(0) => J;
@B6.2
J = PREPROCESSCOMP(0);
@B7.1
IF LBUFF[IPTR] /= RB
@B7.2
if (memcmp(&LBUFF[IPTR], &RB, sizeof(ITYPE)) != 0))
@B8.1
IF OPD.TYPE /= J
@B8.2
if (OPDTYPE != J)
@B9.1
6 => AR[OK.AP];
@B9.2
AR[OKAP] = 6;
@B10.1
END::7.1.1.4
@B10.2
}//7.1.1.4
@B11.1
MONITOR(0);
@B11.2
MONITOR(0);
@B12.1
MONITOR(3);
@B12.2
MONITOR(3);
@END
@TITLE MSL07.1.1.5(1,6)
@COL 1S-2R-3T-4R-5F
@COL 6R
@ROW 4-6
@FLOW 1-2-3Y-4-5
@FLOW 3N-6
@BOX 1.0
PREPROCESS
SUBEXPRESSION
@BOX 2.0
PREPROCESS
COMPUTATION
@BOX 3.0
LAST ITEM
')'?
@BOX 4.0
SET OPERAND
KIND AS
SUBEXPRESSION
@BOX 5.0
END
@BOX 6.0
FAULT 0
@B1.1
BEGIN
::PREPROCESS SUBEXPRESSION
@B1.2
{
//PREPROCESS SUBEXPRESSION
@B2.1
PREPROCESS.COMP(0) => OPD.TYPE;
@B2.2
OPDTYPE = PREPROCESS.COMP(0);
@B3.1
IF LBUFF[IPTR] /= RB
@B3.2
if (memcmp(&LBUFF[IPTR], &RB, sizeof(ITYPE)) != 0))
@B4.1
5 => AR[OK.AP]
@B4.2
AR[OKAP] = 5;
@B5.1
END::7.1.1.5
@B5.2
}//7.1.1.5
@B6.1
MONITOR(0);
@B6.2
MONITOR(0);
@END
@TITLE MSL07.1.1.6(1,6)
@COL 1S-9R-2R-8R-3T-4R-5R-6F
@COL 7R
@ROW 4-7
@FLOW 1-9-2-8-3Y-4-5-6
@FLOW 3N-7
@BOX1.0
PREPROCESS
BUILT IN
FUNCTION
@BOX9.0
DATAVECTORS
@BOX2.0
PUT BUILT IN
FUNCTION NUMBER
IN AR
@BOX 8.0
SET BUILT IN FUNCTION
REGISTER USAGE IN
COMPUTATION KIND
@BOX3.0
NEXT ITEM '('?
@BOX4.0
PREPROCESS
FUNCTION
PARAMETERS
#MSL07.1.1.6.1
#MSL07.1.1.6.2
@BOX5.0
SET OPERAND KIND
AS BUILT IN FUNCTION
@BOX6.0
END
@BOX7.0
FAULT 0
@B1.1
BEGIN
::PREPROCESS BUILT IN FUNCTION
@B1.1
{
//PREPROCESS BUILT IN FUNCTION
@BOX9.1
$DA BIF.START($LO8)
0 2 6 9 13 15 16 19
END
$DA BIF.ACTIONS($LO8)
9 0       ::BYTE
2 10 7 0  ::MAKE
6 8 1     ::POSN
3 5 5 0   ::PART
4 0       ::SIZE
1         ::LLST
2 5 1     ::LPST
12 13 0   ::LENT
END
$DA BIF.REG.USE($LO8)
%60 %50 %20 %70 %60 0 %60 %60
END
@BOX9.2
uint8 BIFSTART[] = { 0, 2, 6, 9, 13, 15, 16, 19 };
uint8 BIFACTIONS[] =
{
9, 0,         //BYTE
2, 10, 7, 0,  //MAKE
6, 8, 1,      //POSN
3, 5, 5, 0,   //PART
4, 0,         //SIZE
1,            //LLST
2, 5, 1,      //LPST
12, 13, 0     //LENT
};
uint8 BIFREGUSE[] = { 0x60, 0x50, 0x20, 0x70, 0x60, 0, 0x60, 0x60 },
@B2.1
I - IBYTE => AR[AP] => U;
1 +> AP;
@B2.2
AR[AP] = I - IBYTE;
U = AR[AP];
AP++;
@BOX8.1
BIF.REG.USE[U] !> COMP.KIND;
@BOX8.2
COMPKIND |= BIFREGUSE[U];
@B3.1
IF LBUFF[1+>IPTR+1] /= LB
@B3.2
if (memcmp(&LBUFF[++IPTR+1], &LB, sizeof(ITYPE)) != 0))
@B4.1
1 +> IPTR;
#MSL07.1.1.6.1
->AROUND;
#MSL07.1.1.6.2
AROUND:
@B4.2
IPTR++;
#MSL07.1.1.6.1
goto AROUND;
#MSL07.1.1.6.2
AROUND:
@B5.1
7 => AR[OK.AP];
@B5.2
AR[OKAP] = 7;
@B6.1
END::7.1.1.6
@B6.2
}//7.1.1.6
@B7.1
MONITOR(0);
@B7.2
MONITOR(0);
@END
@TITLE MSL07.1.1.6.1(1,6)
@COL 1S-2R-3R-4C-5T-6F-7C-8R-9T-10T-11R-12C
@COL 23C-24T-25R-26C-27R-28T-29R-20R-30C-31R-21R
@COL 36C-37R-38T-34T-39C-40C-50R-41R-43C
@ROW 1-23
@ROW 3-25
@ROW 10-21
@ROW 4-26-36
@ROW 7-30-40
@FLOW 1-2-3
@FLOW 23-24Y-25-3
@FLOW 24N-20
@FLOW 4-5Y-6
@FLOW 5N-20
@FLOW 26-27-28N-29
@FLOW 28Y-5
@FLOW 36-37-38N-34Y-39
@FLOW 38Y-21
@FLOW 34N-20
@FLOW 7-8-9Y-10N-11-12
@FLOW 9N-21
@FLOW 30-31-8
@FLOW 10Y-12
@FLOW 40-50-41-43
@BOX1.0
PREPROCESS
FUNCTION
PARAMETERS
@BOX2.0
GET PARAMETER
PROCESSING DESCRIPTION
FOR THIS FUNCTION
@BOX3.0
SWITCH TO
APPROPRIATE
ACTION
@BOX4.0
ACTION 0
@BOX5.0
WAS LAST
ITEM ')'?
@BOX6.0
END
@BOX7.0
ACTION 3
@BOX8.0
PREPROCESS
COMPUTATION
@BOX9.0
IS IT OF POINTER
TO VECTOR TYPE?
@BOX10.0
IS IT ACTION 4?
@BOX11.0
SET OPERAND TYPE
@BOX12.0
NEXT
ACTION
@BOX20.0
FAULT 0
@BOX21.0
FAULT 3
@BOX23.0
NEXT
ACTION
@BOX24.0
WAS LAST
ITEM ',' OR ')'?
@BOX25.0
GET NEXT
ACTION NUMBER
@BOX26.0
ACTION 1
@BOX27.0
SET OPERAND
TYPE TO NONE
@BOX28.0
ONLY OPERAND
IN COMPUTATION?
@BOX29.0
FAULT 35
@BOX30.0
ACTION 4
@BOX31.0
SET OPERAND
TYPE AS INTEGER
@BOX36.0
ACTION 2
@BOX37.0
PROCESS TYPE AND
PLACE IN AR
@BOX38.0
NOT LPST AND
IS IT A
POINTER TYPE?
@BOX34.0
NEXT ITEM ','?
@BOX39.0
NEXT
ACTION
@BOX40.0
ACTION 5
@BOX50.0
SET POINTER IN
AR IF 'PART'
@BOX41.0
PREPROCESS
COMPUTATION
AS INTEGER
UNLESS LPST
@BOX43.0
NEXT
ACTION
@B1.1
::PREPROCESS FUNCTION PARAMETERS
@B1.2
//PREPROCESS FUNCTION PARAMETERS
@B2.1
BIF.START[U] => I;
@B2.2
I = BIFSTART[U];
@B3.1
SWITCH BIF.ACTIONS[I] => N
\ A0,A1,A2,A3,A4,A5,A6,
A7,A8,A9,A10,A11,A12,A13;
@B3.2
N = BIFACTIONS[I];
switch (N)
{
case 0: goto A0;
case 1: goto A1;
case 2: goto A2;
case 3: goto A3;
case 4: goto A4;
case 5: goto A5;
case 6: goto A6;
case 7: goto A7;
case 8: goto A8;
case 9: goto A9;
case 10: goto A10;
case 11: goto A11;
case 12: goto A12;
case 13: goto A13;
}
@B4.1
A0:
@B4.2
A0:
@B5.1
IF LBUFF[IPTR] /= RB
@B5.2
if (memcmp(&LBUFF[IPTR], &RB, sizeof(ITYPE)) != 0))
@B6.1
::END 7.1.1.6.1
@B6.2
//END 7.1.1.6.1
@B7.1
A3:
AP => F + 2 => AP;
@B7.2
A3:
F = AP;
AP = F + 2;
@B8.1
PREPROCESS.COMP(0) => RTYPE;
@B8.1
RTYPE = PREPROCESSCOMP(0);
@B9.1
IF RTYPE > %4000
OR RTYPE & 3 /= 3
@B9.2
if (RTYPE > 0x4000 || (RTYPE & 3) != 3)
@B10.1
IF N = 4
@B10.2
if (N==4)
@B11.1
RTYPE => OPD.TYPE
@B11.2
OPDTYPE = RTYPE;
@B12.1
-> NEXT.ACTION;
@B12.2
goto NEXTACTION;
@B20.1
MONITOR(0);
@B20.2
MONITOR(0);
@B21.1
MONITOR(3);
@B21.2
MONITOR(3);
@B23.1
NEXT.ACTION:
@B23.2
NEXTACTION:
@B24.1
IF LBUFF[IPTR] /= COMMA /= RB
@B24.2
IF (memcmp(&LBUFF[IPTR], &COMMA, sizeof(ITYPE)) != 0 && memcmp(&LBUFF[IPTR], &RB, sizeof(ITYPE)) != 0)
@B25.1
1 +> I;
@B25.2
I++;
@B26.1
A1:
@B26.2
A1:
@B27.1
0 => OPD.TYPE;
@B27.2
OPDTYPE = 0;
@B28.1
IF U = 5 THEN
1 +> IPTR FI
IF SINGLE.OPD /= 0
AND LBUFF[IPTR+1] = EOS
@B28.2
if (U == 5)
{
  IPTR++;
}
if (SINGLEOPD != 0 && memcmp(&LBUFF[IPTR], &EOS, sizeof(ITYPE)) == 0)
@B29.1
MONITOR(10);
@B29.2
MONITOR(10);
@B30.1
A4:
@B30.2
A4:
@B31.1
TINT => OPD.TYPE;
@B31.2
OPDTYPE = TINT;
@B36.1
A2:
@B36.2
A2:
@B37.1
COMP.TYPE() => AR[AP] => RTYPE
! 3 => OPD.TYPE;
1 +> AP;
@B37.2
AR[AP] = COMPTYPE();
RTYPE = AR[AP];
OPDTYPE = RTYPE | 3;
AP++;
@B38.1
IF U /= 6 AND
RTYPE & 3 /= 0
@B38.2
if (U != 6 && (RTYPE & 3) != 0)
@B34.1
IF LBUFF[IPTR+1] /= COMMA
@B34.2
if (memcmp(&LBUFF[IPTR+1], &COMMA, sizeof(ITYPE)) != 0)
@B39.1
1 +> IPTR;
-> NEXT.ACTION;
@B39.2
IPTR++;
goto NEXT.ACTION;
@B40.1
A5:
@B40.2
A5:
@B50.1
IF U = 3 THEN
AP => AR[F];
1 +> F;
FI
@B50.2
if (U==3)
{
  AR[F] = AP;
  F++;
}
@B41.1
AP => N;
IF U /= 6 THEN
TINT => J ELSE 0 => J FI
PREPROCESS.COMP(J) => RTYPE;
IF U = 6 THEN
%100 !> AR[N] FI
@B41.2
N = AP;
if (U != 6)
{
  J = TINT;
}
else
{
  J = 0;
}
 
RTYPE = PREPROCESSCOMP(J);
if (U == 6)
{
  AR[N] |= 0x100;
}
@B43.1
-> NEXT.ACTION;
@B43.2
goto NEXT.ACTION;
@END
@TITLE MSL07.1.1.6.2(1,8)
@COL 21N-24R-6T-22R-7T-23R-8R-9C
@COL 51S-13C-14T-15T-16T-17T-20T-18R-19C-29R
@COL 32C-33T-34R-25C-26R-27T-28C-52C-53R-54R-55C
@COL 44C-45R-47C-1C-2T-3R-4C-40C-41R-42C
@COL 5C-10C-11R-12C
@ROW 21-14
@ROW 24-17
@ROW 6-20
@ROW 13-32-44
@ROW 25-1
@ROW 3-5
@FLOW 13-14Y-15Y-16Y-17Y-20Y-18-19
@FLOW 14N-21-7
@FLOW 15N-24
@FLOW 16N-24
@FLOW 17N-6N-22
@FLOW 6Y-8-9
@FLOW 20N-7N-23
@FLOW 7Y-8
@FLOW 32-33Y-34-18
@FLOW 33N-14
@FLOW 25-26-27Y-28
@FLOW 27N-29
@FLOW 52-53-54-55
@FLOW 44-45-47
@FLOW 1-2Y-3-4
@FLOW 2N-5
@FLOW 40-41-42
@FLOW 10-11-12
@BOX 24.0
FAULT 2
@BOX 6.0
MAKE?
@BOX 22.0
FAULT 7
@BOX7.0
MAKE?
@BOX23.0
FAULT 0
@BOX8.0
SET BYTE ADDR
TYPE MAKE
@BOX 9.0
ACTION 8
@BOX 13.0
ACTION 6
@BOX 14.0
NEXT ITEM
A NAME?
@BOX 15.0
IS THERE A
CORRESPONDING
MUTL NAME?
@BOX 16.0
IN SCOPE?
@BOX 17.0
SPACE NAME?
@BOX 20.0
NEXT ITEM
',' OR ')' ?
@BOX 18.0
COPY NAME TO AR
@BOX 19.0
NEXT
ACTION
@BOX 29.0
FAULT 3
@BOX 32.0
ACTION 7
@BOX 33.0
WAS LAST
ITEM ')'?
@BOX 34.0
SET NAME
TO ZERO
@BOX25.0
ACTION 9
@BOX 26.0
PREPROCESS
COMPUTATION
@BOX27.0
IS IT OF
POINTER TYPE?
@BOX28.0
NEXT
ACTION
@BOX52.0
ACTION 11
@BOX53.0
SET OPERAND
TYPE AS INTEGER
@BOX54.0
INCREMENT IPTR
@BOX55.0
NEXT
ACTION
@BOX 44.0
ACTION 8
@BOX 45.0
PREPROCESS
COMPUTATION
AS BYTE
ADDRESS TYPE
@BOX 47.0
NEXT
ACTION
@BOX 51.0
PREPROCESS
FUNCTION
PARAMETERS
(CONTINUED)
@BOX1.0
ACTION 10
@BOX 2.0
NEXT TWO ITEMS
CONST 0 AND ',' ?
@BOX3.0
SET SCALAR
MAKE REQUIRED
@BOX4.0
NEXT
ACTION
@BOX5.0
ACTION 5
@BOX40.0
ACTION 12
@BOX41.0
PREPROCESS
COMPUTATION
AS LOGICAL32
TYPE
@BOX42.0
NEXT
ACTION
@BOX10.0
ACTION 13
@BOX11.0
PROCESS 0 OR
TYPE AND SET
IN OPERAND
TYPE
INCREMENT IPTR
@BOX12.0
NEXT
ACTION
@B13.1
A6:
@B13.2
A6:
@B14.1
IF TAG OF LBUFF[IPTR+1] /= TNAME
@B14.2
if (LBUFF[IPTR+1].TAG != TNAME)
@B15.1
IND OF LBUFF[IPTR+1] => MSLN;
IF MUTLN(MSLN) => MTLN = 0
@B15.2
MSLN = LBUFF[IPTR+1].IND;
V = MUTLN(MSLN);
if (MTLN == 0)
@B16.1
IF MTLN < CURLEV >= GLEV
@B16.2
if (MTLN < CURLEV  && CURLEV >= GLEV)
@B17.1
IF K OF PLIST[MTLN] /= KSPACE
@B17.2
if (PLIST[MTLN].K != KSPACE)
@B20.1
IF LBUFF[2 +> IPTR]
/= COMMA /= RB
@B20.2
IPTR += 2;
if (LBUFF[IPTR] != COMMA && LBUFF[IPTR] != RB)
@B18.1
MTLN => AR[AP];
1 +> AP;
@B18.2
AR[AP] = MTLN;
AP++;
@B19.1
-> NEXT.ACTION;
@B19.2
goto NEXTACTION;
@B24.1
MONITOR(2);
@B24.2
MONITOR(2);
@B6.1
IF U = 1
@B6.2
if (U == 1)
@B22.1
MONITOR(7);
@B22.2
MONITOR(7);
@B7.1
IF U = 1
@B7.2
if (U == 1)
@B23.1
MONITOR(0);
@B23.2
MONITOR(0);
@B8.1
%40 !> AR[OK.AP+1];
@B8.2
AR[OKAP+1] |= 0x40;
@B9.1
->A8;
@B9.2
goto A8;
@B32.1
A7:
@B32.2
A7:
@B29.1
MONITOR(3);
@B29.2
MONITOR(3);
@B33.1
IF LBUFF[IPTR] /= RB
@B33.2
if (LBUFF[IPTR] != RB)
@B34.1
0 => MTLN;
@B34.2
MTLN = 0;
@B25.1
A9:
@B25.2
A9:
@B26.1
PREPROCESS.COMP(0) => RTYPE;
TBYADDR => OPD.TYPE;
@B26.2
RTYPE = PREPROCESSCOMP(0);
OPDTYPE = TBYADDR;
@B27.1
IF RTYPE & 3 = 0
AND RTYPE /= TADPROC
AND RTYPE /= TLAB
@B27.2
if ((RTYPE & 3) == 0 && RTYPE != TADPROC && RTYPE != TLAB)
@B28.1
->NEXT.ACTION;
@B28.2
goto NEXTACTION;
@BOX52.1
A11:
@BOX52.2
A11:
@BOX53.1
TINT => OPD.TYPE;
@BOX53.2
OPDTYPE = TINT;
@BOX54.1
1+>IPTR;
@BOX54.2
IPTR++;
@BOX55.1
->NEXT.ACTION;
@BOX55.2
goto NEXTACTION;
@B44.1
A8:
@B44.2
A8:
@B45.1
PREPROCESS.COMP(TBYADDR);
@B45.2
PREPROCESSCOMP(TBYADDR);
@B47.1
-> NEXT.ACTION;
@B47.2
goto NEXTACTION;
@BOX1.1
A10:
@BOX1.2
A10:
@BOX2.1
IF TAG OF LBUFF[IPTR+1] /= TCONST
OR ST OF LBUFF[IPTR+1] /= TLO8
OR CLIST[IND OF LBUFF[IPTR+1]] /= 0
OR LBUFF[IPTR+2] /= COMMA
@BOX2.2
if (LBUFF[IPTR+1].TAG != TCONST || LBUFF[IPTR+1].ST != TLO8 || CLIST[LBUFF[IPTR+1].IND] != 0 || memcmp(&LBUFF[IPTR+2], &COMMA, sizeof(ITYPE)) != 0)
@BOX3.1
2 +> IPTR;
%80 !> AR[OK.AP+1];
%FFFD &> OPD.TYPE;
@BOX3.2
IPTR += 2;
AR[OKAP+1] |= 0x80;
OPDTYPE &= 0xFFFD;
@BOX4.1
->NEXT.ACTION;
@BOX4.2
goto NEXTACTION;
@BOX5.1
->A5;
@BOX5.2
goto A5;
@B40.1
A12:
@B40.2
A12:
@B41.1
PREPROCESS.COMP(TLO32);
@B41.2
PREPROCESSCOMP(TLO32);
@B42.1
->NEXT.ACTION;
@B42.2
goto NEXTACTION;
@BOX10.1
A13:
@BOX10.2
A13:
@BOX11.1
IF TAG OF LBUFF[IPTR+1] /= TCONST
OR ST OF LBUFF[IPTR+1] /= TLO8
OR CLIST[IND OF LBUFF[IPTR+1]] /= 0 THEN
COMP.TYPE() => OPD.TYPE;
1 +> IPTR;
ELSE
0 => OPD.TYPE;
2 +> IPTR;
FI
@BOX11.2
if (LBUFF[IPTR+1].TAG != TCONST || LBUFF[IPTR+1].ST != TLO8 || CLIST[LBUFF[IPTR+1].IND] != 0)
{
  OPDTYPE = COMPTYPE();
  IPTR++;
}
else
{
  OPDTYPE = 0;
  IPTR += 2;
}
@BOX12.1
->NEXT.ACTION;
@BOX12.2
goto NEXTACTION;
@END
@TITLE MSL07.1.1.7(1,6)
@COL 1S-2R-3R-4R-5R-6F
@FLOW 1-2-3-4-5-6
@B1
PREPROCESS STRING
@B2
GENERATE DATA VECTOR
FOR CHARACTERS OF STRING
NOTE MUTL NAME
@B3
SET OPERAND KIND
AS STRING
@B4
PUT MUTL NAME OF
STRING DATAVEC IN AR
@B5
SET OPERAND TYPE
AS ADDR[LO8]
@B6
END
@B1.1
BEGIN
::PREPROCESS STRING
@B1.2
{
//PREPROCESS STRING
@B2.1
IND OF LBUFF[1+>IPTR] => I;
TL.S.DECL(NIL,TLO8,-1);
DUMMY() => MTLN;
TL.ASS(MTLN,-1);
-1 => N;
WHILE CLIST[1 +> N + I] /= 0 DO OD
TL.C.LIT.S(TLO8,PART(^CLIST,I,I + N -1));
TL.ASS.VALUE(0,1);
TL.ASS.END();
@B2.2
I = LBUFF[++IPTR].IND;
TLSDECL(NIL,TLO8,-1);
MTLN = DUMMY();
TLASS(MTLN,-1);
N = -1;
while (CLIST[++N + I] != 0) {}
TLCLITS(TLO8,PART(CLIST,I,I + N -1));
TLASSVALUE(0,1);
TLASSEND();
@B3.1
8 => AR[OK.AP];
@B3.2
AR[OKAP] = 8;
@B4.1
MTLN => AR[AP];
1+>AP;
@B4.2
AR[AP] = MTLN;
AP++;
@B5.1
STRING.TYPE => OPD.TYPE;
@B5.2
OPDTYPE = STRINGTYPE;
@B6.1
END::7.1.1.7
@B6.2
}//7.1.1.7
@END
@TITLE MSL07.2(1,6)
@COL 10R
@COL 1S-2R-3R-4R-5R-6T-7T-9F
@COL 11R
@ROW 7-11
@ROW 10-9
@FLOW 1-2-3-4-5-6N-7N-9
@FLOW 6Y-11-5
@FLOW 7Y-10-4
@BOX 1.0
PREPROCESS.COND
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
CLEAR COUNT OF
'OR'S IN AR
@BOX 4.0
CLEAR COUNT OF
'AND'S IN AR
FOR NEXT AND CLAUSE
@BOX 5.0
PREPROCESS TEST
#MSL07.2.1
@BOX 6.0
WAS LAST ITEM
'AND'?
@BOX 7.0
WAS IT
'OR'?
@BOX 9.0
EXIT
@BOX 10.0
INCREMENT COUNT
OF 'OR'S IN AR
@BOX 11.0
INCREMENT COUNT
OF 'AND'S IN AR
@B1.1
$PR PREPROCESS.COND;
@B1.2
void PREPROCESSCOND(void)
{
@B2.1
::DECL & INIT
$IN OR.AP, AND.AP, TEST.AP;
$IN CTYPE,RHS.TYPE;
@B2.2
//DECL & INIT
int ORAP, ANDAP, TESTAP;
int CTYPE,RHSTYPE;
@B3.1
0 => AR[AP => OR.AP];
1 +> AP;
@B3.2
ORAP = AP;
AR[AP] = 0;
AP++;
@B4.1
0 => AR[AP => AND.AP];
1 +> AP;
@B4.2
ANDAP = AP;
AR[AP] = 0;
AP++;
@B5.1
#MSL07.2.1
@B5.2
#MSL07.2.1
@B6.1
IF LBUFF[IPTR] = DAND
@B6.2
if (memcmp(&LBUFF[IPTR], &DAND, sizeof(ITYPE)) == 0)
@B7.1
IF LBUFF[IPTR] = DOR
@B7.2
if (memcmp(&LBUFF[IPTR], &DOR, sizeof(ITYPE)) == 0)
@B9.1
END
@B9.2
}
@B10.1
1 +> AR[OR.AP];
@B10.2
AR[ORAP]++;
@B11.1
1 +> AR[AND.AP];
@B11.1
AR[ANDAP]++;
@END
@TITLE MSL07.2.1(1,6)
@COL 17R
@COL 1S-2R-3T-4R-5R-6T-7R-8R-9T-10R-11R-12T-13R-14T-15F
@COL 18R-19R-20T-21T-23R
@COL 24R
@ROW 4-18
@ROW 23-24
@ROW 17-15
@FLOW 1-2-3N-4-5-6Y-7-8-9N-10-11-12N-13-14Y-15
@FLOW 3Y-18-19-20Y-21Y-23-14
@FLOW 20N-24
@FLOW 6N-17
@FLOW 9Y-11
@FLOW 12Y-7
@FLOW 14N-17
@FLOW 21N-24
@BOX 1.0
PREPROCESS TEST
@BOX 2.0
CLEAR TEST KIND
(RHS COUNT) IN AR
@BOX 3.0
NEXT ITEM '['?
@BOX 4.0
CLEAR TYPE FOR
COMPARISONS IN AR
@BOX 5.0
PREPROCESS LHS
EXPRESSION
MARK AR AS
COMPARISON EXPRESSION
@BOX 6.0
WAS LAST ITEM
A COMPARATOR
@BOX 7.0
PREPROCESS NEXT
RHS EXPRESSION
MARK AR AS
COMPARISON EXPRESSION
@BOX 8.0
INCREMENT RHS
COUNT IN AR
UPDATE TEST INFO
@BOX 9.0
FIRST RHS
@BOX 10.0
CHECK RHS
COMPATABILITY
@BOX 11.0
CHECK RHS TYPE
& NOTE LARGEST
@BOX 12.0
WAS LAST ITEM
A COMPARATOR?
@BOX 13.0
SET TYPE FOR
COMPARISON IN AR
@BOX 14.0
WAS LAST ITEM
A TEST TERMINATOR?
@BOX 15.0
END
@BOX 17.0
FAULT 0
@BOX 18.0
NOTE TEST TYPE IS
[<CONDITION>] IN AR
@BOX 19.0
PREPROCESS
CONDITION
@BOX 20.0
LAST ITEM
']'?
@BOX 21.0
NEXT ITEM
A DELIMITER
@BOX 23.0
COPY INTO
AR
@BOX 24.0
FAULT 0
@B1.1
BEGIN
::PREPROCESS.TEST
$IN I;
@B1.2
{
//PREPROCESS.TEST
int I;
@B2.1
0 => AR[AP => TEST.AP];
1 +> AP;
@B2.2
TESTAP = AP;
AR[AP] = 0;
AP++;
@B3.1
IF LBUFF[IPTR+1] = LSB
@B3.2
if (memcmp(&LBUFF[IPTR+1], &LSB, sizeof(ITYPE)) == 0)
@B4.1
::0 => AR[AP];
1 +> AP;
@B4.2
//0 => AR[AP];
AP++;
@B5.1
PREPROCESS.COMP(0) => CTYPE;
%100 !> AR[TEST.AP+2];
@B5.2
CTYPE = PREPROCESSCOMP(0);
AR[TESTAP+2] |= 0x100;
@B6.1
IF DLIST[IND OF LBUFF[IPTR]] & %8 = 0
@B6.2
if ((DLIST[LBUFF[IPTR].IND] & 0x8) == 0)
@B7.1
AP => I;
PREPROCESS.COMP(0) => RHS.TYPE;
%100 !> AR[I];
@B7.2
I = AP;
RHSTYPE = PREPROCESS.COMP(0);
AR[I] |= 0x100;
@B8.1
1 +> AR[TEST.AP];
@B8.2
AR[TESTAP]++;
@B9.1
IF AR[TEST.AP] = 1
@B9.2
if (AR[TESTAP] == 1)
@B10.1
IF CHECK.TYPE(0,CTYPE,RHS.TYPE) /= CTYPE THEN
CAPTION(%"MSL07.2.1 BOX 10!0A!");
MONITOR(3);
FI
@B10.2
if (CHECKTYPE(0,CTYPE,RHSTYPE) != CTYPE)
{
  CAPTION("MSL07.2.1 BOX 10!0A!");
  MONITOR(3);
}
@B11.1
CHECK.TYPE(0,CTYPE,RHS.TYPE) => CTYPE;
@B11.2
CTYPE = CHECKTYPE(0,CTYPE,RHSTYPE);
@B12.1
IF DLIST[IND OF LBUFF[IPTR]] & %8 /= 0
@B12.2
if ((DLIST[LBUFF[IPTR].IND] & 0x8) != 0)
@B13.1
CTYPE => AR[TEST.AP+1];
@B13.2
AR[TESTAP+1] = CTYPE;
@B14.1
IF DLIST[IND OF LBUFF[IPTR]] & %1 = 0
@B14.2
if ((DLIST[LBUFF[IPTR].IND] & 0x1) == 0)
@B15.1
END::7.2.1
@B15.2
}//7.2.1
@B17.1
MONITOR(0);
@B17.2
MONITOR(0);
@B18.1
1 +> IPTR;
::DONE IN BOX 2
@B18.2
IPTR++;
//DONE IN BOX 2
@B19.1
PREPROCESS.COND();
@B19.2
PREPROCESSCOND();
@B20.1
IF LBUFF[IPTR] /= RSB
@B20.2
if (memcmp(&LBUFF[IPTR], &RSB, sizeof(ITYPE)) != 0)
@B21.1
IF TAG OF LBUFF[IPTR+1] /= TDELIM
@B21.2
if (LBUFF[IPTR+1].TAG != TDELIM)
@B23.1
IND OF LBUFF[1+>IPTR] => AR[AP];
1 +> AP;
@B23.2
AR[AP] = LBUFF[++IPTR].IND;
AP++;
@B24.1
MONITOR(0);
@B24.2
MONITOR(0);
@END
@TITLE MSL07.3(1,6)
@COL 15C-16C-17R
@COL 1S-2R-3R-4R-6R-7R-8T-9R-10T-11T-12R-13R-14F
@ROW 15-6
@ROW 16-8
@ROW 17-11
@FLOW 1-2-3-4-6-7-8Y-9-10N-11Y-12-13-14
@FLOW 15-7
@FLOW 16-10
@FLOW 10Y-17-10
@FLOW 11N-6
@FLOW 8N-10
@BOX 1.0
COMPILE.COMP(INIT.OP,REQD.TYPE)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
CLEAR REF AND
NEGATIVE LOAD
@BOX 4.0
STACK REGISTERS
IN NECESSARY ETC
#MSL07.3.1
@BOX 6.0
PROCESS
OPERAND
#MSL07.3.2
@BOX 7.0
PLANT OP
#MSL07.3.3
@BOX 8.0
LOAD OPERATOR?
@BOX 9.0
SET REGISTER
IN USE
@BOX 10.0
NEXT ITEM IN
AR => OPERATOR
A CONVERSION?
@BOX 11.0
IS IT A
TERMINATOR?
@BOX 12.0
RECOVER A/B/D
IF STACKED
INITIALLY
@BOX 13.0
SET RESULT
TO FINAL
COMP TYPE
@BOX 14.0
EXIT
@BOX 15.0
PLANT
OP.OPD
@BOX 16.0
OP.OPD
DONE
@BOX 17.0
PLANT
CONVERSION
#MSL07.3.4
@B1.1
$PR COMPILE.COMP(INIT.OP,REQD.TYPE);
@B2.1
:: DECL & INIT
$IN CMP.TYPE,OPD.TYPE,OP,REFR,REG,NLOAD,
STACKED.REGS,CMP.KIND,OPD.KIND,OK,I,J,L,OPD,FN,PT;
@B3.1
0 => REFR => NLOAD;
@B4.1
#MSL07.3.1
@B6.1
#MSL07.3.2
@B7.1
#MSL07.3.3
@B8.1
IF OP /= ILOAD
@B9.1
REG !> REGS.IU;
@B10.1
IF AR[AP] => OP & %8000 /= 0
@B11.1
1 +> AP;
IF DLIST[OP] & %800 = 0
@B12.1
IF STACKED.REGS /=0 THEN
UNSTACK.REGS(STACKED.REGS)
FI
@B13.1
CMP.TYPE => COMPILE.COMP;
REG => LAST.REG;
@B14.1
END
@B15.1
PLANT.OP.OPD:
@BOX 16.1
OP.OPD.DONE:
@B17.1
1 +> AP;
#MSL07.3.4
@END
@TITLE MSL07.3.1(1,6)
@COL 14R-19R
@COL 1S-2T-3T-4R-5R-6R-17T-18R-7T-8R-9T-10R-13F
@COL 15R-16R
@ROW 14-4-15
@ROW 19-18
@FLOW 1-2Y-3N-4-5-6-17N-18-7Y-8-9Y-10-13
@FLOW 2N-14-5
@FLOW 3Y-15-16-6
@FLOW 17Y-19-13
@FLOW 7N-9
@FLOW 9N-13
@BOX 1.0
STACK REGISTERS
IF NECESSARY ETC
@BOX 2.0
REQD.TYPE SET?
@BOX 3.0
B REQD?
@BOX 4.0
SET COMP TYPE
FROM REQD.TYPE
@BOX 5.0
GET REGISTER
FROM COMP TYPE
@BOX 6.0
SET COMP KIND
FROM AR
@BOX 17.0
INIT.OP SET?
@BOX 18.0
SET OPERATOR AS LOAD
@BOX 7.0
REGISTER
IN USE?
@BOX 8.0
STACK IT
@BOX 9.0
DOES COMPUTATION
DESTROY A/B/D & ARE
THEY IN USE?
@BOX 10.0
STACK A/B/D
@BOX 13.0
END
@BOX 14.0
SET COMP TYPE
FROM AR
@BOX19.0
SET OPERATOR
FROM INIT.OP
@BOX 15.0
SET COMP TYPE
FROM AR
@BOX 16.0
SET REGISTER
AS B
@B1.1
BEGIN
::STACK REGISTERS
::IF NECESSARY ETC
@B2.1
IF REQD.TYPE = 0
@B3.1
IF REQD.TYPE = B.REQD
@B4.1
REQD.TYPE => CMP.TYPE;
@B5.1
REG.FROM.TYPE(CMP.TYPE,AR[AP] & %180 -= %80) => REG;
@B6.1
AR[AP] => CMP.KIND;
2 +> AP;
@B17.1
IF INIT.OP /= 0
@B18.1
ILOAD => OP;
@B7.1
IF REGS.IU & REG = 0
@B8.1
STACK.REGS(REG);
@B9.1
IF CMP.KIND ->> 4 & A.B.D & REGS.IU => STACKED.REGS = 0
@B10.1
STACK.REGS(STACKED.REGS);
@B13.1
END::7.3.1
@B14.1
AR[AP+1] & %7FFF => CMP.TYPE;
@B19.1
INIT.OP => OP;
0 => STACKED.REGS;
@B15.1
AR[AP+1] & %7FFF => CMP.TYPE;
@B16.1
BREG => REG;
@END
@TITLE MSL07.3.2(1,6)
@COL 8R-9R-10R-11R
@COL 1S-2R-3R-4R-5R-6R-7F
@COL 12R-13R-14R-15R
@ROW 8-3-12
@ROW 10-5-14
@FLOW 1-2
@FLOW 3-4-7
@FLOW 5-6-7
@FLOW 8-9-7
@FLOW 10-11-7
@FLOW 12-13-7
@FLOW 14-15-7
@BOX 1.0
PROCESS
OPERAND
@BOX 2.0
SWITCH ON KIND OF
OPERAND IN AR
@BOX 3.0
KIND 1
KIND 2
@BOX 4.0
LITERALS
#MSL07.3.2.2
@BOX 5.0
KIND 7
@BOX 6.0
BUILT IN
FUNCTIONS
#MSL07.3.2.5
@BOX 7.0
END
@BOX 8.0
KIND 0
@BOX 9.0
NAMED ITEM
#MSL07.3.2.1
@BOX 10.0
KIND 5
KIND 6
@BOX 11.0
SUBEXPRESSION &
CONDITIONAL
COMPUTATIONS
#MSL07.3.2.4
@BOX 12.0
KIND 3
KIND 4
KIND 9
@BOX 13.0
PROCEDURE CALLS
#MSL07.3.2.3
@BOX 14.0
KIND 8
@BOX 15.0
STRINGS
#MSL07.3.2.6
@B1.1
:: PROCESS OPERAND
@B2.1
AR[AP] => OPD.KIND & %F => OK;
1 +> AP;
SWITCH OK \ K0,K1,K2,K3,K4,K5,K6,K7,K8,K9;
@B3.1
K1:
K2:
@B4.1
#MSL07.3.2.2
@B5.1
K7:
@B6.1
#MSL07.3.2.5
@B7.1
::END 7.3.2
@B8.1
K0:
@B9.1
#MSL07.3.2.1
@B10.1
K5:
K6:
@B11.1
#MSL07.3.2.4
@B12.1
K3:
K4:
K9:
@B13.1
#MSL07.3.2.3
@B14.1
K8:
@B15.1
#MSL07.3.2.6
@END
@TITLE MSL07.3.2.1(1,6)
@COL 12R
@COL 1S-2T-3R-4R-5T-13R-11T-6T-7R-8R-9R-10F
@ROW 12-7
@FLOW 1-2Y-3-4-5N-13-11N-6Y-7-8-9-10
@FLOW 2N-4
@FLOW 5Y-10
@FLOW 11Y-12-8
@FLOW 6N-9
@BOX 1.0
NAMED ITEM
@BOX 2.0
IN B/D AND
OPERAND USES B/D
AND ALSO IN USE?
@BOX 3.0
STACK B/D
@BOX 4.0
SET REF FROM
OPERAND KIND IN AR
@BOX 5.0
SET OPD AS MUTLN
FROM AR
IS IT SPECIAL NAME?
@BOX13.0
GET OPERAND TYPE
@BOX 11.0
IS IT A FIELD?
@BOX6.0
AGGREGATE?
@BOX 7.0
TL
D = OPD
@BOX 8.0
SET OPD AS D[]
@BOX 9.0
PROCESS OPERAND
QUALIFICATIONS
#MSL07.3.2.1.1
@BOX12.0
TL
D = OPD
@BOX 10.0
END
@B1.1
BEGIN
:: NAMED ITEM
@B2.1
IF OPD.KIND ->> 4 & B.D & REGS.IU => I = 0
@B3.1
STACK.REGS(I)
@B4.1
OPD.KIND & REF.BIT => REFR;
@B5.1
AR[AP] => OPD;
1 +> AP;
IF OPD > %1000
@BOX13.1
T OF PLIST[OPD] => OPD.TYPE;
@B11.1
IF K OF PLIST[OPD] = KFIELD
@BOX6.1
IF OPD.TYPE < %100
OR OPD.TYPE & 3 /= 0
OR OPD.TYPE & %C000 /= 0
@B7.1
TL.PL(%61,OPD);
@B8.1
DIND => OPD;
@B9.1
#MSL07.3.2.1.1
@B10.1
END::7.3.2.1
@BOX12.1
TL.PL(%62,OPD);
@END
@TITLE MSL07.3.2.1.1(1,,6)
@COL 7R-8R
@COL 1S-2T-3T-20T-4T-5T-6F
@COL 9R-10R-11T-12R-13R-14T-15R-16R-17R
@COL 18R-19R
@ROW 3-9
@ROW 7-5
@ROW 15-18
@FLOW 1-2N-3N-20N-4N-5N-6
@FLOW 2Y-9-10-2
@FLOW 3Y-11Y-12-13-14Y-15-16-17-2
@FLOW 20Y-6
@FLOW 4Y-7-2
@FLOW 5Y-8-2
@FLOW 11N-13
@FLOW 14N-18-19-16
@BOX 1.0
PROCESS OPERAND
QUALIFICATIONS
@BOX 2.0
DOES AR CONTAIN
DEREFERENCE?
@BOX 3.0
DOES AR CONTAIN
SUBSCRIPT?
@BOX 20.0
DOES AR CONTAIN
CONVERSION?
@BOX 4.0
DOES AR CONTAIN
UNION SELECTION?
@BOX 5.0
DOES AR CONTAIN
FIELD SELECTION?
@BOX 6.0
END
@BOX 7.0
TL
SEL ALT
@BOX 8.0
TL
SEL FIELD
@BOX 9.0
TL
D = OPD
@BOX 10.0
SET OPD AS D[]
@BOX 11.0
OPD D[]?
@BOX 12.0
SET D IN USE
SET D.TYPE FROM AR
@BOX 13.0
COMPILE SUBSCRIPT
COMPUTATION
@BOX 14.0
OPD D[]?
@BOX 15.0
SET D NOT IN USE
@BOX 16.0
TL
SEL EL
@BOX 17.0
SET B NOT IN USE
@BOX 18.0
TL
D = REF OPD
@BOX 19.0
SET OPD AS D[]
@B1.1
BEGIN
::PROCESS OPERAND QUALIFICATIONS
@B2.1
IF AR[AP] => I = %7F
@B3.1
IF I = %7E
@B20.1
IF I & %8000 /= 0
@B4.1
IF I >= %C0
@B5.1
IF I >= %80
@B6.1
END::7.3.2.1.1
@B7.1
1 +> AP;
TL.PL(%65,I&%3F);
@B8.1
1 +> AP;
TL.PL(%63,I&%7F);
@B9.1
1 +> AP;
TL.PL(%62,OPD);
@B10.1
DIND => OPD;
@B11.1
2 +> AP;
IF OPD /= DIND
@B12.1
DREG !> REGS.IU;
AR[AP-1] => D.TYPE;
@B13.1
COMPILE.COMP(0,B.REQD);
@B14.1
IF OPD /= DIND
@B15.1
DREG -=> REGS.IU;
@B16.1
TL.PL(%64,0);
@B17.1
BREG -=> REGS.IU;
@B18.1
TL.PL(%61,OPD);
@B19.1
DIND => OPD;
@END
@TITLE MSL07.3.2.2(1,6)
@COL 1S-2R-3T-4R-5R-6F
@COL 7R
@ROW 4-7
@FLOW 1-2-3N-4-5-6
@FLOW 3Y-7-4
@BOX1.0
LITERALS
@BOX2.0
GET TYPE OF
LITERAL FROM AR
@BOX3.0
NEGATED LITERAL
REQUIRED?
@BOX4.0
SET TL CURRENT
LITERAL TO
REQUIRED VALUE
@BOX5.0
SET OPD AS
CURRENT LITERAL
@BOX6.0
END
@BOX7.0
SET FOR
NEGATIVE LOAD
@BOX1.1
BEGIN
::LITERALS
@BOX2.1
OPD.KIND ->> 4 => OPD.TYPE;
@BOX3.1
IF OK = 2
@BOX4.1
::TEMP MOD
$IN DMI,DMJ;AR[AP]=>DMI;OPD.TYPE->>2&%F+DMI=>DMJ;
TL.C.LIT.S(OPD.TYPE,PART(^CLIST,DMI,DMJ));
1 +> AP;
@BOX5.1
CLIT => OPD;
@BOX6.1
END::7.3.2.2
@BOX7.1
-1 => NLOAD;
@END
@TITLE MSL07.3.2.3(1,10)
@COL 17R-12R
@COL 1S-2T-3R-16T-5R-6R-7R-8T-18R-9T-10R-11C
@COL 13R-14R-15R
@ROW 17-5
@ROW 18-14
@ROW 12-10
@FLOW 1-2N-3-16N-5-6-7-8Y-18-9N-10-11
@FLOW 2Y-16
@FLOW 16Y-17-6
@FLOW 8N-14-15-8
@FLOW 9Y-12-10
@BOX 1.0
PROCEDURE CALLS
@BOX 2.0
LOAD OPERATOR?
@BOX 3.0
STACK CURRENT
REGISTER
@BOX 16.0
CALL BY PROC
VARIABLE?
@BOX 5.0
GET MUTLN OF
PROC FROM AR
SET OPD AS MUTLN
@BOX 6.0
TL
STKL OPD
@BOX 7.0
GET RESULT TYPE
& NO OF PARAMETERS
FROM AR
@BOX 8.0
ALL PARAMETERS
PROCESSED?
@BOX18.0
TL ENTER
@BOX 9.0
IN B REGISTER?
@BOX 10.0
SET CURRENT
REGISTER IN USE
@BOX 11.0
REVERSE
OP
@BOX 17.0
GET MUTLN OF PROC
VARIABLE FROM AR
SET OPD FROM
ASSOCIATED PSPEC
SET OPERAND FOR
ENTER TO MUTLN
@BOX 12.0
CONVERT A REGISTER
IF NECESARY
TL
BMODE = COMP TYPE
B = A
@BOX 14.0
COMPILE
PARAMETER
COMPUTATION
@BOX15.0
TL STACK PARAM
SET REGISTER
NOT IN USE
@BOX1.1
::PROCEDURE CALLS
@BOX2.1
IF OP = ILOAD
@BOX3.1
STACK.REGS(REG);
@BOX16.1
0 => L;
IF OK = 9
@BOX5.1
AR[AP] => OPD;
@BOX6.1
1 +> AP;
TL.PL(%40,OPD);
@BOX7.1
AR[AP] => OPD.TYPE;
AR[AP+1] => I;
2 +> AP;
@BOX8.1
IF 1->I >= 0
@BOX18.1
IF OK = 9 AND K OF PLIST[L] = KFIELD THEN
TL.PL(%62,L);
DIND => L;
FI
TL.PL(%42,L);
@BOX9.1
IF REG = BREG
@BOX10.1
REG !> REGS.IU;
@BOX11.1
->REVERSE.OP;
@BOX17.1
AR[AP] => L;
T OF PLIST[L] & %3FFF => OPD;
@BOX12.1
IF OPD.TYPE /= CMP.TYPE THEN
TL.PL(%45,CMP.TYPE) FI
TL.PL(%56,CMP.TYPE);
TL.PL(%02,AOPD);
@BOX14.1
COMPILE.COMP(0,0) => PT;
@BOX15.1
TL.PL(%41,AOPD);
0 => REGS.IU;
@END
@TITLE MSL07.3.2.4(1,10)
@COL 14C-16T-17R
@COL 1S-2T-3T-4R-5T-6T-7R-8R-9R-10C
@COL 11R-12R-13R-15C
@ROW 3-11
@ROW 14-4
@ROW 6-13
@ROW 16-7
@FLOW 1-2N-3N-4-5N-6Y-7-8-9-10
@FLOW 2Y-11
@FLOW 3Y-12-5
@FLOW 14-5
@FLOW 5Y-13-15
@FLOW 6N-16Y-17-8
@FLOW 16N-8
@BOX1.0
SUBEXPRESSIONS &
CONDITIONAL
COMPUTATIONS
@BOX2.0
IN D REG?
@BOX3.0
CONDITIONAL
COMPUTATION
@BOX4.0
COMPILE SUBEXPRESSION
(IN B IF REQD.TYPE.SET)
@BOX5.0
LOAD OPERATOR?
@BOX6.0
IN A REG?
@BOX7.0
CONVERT A
IF NECESSARY
@BOX8.0
CONVERT OPERATOR
TO REVERSE OPERATOR
@BOX9.0
SET OPERAND
AS STACK
DELETE ENTRY ON
STACK.TYPE VECTOR
@BOX10.0
PLANT
OP.OPD
@BOX 14.0
REVERSE
OP
@BOX16.0
IN B REG ?
@BOX17.0
CONVERT B
IF NECESSARY
@BOX11.0
FAULT 4
@BOX12.0
COMPILE
CONDITIONAL
COMPUTATION
#MSL07.3.2.4.1
@BOX13.0
SET A.TYPE,B.TYPE
OR D.TYPE IF
IN A, B OR D
CONVERTING A
IF NECESSARY
@BOX15.0
OP.OPD
DONE
@BOX1.1
::SUBEXPRESSIONS &
::CONDITIONAL
::COMPUTATIONS
@BOX2.1
IF REG = DREG
@BOX3.1
IF OK=6
@BOX4.1
IF REQD.TYPE = B.REQD THEN
B.REQD => I
ELSE
0 => I
FI
COMPILE.COMP(0,I) => OPD.TYPE;
@BOX5.1
IF OP = ILOAD
@BOX6.1
IF REG /= AREG
@BOX7.1
IF OPD.TYPE /= CMP.TYPE THEN
TL.PL(%45,CMP.TYPE);
FI
@BOX8.1
REV.OP[OP-ILOAD] => OP;
@BOX9.1
UNSTK => OPD;
1 -> ST.PTR;
@BOX10.1
->PLANT.OP.OPD;
@BOX14.1
REVERSE.OP:
@BOX16.1
IF REG /= BREG
@BOX17.1
IF OPD.TYPE /= CMP.TYPE THEN
TL.PL(%55,CMP.TYPE) FI
@BOX11.1
MONITOR(4);
@BOX12.1
#MSL07.3.2.4.1
@BOX13.1
IF REG = AREG THEN
IF CMP.TYPE => A.TYPE /= OPD.TYPE THEN
TL.PL(%45,CMP.TYPE) FI
ELSE IF REG = BREG THEN
CMP.TYPE => B.TYPE;
ELSE IF REG = DREG THEN
CMP.TYPE => D.TYPE
FI FI FI
@BOX15.1
->OP.OPD.DONE;
@END

@TITLE MSL07.3.2.4.1(1,7)
@COL 1S-2T-11R-3R-4R-5R-6R-7R-8R-9R-10F
@FLOW 1-2N-11-3-4-5-6-7-8-9-10
@FLOW 2Y-3
@BOX 1.0
COMPILE
CONDITIONAL
COMPUTATION
@BOX 2.0
LOAD OPERATOR?
@BOX 11.0
STACK CURRENT
REGISTER
@BOX 3.0
GENERATE & SPECIFY
TO TL LABELS
ON AND AFTER
ELSE CLAUSE
@BOX 4.0
COMPILE CONDITION AS
UNLESS CONDITION,
-> ELSE CLAUSE
@BOX 5.0
COMPILE THEN CLAUSE
(IN B IF REQD.TYPE SET)
@BOX 6.0
SET REGISTER NOT IN USE
@BOX 7.0
PLANT JUMP ROUND
ELSE CLAUSE
DECLARE LABEL ON
ELSE CLAUSE
@BOX 8.0
COMPILE ELSE CLAUSE
(IN B IF REQD.TYPE SET)
@BOX 9.0
DECLARE LABEL AFTER
ELSE CLAUSE
@BO 10.0
END
@BOX1.1
BEGIN
::COMPILE CONDITIONAL COMPUTATION
@BOX2.1
IF OP = ILOAD
@BOX11.1
STACK.REGS(REG);
@BOX3.1
DUMMY() => I;
DUMMY() => J;
TL.LABEL.SPEC(NIL,3);
TL.LABEL.SPEC(NIL,3);
@BOX4.1
COMPILE.COND(1,I,0);
@BOX5.1
IF REQD.TYPE = B.REQD THEN
B.REQD => PT
ELSE
0 => PT
FI
COMPILE.COMP(0,PT) => OPD.TYPE;
@BOX6.1
REG -=> REGS.IU;
@BOX7.1
TL.PL(%4F,J);
TL.LABEL(I);
@BOX8.1
COMPILE.COMP(0,PT);
@BOX9.1
TL.LABEL(J);
@BOX10.1
END::7.3.2.4.1
@END
@TITLE MSL07.3.2.5(1,6)
@COL 6R-7R-10R
@COL 1S-2R-3R-4R-11R-5C
@COL 8R-9R
@ROW 6-3-8
@FLOW 1-2
@FLOW 3-5
@FLOW 4-5
@FLOW 11-5
@FLOW 6-5
@FLOW 7-5
@FLOW 10-5
@FLOW 8-5
@FLOW 9-5
@BOX1.0
BUILT IN FUNCTIONS
@BOX2.0
SWITCH ON FUNCTION
NUMBER FROM AR
@BOX 3.0
MAKE
#MSL07.3.2.5.2
@BOX4.0
SIZE
#MSL07.3.2.5.5
@BOX11.0
LENT
#MSL07.3.2.5.8
@BOX5.0
OP.OPD.DONE
@BOX6.0
BYTE
#MSL07.3.2.5.1
@BOX7.0
PART
#MSL07.3.2.5.4
@BOX10.0
LPST
#MSL07.3.2.5.7
@BOX8.0
POSN
#MSL07.3.2.5.3
@BOX9.0
LLST
#MSL07.3.2.5.6
@BOX1.1
::BUILT IN FUNCTIONS
@BOX2.1
SWITCH AR[1+>AP-1]=>L & %F
\BIF0,BIF1,BIF2,BIF3,BIF4,BIF5,BIF6,BIF7;
@BOX3.1
BIF1:
#MSL07.3.2.5.2
@BOX4.1
BIF4:
#MSL07.3.2.5.5
@BOX11.1
BIF7:
#MSL07.3.2.5.8
@BOX5.1
->OP.OPD.DONE;
@BOX6.1
BIF0:
#MSL07.3.2.5.1
@BOX7.1
BIF3:
#MSL07.3.2.5.4
@BOX10.1
BIF6:
#MSL07.3.2.5.7
@BOX8.1
BIF2:
#MSL07.3.2.5.3
@BOX9.1
BIF5:
#MSL07.3.2.5.6
@END
@TITLE MSL07.3.2.5.1(1,10)
@COL 1S-6T-7R-2R-3R-8T-9R-4R-5C
@FLOW 1-6N-7-2-3-8Y-9-4-5
@FLOW 6Y-2
@FLOW 8N-4
@BOX1.0
BYTE
@BOX2.0
COMPILE
PARAMETER
@BOX6.0
LOAD OPERATOR?
@BOX7.0
STACK CURRENT
REGISTER
@BOX3.0
IF IN D REGISTER
PLANT A=REF D[]
CONVERT A TO
BYTE ADDRESS TYPE
@BOX8.0
IN B REGISTER?
@BOX9.0
TL
BMODE = COMP TYPE
B = A
@BOX4.0
SET A/D REGISTERS
NOT IN USE
SET CURRENT
REGISTER IN USE
@BOX5.0
REVERSE
OP
@B1.1
::BYTE
@B2.1
COMPILE.COMP(0,0);
@BOX6.1
IF OP = ILOAD
@BOX7.1
STACK.REGS(REG);
@B3.1
IF LAST.REG = DREG THEN
TL.PL(%46,D.TYPE);
TL.PL(%21,DIND) FI
TL.PL(%45,CMP.TYPE=> A.TYPE);
@BOX8.1
IF REG /= BREG
@BOX9.1
TL.PL(%56,CMP.TYPE);
TL.PL(%02,AOPD);
@BOX4.1
REGS.IU ! AREG ! DREG
-= AREG -= DREG
! REG => REGS.IU;
@BOX5.1
->REVERSE.OP;
@END
@TITLE MSL07.3.2.5.2(1,10)
@COL 1S-2R-3T-4R-5R-6T-7R-8R-9R-10R-11F
@COL 12R-14R-15R-17T-18R
@ROW 4-12
@ROW 7-14
@FLOW 1-2-3N-4-5-6N-7-8-9-10-11
@FLOW 3Y-12-6
@FLOW 14-15-17N-18-9
@FLOW 6Y-14
@FLOW 17Y-10
@BOX 1.0
MAKE
@BOX 2.0
GET TYPE
FROM AR
@BOX 3.0
SCALAR REQUIRED?
@BOX 4.0
NOTE VECTOR MAKE
@BOX 5.0
COMPILE
B = PARAMETER 2
@BOX 6.0
BYTE ADDR REQUIRED?
@BOX 7.0
GET SPACE
NAME FROM AR
@BOX 8.0
TL.MAKE(SPACE,TYPE)
@BOX 9.0
SET B NOT IN USE
@BOX 10.0
SET A IN USE
SET A.TYPE
@BOX 11.0
END
@BOX 12.0
NOTE SCALAR MAKE
@BOX 14.0
COMPILE
A = BYTE ADDR
@BOX 15.0
CONVERT A TO
POINTER TYPE
@BOX 17.0
SCALAR MAKE?
@BOX 18.0
TL
LIMIT = B
@BOX 1.1
BEGIN
::MAKE
@BOX 2.1
AR[AP] => OPD.TYPE;
1 +> AP;
@BOX 3.1
IF L & %80 /= 0
@BOX 4.1
-1 => J;
@BOX 5.1
COMPILE.COMP(0,B.REQD);
@BOX 6.1
IF L & %40 /= 0
@BOX 7.1
AR[AP] => I;
1 +> AP;
@BOX 8.1
TL.MAKE(I,OPD.TYPE,J);
@BOX 9.1
REGS.IU ! BREG
-= BREG => REGS.IU;
@BOX 10.1
AREG !> REGS.IU;
CMP.TYPE => A.TYPE;
@BOX 11.1
END::7.3.2.5.2
@BOX 12.1
0 => J;
@BOX 14.1
COMPILE.COMP(0,0);
@BOX 15.1
IF J < 0 THEN
2 !> OPD.TYPE FI
TL.PL(%45,OPD.TYPE ! 1);
@BOX17.1
IF L & %80 /= 0
@BOX 18.1
TL.C.LIT.16(TINT,1);
TL.PL(9,0);
TL.PL(%27,0);
@END
@TITLE MSL07.3.2.5.3(1,6)
@COL 1S-2R-3R-4R-5F
@FLOW 1-2-3-4-5
@BOX1.0
POSN
@BOX2.0
GET SPACE NAME
FROM AR
@BOX3.0
COMPILE ADDRESS
(INTO A)
@BOX4.0
TL
A => SPACE NAME
@BOX5.0
END
@BOX1.1
::POSN
@BOX2.1
AR[AP] => OPD;
1 +> AP;
@BOX3.1
COMPILE.COMP(0,0);
@BOX4.1
TL.PL(%20,OPD);
@BOX5.1
::END 7.3.2.5.2
@END
@TITLE MSL07.3.2.5.4(1,7)
@COL 1S-2R-3R-4R-5R-6R-7R-8R-9R-10R-11F
@FLOW 1-2-3-4-5-6-7-8-9-10-11
@BOX1.0
PART
@BOX2.0
GET PARAMETER
POINTERS FROM AR
@BOX3.0
COMPILE
B = PARAMETER 3
@BOX4.0
COMPILE
PARAMETER 1
(ENSURE IT IS
IN A REGISTER)
@BOX5.0
TL PLANT
LIMIT B
@BOX6.0
SET B NOT IN USE
@BOX7.0
COMPILE
B = PARAMETER 2
@BOX8.0
TL PLANT
BASE B
@BOX9.0
SET B REGISTER
NOT IN USE
@BOX10.0
ADJUST AP
@BOX11.0
END
@BOX1.1
::PART
@BOX2.1
AP => I;
AR[I+1] => AP;
@BOX3.1
COMPILE.COMP(0,B.REQD);
@BOX4.1
AP => J;
I + 2 => AP;
COMPILE.COMP(0,0);
IF LAST.REG = DREG THEN
TL.PL(%46,CMP.TYPE => A.TYPE);
TL.PL(%21,DIND);
AREG => REG;
REGS.IU -= DREG ! AREG => REGS.IU FI
@BOX5.1
TL.PL(%27,0);
@BOX6.1
BREG -=> REGS.IU;
@BOX7.1
AR[I] => AP;
COMPILE.COMP(0,B.REQD);
@BOX8.1
TL.PL(%26,1);
@BOX9.1
BREG -=> REGS.IU;
@BOX10.1
J => AP;
@BOX11.1
::END 7.3.2.5.4
@END
@TITLE MSL07.3.2.5.5(1,10)
@COL 1S-2T-3R-4R-8R-5R-6R-7C
@FLOW 1-2N-3-4-8-5-6-7
@FLOW 2Y-4
@BOX1.0
SIZE
@BOX2.0
LOAD OPERATOR?
@BOX3.0
STACK CURRENT
REGISTER
@BOX4.0
COMPILE ADDRESS
OF VECTOR
@BOX8.0
(IF IN D REGISTER
PLANT A=REF D[] )
CONVERT A TO INTEGER
@BOX5.0
IF IN B REGISTER
PLANT B = A
@BOX6.0
SET A/D REGISTER
NOT IN USE
SET CURRENT
REGISTER IN USE
@BOX7.0
REVERSE
OP
@BOX1.1
::SIZE
@BOX2.1
IF OP = ILOAD
@BOX3.1
STACK.REGS(REG);
@BOX4.1
COMPILE.COMP(0,0);
@BOX8.1
IF LAST.REG = DREG THEN
TL.PL(%46,D.TYPE);
TL.PL(%21,DIND) FI
TL.PL(%45,CMP.TYPE => A.TYPE ! %4000);
@BOX5.1
IF REG = BREG THEN
TL.PL(%56,CMP.TYPE);
TL.PL(%02,AOPD) FI
@BOX6.1
REGS.IU ! AREG ! DREG
-=DREG -= AREG
! REG => REGS.IU;
@BOX7.1
->REVERSE.OP;
@END
@TITLE MSL07.3.2.5.6(1,6)
@COL 1S-2R-3F
@FLOW 1-2-3
@BOX1.0
LLST
@BOX2.0
TL
PLANT STKLINK
@BOX3.0
END
@BOX1.1
::LLST
@BOX2.1
TL.PL(%40,0);
@BOX3.1
::END 7.3.2.5.6
@END
@TITLE MSL07.3.2.5.7(1,6)
@COL 1S-2R-3R-4T-5R-6R-7F
@FLOW 1-2-3-4N-5-6-7
@FLOW 4Y-6
@BOX1.0
LPST
@BOX2.0
GET TYPE
FROM AR
@BOX3.0
COMPILE
COMPUTATION
@BOX4.0
IN CORRECT
FINAL TYPE?
@BOX5.0
TL
PLANT CONVERSION
@BOX6.0
TL
PLANT STACK PAR
@BOX7.0
END
@BOX1.1
BEGIN
::LPST
@BOX2.1
AR[AP] => OPD.TYPE;
1 +> AP;
@BOX3.1
COMPILE.COMP(0,0) => I;
@BOX4.1
IF I = OPD.TYPE
@BOX5.1
TL.PL(%45,OPD.TYPE);
@BOX6.1
TL.PL(%41,AOPD);
@BOX7.1
END::7.3.2.5.7
@END
@TITLE MSL07.3.2.5.8(1,6)
@COL 1S-2R-3R-4R-5R-6F
@FLOW 1-2-3-4-5-6
@BOX1.0
LENT
@BOX2.0
COMPILE
COMPUTATION
(INTO A)
@BOX3.0
TL
ENTER A
@BOX4.0
SET A REGISTER
NOT IN USE
SET CURRENT
REGISTER IN USE
@BOX5.0
TL
AMODE = CMP.TYPE
SET A.TYPE
@BOX6.0
END
@BOX1.1
::LENT
@BOX2.1
COMPILE.COMP(0,0);
@BOX3.1
TL.PL(%42,AOPD);
@BOX4.1
REGS.IU -= AREG ! REG => REGS.IU;
@BOX5.1
TL.PL(%46,CMP.TYPE => A.TYPE);
@BOX6.1
::END 7.3.2.5.8
@END
@TITLE MSL07.3.2.6(1,6)
@COL 1S-2R-3F
@FLOW 1-2-3
@BOX 1.0
STRINGS
@BOX 2.0
SET OPD AS
MUTLN FROM AR
SET REF
@BOX 3.0
END
@BOX 1.1
::STRINGS
@BOX 2.1
AR[AP] => OPD;
1 +> AP;
REF.BIT => REFR;
@BOX 3.1
::END 7.3.2.6
@END
@TITLE MSL07.3.3(1,6)
@COL 1S-2R-3T-4R-5T-6R-7T-17T-18T-8R
@COL 16R-9T-10R-23T-24R-25R-19R-11R-12F
@COL 20T-13T-14T-15R-26R
@COL 22R
@ROW 4-16
@ROW 10-20
@ROW 13-22
@FLOW 1-2-3Y-4-5Y-6-7Y-17N-18N(=>)-8-19-11
@FLOW 3N-16-9Y-10-23Y-24-25-11-12
@FLOW 9N-20Y-13N-14Y-15-19
@FLOW 23N-19
@FLOW 13Y-26-11
@FLOW 14N-19
@FLOW 5N-7
@FLOW 7N-19
@FLOW 17Y-11
@FLOW 18Y-12
@FLOW 20N-22
@BOX 1.0
PLANT OP
@BOX 2.0
FORM TL FN
FROM OPERATOR
@B19.0
IF STORE OR COMPARE
OPERATOR AND NEXT
OPERATOR A COMPARATOR
OR IF STORE OPERATOR
AND NOT FINAL OPERAND
THEN CALL TL.REG
@BOX 3.0
IN D REGISTER?
@BOX 4.0
CHANGE FN TO D FN
SET D.TYPE IF LOAD
@BOX 5.0
REF SET?
@BOX 6.0
SET FN AS
D = REF
CLEAR REF
@BOX 7.0
OPD D[]?
@BOX 17.0
FN D= ?
@BOX18.0
FN D=REF ?
@BOX 8.0
CHANGE FN
TO STK =>
SET D IN USE
DELETE STACK
TYPE ENTRY
@BOX 16.0
ADJUST TL FN IF
NEGATIVE LOAD
(AND CLEAR IT)
@BOX 9.0
IN A REGISTER
@BOX 10.0
CHANGE FN TO A FN
@BOX23.0
LOAD OPERATOR?
@BOX24.0
TL
AMODE = COMP TYPE
SET A.TYPE
@BOX25.0
IF REF SET
CHANGE FN TO
A=REF AND
CLEAR REF SET
@BOX 11.0
TL
FN OPD
@BOX 12.0
END
@BOX 20.0
IN B REGISTER?
@BOX 13.0
LOAD OPERATOR?
@BOX 14.0
B REGISTER
STACKED?
@BOX 15.0
UNSTACK B
@BOX26.0
TL
BMODE = COMP TYPE
SET B.TYPE
@BOX 22.0
FAULT 3
@B1.1
BEGIN
::PLANT OP
@B2.1
TL.FN[OP-ILOAD] => FN;
@B19.1
IF DLIST[OP => I] & %4 /=0 OR OP = ICOMP THEN
IF AR[AP] => I & %8000 /= 0 THEN
IF AR[AP+1] => I & %8000 /= 0 THEN
AR[AP+2] => I FI FI
IF DLIST[I] & %8 /=0
OR OP /= ICOMP AND I /= IEOS THEN
TL.REG(REG)
FI FI
@B3.1
IF REG /= DREG
@B4.1
$IF %60 !> FN = %62 $TH
CMP.TYPE => D.TYPE FI
@B5.1
IF REFR = 0
@B6.1
%61 => FN;
0 => REFR;
@B7.1
IF OPD /= DIND
@B17.1
IF FN = %62
@B18.1
IF FN = %61
@B8.1
%69 => FN;
DREG !> REGS.IU;
1 -> ST.PTR;
@B16.1
NLOAD +> FN;
0 => NLOAD;
@B9.1
IF REG /= AREG
@B10.1
%20 !> FN;
@BOX23.1
IF OP /= ILOAD
@BOX24.1
TL.PL(%46,CMP.TYPE => A.TYPE);
@BOX25.1
IF REFR /= 0 THEN
%21 => FN;0 => REFR FI
@B11.1
TL.PL(FN,OPD);
@B12.1
END::7.3.3
@B20.1
IF REG /= BREG
@B13.1
IF OP = ILOAD
@B14.1
IF REGS.IU & BREG /= 0
@B15.1
UNSTACK.REGS(BREG);
@BOX26.1
TL.PL(%56,CMP.TYPE => B.TYPE);
@B22.1
MONITOR(3);
@END
@TITLE MSL07.3.4(1,10)
@COL 1S-2T-3T-4R-5R-6R-7F
@COL 8R-9R
@ROW 4-8
@FLOW 1-2N-3N-4-5-6-7
@FLOW 2Y-7
@FLOW 3Y-8-9-6
@BOX 1.0
PLANT CONVERSION
@BOX 2.0
NEW TYPE SAME
AS COMP TYPE?
@BOX 3.0
IN B REGISTER?
@BOX 4.0
SET A.TYPE
@BOX 5.0
TL
ACONV = NEW TYPE
@BOX 6.0
SET COMP TYPE
FROM NEW TYPE
@BOX 7.0
END
@BOX8.0
SET B.TYPE
@BOX9.0
TL
BCONV = NEW TYPE
@B1.1
BEGIN
::PLANT CONVERSION
@B2.1
IF OP & %7FFF => OP = CMP.TYPE
@B3.1
IF REG = BREG
@B4.1
OP & %FF => A.TYPE;
@B5.1
TL.PL(%45,OP);
@B6.1
OP & %FF => CMP.TYPE;
@B7.1
END::7.3.4
@BOX8.1
OP & %FF => B.TYPE;
@BOX9.1
TL.PL(%55,OP);
@END
@TITLE MSL07.4(1,6)
@COL 1S-2R-4T-5R-6R-7F
@COL 8T-9R-10R
@ROW 5-8
@FLOW 1-2-4Y-5-6-7
@FLOW 4N-8Y-9-10-4
@FLOW 8N-10
@BOX 1.0
COMPILE.COND
(IF.OR.UN,DEST.LAB,NEXT.LAB)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 4.0
FINAL AND
CLAUSE?
@BOX 5.0
COMPILE
FINAL
AND CLAUSE
@BOX 6.0
DECLARE LABEL
AFTER CONDITION
IF GENERATED HERE
@BOX 7.0
EXIT
@BOX 8.0
FIRST AND
CLAUSE?
@BOX9.0
SET DESTINATION
LABEL FOR AN
CLAUSES
GENERATE LABEL
AFTER CONDIION IF
NECESSARY
@BOX 10.0
COMPILE
AND CLAUSE
@B1.1
$PR COMPILE.COND(IF.OR.UN,DEST.LAB,NEXT.LAB);
@B2.1
$IN I,N,LAB,LAB.AFTER;
AR[AP] => I => N;
1 +> AP;
NEXT.LAB => LAB.AFTER;
@B4.1
IF 1 -> I >= 0
@B5.1
COMPILE.AND(IF.OR.UN,DEST.LAB,LAB.AFTER);
@B6.1
IF LAB.AFTER /= NEXT.LAB THEN
TL.LABEL(LAB.AFTER)
FI
@B7.1
$EN
@B8.1
IF I + 1 /= N
@B9.1
IF IF.OR.UN = 0 THEN
DEST.LAB => LAB
ELSE
IF NEXT.LAB = 0 THEN
DUMMY() => LAB.AFTER;
TL.LABEL.SPEC(NIL,3)
FI
LAB.AFTER => LAB
FI
@B10.1
COMPILE.AND(0,LAB,0);
@END
@TITLE MSL07.5(1,6)
@COL 1S-2R-3T-4R-5R-6F
@COL 7T-8R-9R
@ROW 4-7
@FLOW 1-2-3Y-4-5-6
@FLOW 3N-7Y-8-9-3
@FLOW 7N-9
@BOX 1.0
COMPILE AND
(IF.OR.UN,DEST.LAB,NEXT.LAB)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
FINAL
TEST?
@BOX 4.0
COMPILE
FINAL TEST
@BOX 5.0
DECLARE LABEL
AFTER AND CLAUSE
IF GENERATED HERE
@BOX 6.0
EXIT
@BOX 7.0
FIRST
TEST?
@BOX 8.0
SET DESTINATION
LABEL FOR TESTS
GENERATE LABEL
AFTER TEST
IF NECESSARY
@BOX 9.0
COMPILE TEST
@B1.1
$PR COMPILE.AND(IF.OR.UN,DEST.LAB,NEXT.LAB);
@B2.1
$IN I,N,LAB,LAB.AFTER;
AR[AP] => I => N;
1 +> AP;
NEXT.LAB => LAB.AFTER;
@B3.1
IF 1 -> I >= 0
@B4.1
COMPILE.TEST(IF.OR.UN,DEST.LAB,LAB.AFTER);
@B5.1
IF LAB.AFTER /= NEXT.LAB THEN
TL.LABEL(LAB.AFTER)
FI
@B6.1
$EN
@B7.1
IF I +1 /= N
@B8.1
IF IF.OR.UN = 0 THEN
IF NEXT.LAB = 0 THEN
DUMMY() => LAB.AFTER;
TL.LABEL.SPEC(NIL,3)
FI
LAB.AFTER => LAB
ELSE
DEST.LAB => LAB
FI
@B9.1
COMPILE.TEST(1,LAB,0);
@END
@TITLE MSL07.6(1,11)
@COL 1S-2R-26T-3R-5R-6R-7T-8T-11R-12R-13T-14R-15R-16F
@COL 27R-28R-29T-18R-19T-20R-21R-22R-23R-24R
@COL 30R-25R
@ROW 3-27
@ROW 7-29
@ROW 18-30
@ROW 22-25
@FLOW 1-2-26N-3-5-6-7N-8N-11-12-13N-14-15-16
@FLOW 26Y-27-28
@FLOW 7Y-23
@FLOW 8Y-29N-18-19N-20-21-22-23-24-12
@FLOW 13Y-6
@FLOW 29Y-30
@FLOW 19Y-25-23
@BOX1.0
COMPILE.TEST
(IF.OR.UN,DEST.LAB,NEXT.LAB)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 26.0
GET NO OF TESTS FROM AR
IS IT [<CONDITION>] ?
@BOX 3.0
GET TYPE FOR COMPARISONS FROM AR
AND DETERMINE INITIAL EVALUATION
TYPE FOR L.H.S EXPRESSION
@BOX5.0
COMPILE LHS COMPUTATION
AND CONV TO COMP TYPE
IN CASE COMP CONTAINED A CONV.
@BOX6.0
NOTE COMPARATOR FROM AR
@BOX7.0
LHS STORED?
@BOX8.0
NEXT RHS NOT SINGLE OPERAND
OR NOT LITERAL OR NAMED ITEM
OR WOULD OPERAND EVALUATION
CAUSE REGISTER STACKING?
@BOX11.0
COMPILE OPERAND WITH
COMPARE OPERATOR
@BOX12.0
PLANT TEST JUMP
#MSL07.6.1
@BOX13.0
FURTHER COMPARISONS?
@BOX14.0
SET REGISTER NOT IN USE
@BOX15.0
DECLARE LABEL AFTER TEST
IF GENERATED HERE
@BOX16.0
EXIT
@BOX27.0
COMPILE CONDITION
@BOX 28.0
EXIT
@BOX29.0
AGGREGATE?
@BOX18.0
NOTE REVERSE
COMPARE REQUIRED
@BOX19.0
FINAL COMPARISON?
@BOX20.0
TL DECLARE VARIABLE
FOR LHS DUMP
@BOX21.0
TL PLANT
REG => DUMP
NOTE LHS STORED
SET REGISTER
NOT IN USE
@BOX22.0
SET COMPARE OPERAND
AS DUMP
@BOX23.0
COMPILE RHS COMPUTATION
@BOX 24.0
TL PLANT
REG COMP COMPARE OPERAND
SET REGISTER NOT IN USE
DELETE STACK.TYPE
ENTRY IF STACK OPERAND
@BOX30.0
FAULT 4
@BOX25.0
SET COMPARE OPERAND
AS STACK
@BOX1.1
$PR COMPILE.TEST(IF.OR.UN,DEST.LAB,NEXT.LAB);
@BOX2.1
$IN OP,TFN,COPD,CMP.TYPE,N,LTYPE;
$IN I,J,REV,LHS.STORED,JUMP.LAB,LAB.AFTER;
0 => REV => LHS.STORED;
NEXT.LAB => LAB.AFTER;
@BOX 26.1
IF AR[AP] => N = 0
@BOX3.1
AR[AP+1] => CMP.TYPE;
2 +> AP;
CHECK.TYPE(0,CMP.TYPE,AR[AP+1] & %7FFF) => LTYPE;
@BOX5.1
IF COMPILE.COMP(0,L.TYPE) /= CMP.TYPE THEN
TL.PL(%45,CMP.TYPE) FI
@BOX6.1
AR[AP-1] => OP;
@BOX7.1
IF LHS.STORED /= 0
@BOX8.1
IF AR[AP] ->> 4 => I & %8 =0
OR AR[AP+2] & %F => J > 2
OR J = 0 AND I & A.B.D & REGS.IU /= 0
@BOX 11.1
COMPILE.COMP(ICOMP,CMP.TYPE);
@BOX12.1
#MSL07.6.1
@BOX13.1
IF 1 -> N /= 0
@BOX14.1
REGS.IU ! AREG -= AREG => REGS.IU;
@BOX15.1
IF LAB.AFTER /= NEXT.LAB THEN
TL.LABEL(LAB.AFTER)
FI
@BOX16.1
$EN
@BOX27.1
1 +> AP;
COMPILE.COND(IF.OR.UN,DEST.LAB,NEXT.LAB);
1 +> AP;
@BOX 28.1
$EX
@BOX29.1
IF CMP.TYPE & %FF03 /= 0
@BOX18.1
1 => REV;
@BOX19.1
IF N = 1
@BOX20.1
DUMMY() => COPD;
TL.S.DECL(NIL,CMP.TYPE,0);
@BOX21.1
TL.PL(%20,COPD);
1 => LHS.STORED;
AREG -=> REGS.IU;
@BOX22.1
::DONE IN BOX 20
@BOX 23.1
COMPILE.COMP(0,CMP.TYPE);
@BOX24.1
TL.PL(%2F,COPD);
AREG -=> REGS.IU;
IF COPD = UNSTK THEN
1 -> ST.PTR
FI
@BOX30.1
MONITOR(4);
@BOX25.1
UNSTK => COPD;
@END
@TITLE MSL07.6.1(1,6)
@COL 1S-2R-3T-4R-5T-6T-7R-9T-10R-11R-12R-13F
@COL 14R-15R
@ROW 6-14
@ROW 11-15
@FLOW 1-2-3Y-4-5N-6N-7-9N-10-11-12-13
@FLOW 3N-5
@FLOW 5Y-14-15-12
@FLOW 6Y-15
@FLOW 9Y-11
@BOX1.0
PLANT TEST JUMP
@BOX2.0
FORM TEST FN
FROM COMPARE OPERATOR
@BOX3.0
REVERSE COMPARE REQUIRED?
@BOX4.0
ADJUST TEST FN
FOR REVERSE COMPARE
@BOX5.0
'UNLESS' CASE?
@BOX 6.0
FINAL COMPARISON
IN TEST?
@BOX7.0
ADJUST TEST FN
FOR INVERSE TEST
@BOX 9.0
LABEL AFTER
TEST SET?
(INITIALLY NEXT.LAB)
@BOX10.0
GENERATE AND SPECIFY
TO TL LABEL AFTER TEST
@BOX11.0
SET JUMP LABEL TO
LABEL AFTER TEST
@BOX12.0
TL PLANT
TEST FN  JUMP LABEL
@BOX13.0
END
@BOX14.0
ADJUST TEST FN
FOR INVERSE TEST
@BOX15.0
SET JUMP LABEL
TO DEST.LAB
@BOX1.1
BEGIN
::PLANT TEST JUMP
@BOX2.1
TL.TST.FN[OP-IMIN.COMP] => TFN;
@BOX3.1
IF REV = 0
@BOX4.1
REV.COMP[TFN - 9] => TFN;
@BOX5.1
IF IF.OR.UN = 1
@BOX6.1
IF N = 1
@BOX7.1
INV.TST[TFN-9]=>TFN;
@BOX9.1
IF LAB.AFTER /= 0
@BOX10.1
DUMMY() => LAB.AFTER;
TL.LABEL.SPEC(NIL,3);
@BOX11.1
LAB.AFTER => JUMP.LAB;
@BOX12.1
TL.PL(%40 ! TFN,JUMP.LAB);
@BOX13.1
END::7.6.1
@BOX14.1
INV.TST[TFN-9] => TFN;
@BOX15.1
DEST.LAB => JUMP.LAB;
@END
@TITLE MSL07.7(1,10)
@COL 1S-2R-3T-4R-5R-6T-7R-13R-8T-9R-10R-11R-12F
@FLOW 1-2-3Y-4-5-6Y-7-13-8Y-9-10-11-12
@FLOW 3N-6
@FLOW 6N-8
@FLOW 8N-11
@BOX 1.0
STACK.REGS(REG.BITS)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
A REG?
@BOX 4.0
TL
A => STACK
@BOX 5.0
NOTE A TYPE
IN STACK.TYPE
VECTOR
@BOX 6.0
B REG?
@BOX 7.0
TL
B => STACK
@BOX13.0
NOTE B TYPE
IN STACK.TYPE
VECTOR
@BOX 8.0
D REG?
@BOX 9.0
TL
D => STACK
@BOX 10.0
NOTE D TYPE
IN STACK.TYPE
VECTOR
@BOX 11.0
SET REGISTERS
NOT IN USE
@BOX 12.0
EXIT
@B1.1
$PR STACK.REGS(REG.BITS);
@B2.1
:: DECL & INIT
@B3.1
IF REG.BITS & AREG = 0
@B4.1
TL.PL(%47,A.OPD);
@B5.1
A.TYPE => STACK.TYPE[ST.PTR];
1 +> ST.PTR;
@B6.1
IF REG.BITS & BREG = 0
@B7.1
TL.PL(%47,B.OPD);
@BOX13.1
B.TYPE => STACK.TYPE[ST.PTR];
1 +> ST.PTR;
@B8.1
IF REG.BITS & DREG = 0
@B9.1
TL.PL(%47,STK.SEL);
@B10.1
D.TYPE => STACK.TYPE[ST.PTR];
1 +> ST.PTR;
@B11.1
REG.BITS -=> REGS.IU;
@B12.1
$EN
@END
@TITLE MSL07.8(1,10)
@COL 1S-2R-3T-4R-5R-6T-13R-7R-8T-9R-10R-11R-12F
@FLOW 1-2-3Y-4-5-6Y-13-7-8Y-9-10-11-12
@FLOW 3N-6
@FLOW 6N-8
@FLOW 8N-11
@BOX 1.0
UNSTACK.REGS(REG.BITS)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
D REG?
@BOX 4.0
SET D TYPE
FROM STACK.TYPE
VECTOR
@BOX 5.0
TL
D = STACK
@BOX 6.0
B REG?
@BOX13.0
SET B TYPE
FROM STACK.TYPE
VECTOR
@BOX 7.0
TL
BMODE = B TYPE
B = STACK
@BOX 8.0
A REG?
@BOX 9.0
SET A TYPE
FROM STACK.TYPE
VECTOR
@BOX 10.0
TL
AMODE = A TYPE
A = STACK
@BOX 11.0
SET REGISTERS
IN USE
@BOX 12.0
EXIT
@B1.1
$PR UNSTACK.REGS(REG.BITS);
@B2.1
:: DECL & INIT
@B3.1
IF REG.BITS & DREG = 0
@B4.1
STACK.TYPE[1->ST.PTR] => D.TYPE;
@B5.1
TL.PL(%62,STK.SEL);
@B6.1
IF REG.BITS & BREG = 0
@BOX13.1
STACK.TYPE[1->ST.PTR] => B.TYPE;
@B7.1
TL.PL(%56,B.TYPE);
TL.PL(%02,UNSTK);
@B8.1
IF REG.BITS & AREG = 0
@B9.1
STACK.TYPE[1 -> ST.PTR] => A.TYPE;
@B10.1
TL.PL(%46,A.TYPE);
TL.PL(%22,UNSTK);
@B11.1
REG.BITS !> REGS.IU;
@B12.1
$EN
@END
@TITLE MSL07.9(1,6)
@COL 1S-2R-3T-4T-5T-6T-7R
@COL 14T-8R-9R-10R-12F
@ROW 4-14
@FLOW 1-2-3N-4N-5N-6N-7-12
@FLOW 3Y-14N-8-12
@FLOW 4Y-9-12
@FLOW 5Y-10-12
@FLOW 6Y-9
@FLOW 14Y-9
@BOX 1.0
REG.FROM.TYPE(TYPE,KIND)
@BOX 2.0
DECLARATIONS &
INITIALISATION
@BOX 3.0
LABEL OR
ADDR PROC OR
POINTER TYPE?
@BOX 4.0
BASIC TYPE?
@BOX 5.0
VECTOR TYPE?
@BOX 6.0
AGGREGATE TYPE?
@BOX 7.0
SET NONE
@BOX14.0
DOES KIND INDICATE A
POINTER ASSIGNMENT
OR COMPARISON
@BOX 8.0
SET D REGISTER
@BOX 9.0
SET A REGISTER
@BOX 10.0
SET 'VECTOR'
@BOX 12.0
EXIT
@BOX 1.1
$PR REG.FROM.TYPE(CTYPE,KIND);
@BOX 2.1
::DECL & INIT
@BOX 3.1
IF CTYPE & 3 /= 0
OR CTYPE = TADPROC
OR CTYPE = TLAB
@BOX 4.1
IF CTYPE < %100 > 0
@BOX 5.1
IF CTYPE >= %4000
@BOX 6.1
IF CTYPE /= 0
@BOX 7.1
0 => REG.FROM.TYPE;
@BOX14.1
IF KIND /= 0
@BOX 8.1
DREG => REG.FROM.TYPE;
@BOX 9.1
AREG => REG.FROM.TYPE;
@BOX 10.1
VEC => REG.FROM.TYPE;
@BOX 12.1
$EN
@END
@TITLE MSL07.10(1,11)
@COL 12T-13R-14T-15R
@COL 1S-2R-3T-18T-16T-4T-5T-6T-7T-8T-9T-10R-11F
@COL 17R-19T-20R-21T-22T-23R
@ROW 18-17
@ROW 12-5
@ROW 13-8
@ROW 14-9
@FLOW 1-2-3N-18N-16N-4N-5N-6N-7N-8Y-9N-10-11
@FLOW 3Y-17-18Y-19Y-10
@FLOW 16Y-20-21Y-22Y-23-11
@FLOW 4Y-12N-13
@FLOW 5Y-10
@FLOW 6Y-15
@FLOW 7Y-13
@FLOW 8N-14N-15-11
@FLOW 9Y-15
@FLOW 12Y-15
@FLOW 14Y-10
@FLOW 19N-16
@FLOW 21N-4
@FLOW 22N-4
@BOX1.0
CHECK.TYPE(OP,OLD,NEW)
@BOX2.0
DECLARATIONS &
INITIALISATION
@BOX3.0
IS OLD OF TYPE LOGICAL ?
@BOX 16.0
IS NEW OF TYPE LOGICAL ?
@BOX4.0
OP A SHIFT
OPERATOR?
@BOX5.0
OLD NOT SET?
@BOX6.0
OLD = NEW?
@BOX7.0
ARE OLD OR NEW
AGGREGATE OR
LABEL OR
POINTER TYPES?
@BOX8.0
OLD AND NEW OF
SAME ARITHMETIC TYPE?
@BOX9.0
SIZE OF OLD >=
SIZE OF NEW ?
@BOX10.0
SET RESULT
TO NEW TYPE
@BOX11.0
EXIT
@BOX12.0
IS NEW TYPE
INTEGER?
@BOX13.0
FAULT 3
@BOX14.0
IS NEW TYPE
REAL?
@BOX15.0
SET RESULT
TO OLD TYPE
@BOX 17.0
CHANGE OLD TO INTEGER
@BOX18.0
IS IT INTEGER64 ?
@BOX 19.0
IS NEW OF TYPE POINTER
AND OPERATOR IS '=>'
OR OPERATOR IS TERMINATOR ?
@BOX 20.0
CHANGE NEW TO INTEGER
@BOX 21.0
IS IT INTEGER64 ?
@BOX 22.0
IS OLD OF TYPE POINTER
AND OPERATOR IS '=>'
OR OPERATOR IS TERMINATOR ?
@BOX 23.0
SET RESULT TO
OLD TYPE
@BOX1.1
$PR CHECK.TYPE(OP,OLD,NEW);
@BOX2.1
::DECL & INIT
@BOX3.1
IF OLD <256 AND OLD & %C3 = TLO0
@BOX16.1
IF NEW < 256 AND NEW & %C3 = TLO0
@BOX4.1
IF DLIST[OP] & %1000 /= 0
@BOX5.1
IF OLD =0
@BOX6.1
IF OLD = NEW
@BOX7.1
IF OLD > 256 OR NEW > 256
OR OLD = TLAB
OR NEW = TLAB
OR OLD & 3 /= 0
OR NEW & 3 /= 0
@BOX8.1
IF NEW & %C0 => OP /= OLD & %C0
@BOX9.1
IF OLD >= NEW
@BOX10.1
NEW => CHECK.TYPE;
@BOX11.1
END
@BOX12.1
IF NEW <256 AND NEW & %C3 = TINT0
@BOX13.1
MONITOR(3);
@BOX14.1
IF OP = 0
@BOX15.1
OLD => CHECK.TYPE;
@BOX 17.1
OLD -TINT0 => OLD;
@BOX 18.1
IF OLD = TINT64
@BOX 19.1
IF NEW & %3 = 0
OR OP /= ISTORE
AND DLIST[OP] & %800 = 0
@BOX 20.1
NEW -TINT0 => NEW;
@BOX 21.1
IF NEW /= TINT64
@BOX 22.1
IF OLD & %3 = 0
OR OP /= ISTORE
AND DLIST[OP] & %800 = 0
@BOX 23.1
OLD => CHECK.TYPE;
@END
@TITLE MSL07.11(1,6)
@COL 1S-2R-3R-4F
@FLOW 1-2-3-4
@BOX 1.0
PRINT.AR
@BOX 2.0
PRINT HEADINGS
@BOX 3.0
PRINT ELEMENTS IN
APPROPRIATE FORMAT
@BOX 4.0
END
@BOX 1.1
$PR PRINT.AR;
$IN I;
@BOX 2.1
SELECTOUTPUT(MSTR);
NEWLINES(0);
CAPTION(%"AR");
@BOX 3.1
0 => I;
L1:
NEWLINES(0);
L2:
OUTHEX(AR[I],8);
IF 1 +> I > AP, -> OUT;
IF I & 7 = 0, -> L1;
SPACES(2);
-> L2;
OUT:
NEWLINES(0);
@BOX 4.1
$EN
@END