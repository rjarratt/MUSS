@X @~
~V7 56 2 -5
~L3 COUK1247
80
~D10
~H                    MUSS
~
~
~D10
~H            NMSL031
~D10
~MMANCHESTER UNIVERSITY  -  CONFIDENTIAL~
~
~
                                                            ISSUE 11~
~V9 -1
~P
~V9 1
~YMSL031
~M~OMSL IMPLEMENTATION DESCRIPTION
~
~M~OSection 3 Version 1
~S1~OSection 3.1 Lexical Analysis
~S1~O1. General Description
~BThis section of the compiler handles the input of the source
program text.The main procedure in this module is the ITEMISE procedure which
reads a MUSL statement and itemises it into its constituent parts. An
encoding of the statement is placed in the itemised line buffer (LBUFF)
ignoring control characters and comments,
and a copy of its source characters is placed in SBUFF to
facilitate fault monitoring. Any
new names contained in the statement are added to the name list
CHLIST (described in section 8) and literal and string
constants are added to the constant list CLIST,
which is part of this module.~
~S1~O2. Interfaces
~
~
Other modules used~
~
Section 1 : (Compiler Organisation)~
Section 2 : (Declarations and Initialisations)~
Section 8 : (Name List Management)~
~S1~O2.1 Software Interface
~
~
Exported Scalars~
~T% 9
%IPTR~
%SPTR~
%Literals which give the ITEM encoding of characters~
%(e.g. PLUS, MINUS, DOF, DOR, etc.)~
~
Exported Types~
%ITYPE~
~
Exported Vectors~
%LBUFF~
%SBUFF~
%CLIST~
%DLIST~
~S1~O3. Implementation
~S1~O3.1 Outline of Operation
~S1~O3.1.1 ITEMISE (MODE)
~BLexical analysis is done by the procedure ITEMISE.
Clearly, if ITEMISE is to read one complete statement
each time it is called it must make some assumptions about the
syntax of the language. These are~
~B1) Initial ';'s newlines and spaces are to be ignored, hence they
may be used redundantly between statements~
~B2) Newlines and spaces between items can be ignored~
~B3) A ';' as an item always terminates a statement but it may be
terminated in other ways. For example, except for 'conditional' delimiters any
delimiter marked as a 'finisher' in DLIST will terminate the statement.
Also if any delimiter marked as a 'starter' is encountered after the
first item the statement is assumed to terminate before this delimiter. If a
delimiter marked 'conditional' occurs inside parenthesis '(' ')' or '[' ']'
its properties as a 'starter' or a 'finisher'
are suppressed (within the parenthesis).~
~B4) A comment - which is any string of symbols following '::' up to a newline i
s
ignored except that like ';' it is assumed to terminate the statement.~
~B5) All names must start with an alphabetic character,followed by any
number of alphanumeric characters. A name is compared with those in
datavec STEMS and REST and a match indicates a keyword,otherwise it is
treated as a program name.~
~B6) The $ symbol indicates that the following two characters must be
matched with a keyword stem in STEMS.~
~B7) String constants must be enclosed by double quotes.To include the
null, newline, newpage, double quote characters, the encodings $N, $L, $P, $"
are allowed.~
~BHowever, the ITEMISE procedure has a parameter MODE which
will normally be set to 0. When compiling datavectors it is called
with this parameter set to 1, this causes a newline to be treated
as a statement separator. The object of this is to improve the
relevance of fault monitoring
if there are incorrect elements in a datavector.~
~BThe mechanism by which the codes for the multicharacter
delimiters are generated is not detailed on the flowcharts. It operates as follo
ws.
No special treatment is given to the initial character, however,
when characters which are possible second and third characters
occur a check is made on the preceding item and it is converted
according to the following rules.~
~
~
~T% 5 8 19 32 35
%a%:%preceding a%:%is treated as a comment~
%a%-%preceding a%:%is converted to -:~
%a%/%preceding a%:%is converted to /:~
%a%>%preceding a%:%is converted to >:~
%a%/%preceding a%=%is converted to /=~
%a%-%preceding a%=%is converted to -=~
%a%>%preceding a%=%is converted to >=~
%an operator%preceding a%>%is converted to operator>~
%a%<%preceding a%<%is converted to <<~
%a%=%preceding a%<%is converted to =<~
%a%<<%preceding a%-%is converted to <<-~
%a%->%preceding a%>%is converted to ->>~
~BMinus signs in expressions are also given special treatment
as follows. First when '-' follows an operator or comparator it is
converted to a code that represents unary minus (85). If
an integer constant follows a unary minus the
constant is negated and the code 85 is deleted.~
~S1~O3.2 Data Structures
~
~T% 10
~BThe output of the lexical section are the text of the input lines forming
the statement in SBUFF and the itemised form of the statement in LBUFF.~
~
DLIST~Ithis is a data vector containing bit patterns which give the
characteristics of the delimiters, and it is described
below. Delimiters in LBUFF are represented by
their index into the DATAVEC DLIST.~
~
LBUFF~Ithis is a vector in which the itemised statement is
placed. Each element of the vector is of type ITYPE.~
~
IPTR~Ithis is used as an index into LBUFF and is normally
'pointing' to the next item to be processed.
On exit from itemise it is always set zero.~
~
ITYPE~Ithis is an aggregate type with three fields called
TAG, ST and IND.~
~
%The TAG field distinguishes four kinds of item thus~
~
%0 indicates a Delimiter Item~
%1 indicates a Name Item~
%2 indicates a Character String Item~
%3 indicates a Constant Item~
~
~IThe ST field specifies the SIZE and TYPE of a constant or
delimiter item according to the following encoding.~
~
%Bits 2-5 specify the size as a number of bytes less one~
%Bits 6-7 specify the type thus~
%0 real~
%1 integer~
%2 logical~
~
%Depending on the value of TAG, the IND field indicates the~
%position of~
%the delimiter in DLIST~
%or the name in the name list (i.e. its INTID)~
%or a string in CLIST~
%or the Constant in the CLIST~
~
SBUFF~IThis is a byte vector in which the characters of
a source statement are placed as they are read.
At the start of each item IPTR+128 is also stored in
SBUFF. This enables the monitor routine of
section 9 to indicate a position in the source that
corresponds to the last item processed.~
~
SPTR~IThis is a pointer to the last used position in SBUFF.~
~P
~T% 7 10 13 17 21
~3
%%%%TYPE---------------- ----------------STARTER~
%% BASIC TYPE-------------- | | --------------FINISHER~
%%BUILT IN FN------------ | | | | ------------CONDITIONAL~
%%COMP TERMTR---------- | | | | | | ----------OPERATOR~
%%%SHIFT OP-------- | | | | | | | | --------COMPARATOR~
%%%%%------ | | | | | | | | | | ------STORE OP~
%%%%%---- | | | | | | | | | | | | ----INIT COMP OP~
%%%%%-- | | | | | | | | | | | | | | --COND TERMTR~
%~O%%%% | | | | | | | | | | | | | | | | ~
%~O0%EOS%%| | | | |X| | | | | | | | | | |X|~
%~O1%BEGIN%%| | | | | | | | |X|X| | | | | | |~
%~O2%PROC%%| | | | | | | | |X| | | | | | | |~
%~O3%MODULE%%| | | | | | | | |X| | | | | | | |~
%~O4%END%%| | | | | | | | |X|X| | | | | | |~
%~O5%IF%%%| | | | | | | | |X| |X| | | | | |~
%~O6%THEN%%| | | | |X| | | | |X|X| | | | |X|~
%~O7%ELSE%%| | | | |X| | | |X|X|X| | | | | |~
%~O8%FI%%%| | | | |X| | | |X|X|X| | | | | |~
%~O9%WHILE%%| | | | | | | | |X| | | | | | | |~
%~O10%FOR%%| | | | | | | | |X| | | | | | | |~
%~O11%DO%%%| | | | |X| | | | |X| | | | | |X|~
%~O12%OD%%%| | | | | | | | |X|X| | | | | | |~
%~O13%SWITCH%%| | | | | | | | |X| | | | | | | |~
%~O14%ALTERNATIVE| | | | | | | | |X| | | | | | | |~
%~O15%SPACE%%| | | | | | | | |X| | | | | | | |~
%~O16%EXIT%%| | | | | | | | |X|X| | | | | | |~
%~O17%PSPEC%%| | | | | | | | |X| | | | | | | |~
%~O18%LITERAL%| | | | | | | | |X| | | | | | | |~
%~O19%DATAVEC%| | | | | | | | |X| | | | | | | |~
%~O20%TYPE%%| | | | | | | | |X| | | | | | | |~
%~O21%SELECT%%| | | | | | | | |X| | | | | | | |~
%~O22%ADDR%%| | | | | | | |X| | | | | | | | |~
%~O23%INTEGER%| | | | | | |X|X| | | | | | | | |~
%~O24%LOGICAL%| | | | | | |X|X| | | | | | | | |~
%~O25%REAL%%| | | | | | |X|X| | | | | | | | |~
%~O26%VSTORE%%| | | | | | | | |X| | | | | | | |~
%~O27%IMPORT%%| | | | | | | | |X| | | | | | | |~
%~O28%LSPEC%%| | | | | | | | |X| | | | | | | |~
%~O29%BYTE%%| | | | | |X| | | | | | | | | | |~
%~O30%MAKE%%| | | | | |X| | | | | | | | | | |~
%~O31%POSN%%| | | | | |X| | | | | | | | | | |~
%~O32%PART%%| | | | | |X| | | | | | | | | | |~
%~O33%SIZE%%| | | | | |X| | | | | | | | | | |~
%~O34%LLST%%| | | | | |X| | | | | | | | | | |~
%~O35%LPST%%| | | | | |X| | | | | | | | | | |~
%~O36%LENT%%| | | | | |X| | | | | | | | | | |~
%~O37%X1XX%%| | | | | |X| | | | | | | | | | |~
%~O38%BSPEC%%| | | | | | | | |X| | | | | | | |~
%~O39%WITHIN%%| | | | | | | | |X| | | | | | | |~
%~O40%LABEL%%| | | | | | |X|X| | | | | | | | |~
%~O41%OF%%%| | | | | | | | | | | | | | | | |~
%~O42%IS%%%| | | | | | | | | | | | | | | | |~
%~O43%AND%%| | | | |X| | | | | | | | | | |X|~O~
%%%%TYPE---------------- ----------------STARTER~
%% BASIC TYPE-------------- | | --------------FINISHER~
%%BUILT IN FN------------ | | | | ------------CONDITIONAL~
%%COMP TERMTR---------- | | | | | | ----------OPERATOR~
%%%SHIFT OP-------- | | | | | | | | --------COMPARATOR~
%%%%%------ | | | | | | | | | | ------STORE OP~
%%%%%---- | | | | | | | | | | | | ----INIT COMP OP~
%%%%%-- | | | | | | | | | | | | | | --COND TERMTR~
%~O%%%% | | | | | | | | | | | | | | | | ~
%~O44%OR%%%| | | | |X| | | | | | | | | | |X|~
%~O45%FROM%%| | | | |X| | | | |X| | | | | | |~
%~O46%>=%%%| | | | |X| | | | | | | |X| | | |~
%~O47%=<%%%| | | | |X| | | | | | | |X| | | |~
%~O48%>%%%| | | | |X| | | | | | | |X| | | |~
%~O49%<%%%| | | | |X| | | | | | | |X| | | |~
%~O50%/=%%%| | | | |X| | | | | | | |X| | | |~
%~O51%=%%%| | | | |X| | | | | | | |X| | | |~
%~O52%+%%%| | | | | | | | | | | |X| | |X| |~
%~O53%-%%%| | | | | | | | | | | |X| | |X| |~
%~O54%*%%%| | | | | | | | | | | |X| | | | |~
%~O55%/%%%| | | | | | | | | | | |X| | | | |~
%~O56%-:%%%| | | | | | | | | | | |X| | | | |~
%~O57%/:%%%| | | | | | | | | | | |X| | | | |~
%~O58%&%%%| | | | | | | | | | | |X| | | | |~
%~O59%!%%%| | | | | | | | | | | |X| | | | |~
%~O60%-=%%%| | | | | | | | | | | |X| | | | |~
%~O61%=>%%%| | | | | | | | | | | |X| |X| | |~
%~O62%+>%%%| | | | | | | | | | | |X| |X| | |~
%~O63%->%%%| | | | | | | | | | | |X| |X| | |~
%~O64%*>%%%| | | | | | | | | | | |X| |X| | |~
%~O65%/>%%%| | | | | | | | | | | |X| |X| | |~
%~O66%-:>%%| | | | | | | | | | | |X| |X| | |~
%~O67%/:>%%| | | | | | | | | | | |X| |X| | |~
%~O68%&>%%%| | | | | | | | | | | |X| |X| | |~
%~O69%!>%%%| | | | | | | | | | | |X| |X| | |~
%~O70%-=>%%| | | | | | | | | | | |X| |X| | |~
%~O71%<<%%%| | | | | | | | | | | | | | | | |~
%~O72%->>%%| | | |X| | | | | | | |X| | | | |~
%~O73%<<-%%| | | |X| | | | | | | |X| | | | |~
%~O74%^%%%| | | | | | | | | | | | | | |X| |~
%~O75%;%%%| | | | | | | | | |X| | | | | | |~
%~O76%,%%%| | | | |X| | | | | | | | | | |X|~
%~O77%[%%%| | | | | | | | | | | | | | | | |~
%~O78%]%%%| | | | |X| | | | | | | | | | |X|~
%~O79%(%%%| | | | | | | | | | | | | | |X| |~
%~O80%)%%%| | | | |X| | | | | | | | | | | |~
%~O81%\%%%| | | | |X| | | | | | | | | | | |~
%~O82%>:%%%| | | | | | | | | |X| | | | | | |~
%~O83%:%%%| | | | | | | | | |X| | | | | | |~
%~O84%FLTSYM%%| | | | | | | | | | | | | | | | |~
%~O85%UNARY MINUS| | | | | | | | | | | |X| | | | |~
%~O86%#%%%| | | | | | | | |X| | | | | | | |~
%~O87%EOL%%| | | | | | | | | | | | | | | | |~
~0
~Y
~V9 -1
~P
~V9 -1
~D15
~HFLOWCHARTS
~
~
~H              NMSL031
~V9 -1
~F
@TITLE MSL03(1,11)
@COL 1S-2R-3R-4R-5R-6F
@FLOW 1-2-3-4-5-6
@BOX 1.0
LEXICAL ANALYSIS MODULE
@BOX 2.0
TYPE DECLS
@BOX 3.0
LITERALS/VARIABLES
@BOX 4.0
PROCEDURES IN MODULE:
ITEMISE [MSL03.1]
@BOX 5.0
MODULE INITIALIZATION
@BOX 6.0
END
@BOX 1.1
#MSL03/1
MODULE(ITEMISE,ITYPE,TINT,TADPROC,TRE0,TINT0,TLO8,TVST,TLO0,TLO1,TLO,TLAB,
TDELIM,ITEM,LBUFF,IPTR,CLIST,DLIST,SBUFF,SPTR,SDLIST,STRINGTYPE,TRE,TBYADDR,
TINT16,TINT32,TINT64,TLO32,EOS,LSHIFT,ASTERISK,EOL,DIMPORT,
::MU6 DIF,DTHEN,DELSE,DDO,DVSTORE,DTY,DEND,DDATAVEC,DADDR,DWITHIN,
::MU6 DLA,DFROM,DOF,DIS,DAND,DOR,LTHAN,EQUALS,GTHAN,PLUS,MINUS,
::MU6 SLASH,GOTO,DAMPAND,DBANG,DEREF,HASH,REF,COMMA,LSB,RSB,LB,
::MU6 RB,BSLASH,XCOLON,COLON,
UMINUS,
TDELIM,TNAME,TSTRING,TCONST,IEOS,IBYTE,IMIN.COMP,ILOAD,ISTORE,ICOMP,INIT.S3);
@BOX 1.2
#MSL03/1
@BOX 2.1
$TY ITYPE $IS $LO8 TAG, ST $LO16 IND;
@BOX 2.2
// ITYPE declaration comes from nmsl011.h
@BOX 3.1
*GLOBAL 5;
$LI MAX.KEYWORD = 45;
$LI TINT0=%40,TLO8=%80,TLO0=%80,TLO1=%20,TADPROC=%24,STRING.TYPE=%83;
$LI TINT16=%44,TINT32=%4C,TINT64=%5C,TLO32=%8C,TRE0=%00,TLAB=%30;
ITYPE [LBUFFZ]LBUFF;
$LO8 [CLISTZ]CLIST;
$IN TINT,TLO,TRE,TBYADDR,TVST;
$IN IPTR,SPTR;
$LI SDLIST = 87;
::PDP *CODE 2;
*GLOBAL 1;
$DA DLIST($LO16)
%801 %C0 %80 %2080 %C0 %A0 %861 %8E0
%8E0 %80 %80 %841 %C0 %80 %80 %80
%C0 %80 %2080 %2080 %2080 %80 %100 %300
%300 %300 %80 %80 %80 %400 %400 %400
%400 %400 %400 %400 %400 %400 %80 %80
%300 %0 %0 %801 %801 %840 %808 %808
%808 %808 %808 %808 %12 %12 %10
%10 %10 %10 %10 %10 %10 %14 %14
%14 %14 %14 %14 %14 %14 %14 %14
%0 %1010 %1010 %2 %40 %801 %0 %801
%2 %800 %800 %40 %40 %0 %10 %80
$EN
*GLOBAL 5;
::PDP *CODE 1;
$LI/ITYPE  UMINUS=0\0\%55,EOS=0\0\%0,LSHIFT=0\0\%47,ASTERISK=0\0\%36,EOL=0\0\%57
,DIMPORT=0\0\%1B;
::MU6 $LI/ITYPE DIF = 0\0\%5, DTHEN = 0\0\%6,
::MU6 DELSE = 0\0\%7, DDO = 0\0\%B,DVSTORE = 0\0\%1A,DTY = 0\0\%14,
::MU6 DEND = 0\0\%4, DDATAVEC = 0\0\%13, DADDR = 0\0\%16, DLA = 0\%30\%28,DWITHI
N = 0\0\%27,
::MU6 DFROM = 0\0\%2D,DOF = 0\0\%29, DIS = 0\0\%2A, DAND = 0\0\%2B,
::MU6 DOR = 0\0\%2C, LTHAN = 0\0\%31, EQUALS = 0\0\%33, GTHAN = 0\0\%30,
::MU6 PLUS = 0\0\%34, MINUS = 0\0\%35,
::MU6 SLASH = 0\0\%37, GOTO = 0\0\%3F,DAMPAND = 0\0\%3A, DBANG = 0\0\%3B,
::MU6 DEREF = 0\0\%4A, HASH = 0\0\%56, REF = 0\0\%4A, COMMA = 0\0\%4C,
::MU6 LSB = 0\0\%4D, RSB = 0\0\%4E, LB = 0\0\%4F,
::MU6 RB = 0\0\%50, BSLASH = 0\0\%51, XCOLON = 0\0\%52,
::MU6 COLON = 0\0\%4B;
$LI KEYWORD = 44;
$LI TDELIM = 0, TNAME = 1, TSTRING = 2, TCONST = 3;
$LI IEOS = 0, IBYTE = 29, IMIN.COMP = 46, ILOAD = 51, ISTORE = 61, ICOMP = 71;
$LO8[2000]SBUFF;
$LI NL=10, NEWP=12;
$LO CFWDPTR, CBWDPTR;
ITYPE SAVEDELIM;
@BOX 3.2
// MOVED MOST OF THIS BLOCK TO NMSL021
//#define MAXKEYWORD 45
//#define TINT0 0x40
//#define TLO8 0x80
//#define TLO0 0x80
//#define TLO1 0x20
//#define STRINGTYPE 0x83
//#define TINT16 0x44
//#define TINT32 0x4C
//#define TINT64 0x5C
//#define TLO32 0x8C
//#define TRE0 0x00
//#define TLAB 0x30
ITYPE LBUFF[LBUFFZ];
unsigned char CLIST[CLISTZ];
int TINT,TLO,TRE,TBYADDR,TVST;
int IPTR,SPTR;
unsigned short DLIST[] = {
0x801, 0xC0, 0x80, 0x2080, 0xC0, 0xA0, 0x861, 0x8E0,
0x8E0, 0x80, 0x80, 0x841, 0xC0, 0x80, 0x80, 0x80,
0xC0, 0x80, 0x2080, 0x2080, 0x2080, 0x80, 0x100, 0x300,
0x300, 0x300, 0x80, 0x80, 0x80, 0x400, 0x400, 0x400,
0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x80, 0x80,
0x300, 0x0, 0x0, 0x801, 0x801, 0x840, 0x808, 0x808,
0x808, 0x808, 0x808, 0x808, 0x12, 0x12, 0x10,
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x14, 0x14,
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
0x0, 0x1010, 0x1010, 0x2, 0x40, 0x801, 0x0, 0x801,
0x2, 0x800, 0x800, 0x40, 0x40, 0x0, 0x10, 0x80
};
// BELOW BLOCK MOVED TO NMSL021
//ITYPE UMINUS = { 0, 0, 0x55 };
//ITYPE EOS = { 0, 0, 0x0 };
//ITYPE LSHIFT = { 0, 0, 0x47 };
//ITYPE ASTERISK = { 0, 0, 0x36 };
//ITYPE EOL = { 0, 0, 0x57 };
//ITYPE DIMPORT = { 0, 0, 0x1B };
//#define KEYWORD 44
//#define TDELIM 0
//#define TNAME 1
//#define TSTRING 2
//#define TCONST 3
//
//#define IEOS 0
//#define IBYTE 29
//#define IMINCOMP 46
//#define ILOAD 51
//#define ISTORE 61
//#define ICOMP 71

unsigned char SBUFF[2000];
#define NL 10
#define NEWP 12
int CFWDPTR, CBWDPTR;
ITYPE SAVEDELIM;
@BOX 4.1
::PDP *CODE 1;
#MSL03.1.2
$PS ITEMISE($IN);
#MSL03.1
@BOX 4.2
#MSL03.1.2
extern void ITEMISE(int);
#MSL03.1
@BOX 5.1
$PS INITS3();
$PR INITS3;
::PDP $LI/$LO8 INT = %44, DEFAD = %44;
::MU6 $LI/$LO8 INT = %4C, DEFAD = %4C;
$AL CMODE&3 FROM
  $BE INT => TINT; DEFAD => TBYADDR;
  ::MC TINT16=> TINT;
  $EN
  TINT16 => TINT => TBYADDR;
  TINT32 => TINT => TBYADDR;
  $BE TINT16 => TINT; TINT32 => TBYADDR $EN
END
TINT+ %40 => TLO => TVST;
(IF CMODE & %30 = 0 THEN %0C ELSE
(IF CMODE & %10 /= 0 THEN
%0C ELSE %1C)) => TRE;
$FO IPTR < LBUFFZ $DO
EOS => LBUFF[IPTR] $OD
EOS => SAVEDELIM;
$EN
@BOX 5.2
void INITS3(void);
void INITS3(void)
{
  const unsigned char INT = 0x44;
  const unsigned char DEFAD = 0x44;
  switch (CMODE&3)
  {
    case 0:
    {
      TINT = INT;
	  TBYADDR = DEFAD;
      break;
    }
   
    case 1:
    {
      TINT = TINT16;
	  TBYADDR = TINT16;
	  break;
	}

    case 2:
    {
      TINT = TINT32;
	  TBYADDR = TINT32;
	  break;
	}

    case 3:
    {
      TINT = TINT16;
	  TBYADDR = TINT32;
      break;
    }
  }

  TVST = TINT + 0x40;
  TLO = TINT + 0x40;

  TRE = ((CMODE & 0x30) == 0) ? 0x0C : (((CMODE & 0x10) != 0) ? 0x0C : 0x1C);
  for ( ; IPTR < LBUFFZ; IPTR++)
  {
    memcpy(&LBUFF[IPTR], &EOS, sizeof(ITYPE));
  }
  memcpy(&SAVEDELIM, &EOS, sizeof(ITYPE));
}
@BOX 6.1

::END OF MODULE MSL031

*END
@END
@TITLE MSL03/1(1,10)
@COL 1S
@BOX 1.0
EXTERNAL SPEC
FOR MSL03
@BOX 1.1
$IM $LI LBUFFZ,CLISTZ;
$LS INCH()/$IN;
$LS OUTCH($IN);
$LS INBACKSPACE($IN);
$LS NEXTCH()/$IN;
$LS NEWLINES($IN);
$LS OUTLINENO($IN32);
$LS PPC.CMD();
$LS FINDN(ADDR[$LO8],$IN)/$LO32;
$LS SELECTOUTPUT($IN);
$LS SPACES($IN);
$LS OUTHEX($LO32,$IN);
$LS TL.LINE($IN32)/$IN;
$PS ADDN()/$LO16;
$PS GENN($LO16)/ADDR[$LO8];
$PS MONITOR($IN);
$IM $LI CHLISTZ;
$LO8[CHLISTZ] CHLIST;
$IN CWORD,LASTCH,CMODE;
$IN32 LINE.NO;
$IN MSTR,MUTLSTR
@BOX 1.2
#include <stdio.h>
#include <memory.h>
#include <string.h>

typedef struct { unsigned char TAG, ST; unsigned short IND; } ITYPE;
typedef unsigned char      uint8;
typedef short              int16;
typedef unsigned short     uint16;
typedef int                int32;
typedef unsigned int       uint32;
typedef long long          t_int64;
typedef unsigned int       uint32;
typedef unsigned long long t_uint64;

#define LBUFFZ 125
#define CLISTZ 125
#define PLISTZ 320
#define PARAMSZ 270
#define TLISTZ 250
#define NLISTZ 340
#define CHLISTZ 4100
#define SDLIST 87
extern ITYPE DIF;
extern ITYPE DTHEN;
extern ITYPE DELSE;
extern ITYPE DDO;
extern ITYPE DVSTORE;
extern ITYPE DTY;
extern ITYPE DEND;
extern ITYPE DDATAVEC;
extern ITYPE DADDR;
extern ITYPE DLA;
extern ITYPE DFROM;
extern ITYPE DOF;
extern ITYPE DIS;
extern ITYPE DAND;
extern ITYPE DOR;
extern ITYPE LTHAN;
extern ITYPE EQUALS;
extern ITYPE GTHAN;
extern ITYPE PLUS;
extern ITYPE MINUS;
extern ITYPE SLASH;
extern ITYPE GOTO;
extern ITYPE DAMPAND;
extern ITYPE DBANG;
extern ITYPE DEREF;
extern ITYPE HASH;
extern ITYPE REF;
extern ITYPE COMMA;
extern ITYPE LSB;
extern ITYPE RSB;
extern ITYPE LB;
extern ITYPE RB;
extern ITYPE BSLASH;
extern ITYPE XCOLON;
extern ITYPE COLON;
extern ITYPE UMINUS;
extern ITYPE EOS;
extern ITYPE LSHIFT;
extern ITYPE ASTERISK;
extern ITYPE EOL;
extern ITYPE DIMPORT;
#define KLAB 14
#define KLABREF 15
#define KVAR 4
#define KDUMMY 0
#define KGLAB 13
#define KIMPLAB 16
#define KTREF 9
#define KTYPE 6
#define NIL NULL
#define TADPROC 0x24
#define CONSTKZ 500
typedef struct { unsigned short MUTLN,MUSLN,HASH;} NLISTENT;
typedef struct { unsigned short INTID,PREVN,K,T; int32 DETAIL; } PLISTENT;
extern NLISTENT NLIST[NLISTZ];
extern PLISTENT PLIST[PLISTZ];
extern unsigned char CHLIST[CHLISTZ];
extern unsigned char XNAME[64];

#define MAXKEYWORD 45
#define TINT0 0x40
#define TLO8 0x80
#define TLO0 0x80
#define TLO1 0x20
#define STRINGTYPE 0x83
#define TINT16 0x44
#define TINT32 0x4C
#define TINT64 0x5C
#define TLO32 0x8C
#define TRE0 0x00
#define TLAB 0x30

#define KEYWORD 44
#define TDELIM 0
#define TNAME 1
#define TSTRING 2
#define TCONST 3

#define IEOS 0
#define IBYTE 29
#define IMINCOMP 46
#define ILOAD 51
#define ISTORE 61
#define ICOMP 71

// FROM NMSL051
#define KPSPEC 1
#define KPROC 3
#define KVAR 4
#define KFIELD 5
#define KTYPE 6
#define KLIT 7
#define KSPACE 8
#define KTREF 9
#define KEX 10
#define KDVEC 11
#define KDUMMY 0
#define KLAB 14
#define KLABREF 15
#define KGLAB 13
#define KIMPLAB 16

int CWORD,LASTCH,CMODE;
int LINENO;
FILE *MSTR,*MUTLSTR;
@END
@TITLE MSL03.1(1,11)
@COL 8C-9R-10C-11R-12C
@COL 1S-2R-3R-20R-4R-19R-5T-6R-7R
@COL 21C-22R-13C-14T-18R-15C-16R-17F
@ROW 4-21
@ROW 8-5-13
@ROW 10-6-15
@FLOW 1-2-3-20-4-19-5
@FLOW 7-5
@FLOW 6-5
@FLOW 8-9-12
@FLOW 10-11-12
@FLOW 13-14N-5
@FLOW 14Y-18-15-16-17
@FLOW 21-22-5
@BOX1.0
ITEMISE
@BOX2.0
VARIABLE/DATAVEC DECLARATIONS
#MSL03.1.1
@BOX3.0
INITIALIZE LBUFF
AND BCOUNT
@BOX4.0
IF MODE IS = 0
IGNORE SP NL
(CALL PPC.SEQ
IF **ENCOUNTERED)
@BOX 19.0
SET LINE.NO
@BOX5.0
SWITCH ON CH
@BOX6.0
PROCESS CONSTANTS
#MSL03.1.3
@BOX7.0
PROCESS NAMES
AND DELIMITERS
#MSL3.1.2
@BOX8.0
(
@BOX9.0
INC BCOUNT
@BOX10.0
)
@BOX11.0
DEC BCOUNT
@BOX12.0
DELIM
[MSL03.1.4]
@BOX13.0
NLINE
@BOX14.0
IS MODE LINE BY LINE
OR STATEMENT $LI $DA $MO $TY
@BOX15.0
;
@BOX16.0
STORE EOS ITEM
PRINT IBUFF IF CWORD SET
SET IPTR TO 0
@BOX17.0
END.
@BOX 18.0
STORE EOL ITEM
@BOX 20.0
INSERT DELIMITER SAVED FROM
PREVIOUS ITEMISED LINE INTO
NEW ITEMISED LINE
IF FINISHER,END THE LINE
@BOX 21.0
NEWPAGE
@BOX 22.0
INC PAGE NO AND RESET LINE NO
@BOX 1.1
$PR ITEMISE(MODE);
@BOX 1.2
void ITEMISE(int MODE)
{
@BOX 2.1
$LO STEM,PTR,RPTR,NPTR,ISYM,SYM,
    PPOS,BCOUNT,CSIZE,CTYPE,I,J,TY,SW;
$LO32 INT; $LO64 L64;
$RE64 FP,POWERS;
$LI/$IN TEN = 10, ZERO = 0;
#MSL03.1.1
@BOX 2.2
unsigned int STEM,PTR,RPTR,NPTR,ISYM,SYM,
    PPOS,BCOUNT,CSIZE,CTYPE,I,J,TY,SW;
uint32 INT;
t_uint64 L64;
double FP,POWERS;
const int TEN = 10;
const int ZERO = 0;
#MSL03.1.1
@BOX 3.1
BX3:
0 => CFWDPTR; CLISTZ => CBWDPTR;
0 => IPTR => PTR => BCOUNT => SPTR  => TY;
@BOX 3.2
BX3:
CFWDPTR = 0;
CBWDPTR = CLISTZ;
IPTR = 0;
PTR = 0;
BCOUNT = 0;
SPTR =0;
TY = 0;
@BOX 20.1
$IF SAVEDELIM /= EOS $TH
SAVEDELIM => LBUFF[1=>IPTR];
EOS => SAVEDELIM
$IF DLIST[IND OF LBUFF[1]] & 64 /= 0, -> SCOLON
$FI
@BOX 20.2
if (memcmp(&SAVEDELIM, &EOS, sizeof(ITYPE)) != 0)
{
  IPTR = 1;
  memcpy(&LBUFF[IPTR], &SAVEDELIM, sizeof(ITYPE));
  memcpy(&SAVEDELIM, &EOS, sizeof(ITYPE));
  if ((DLIST[LBUFF[1].IND] & 64) != 0) goto SCOLON;
}
@BOX 4.1
B4:
$WH INCH() => ISYM = '; $AN MODE=0 $OR ISYM = '$L
$OR ISYM = '  $OR ISYM = %9 $DO  $OD
$IF INCH() = '* $AN ISYM = '* $TH
SELECT.OUTPUT(MSTR);
PPC.CMD(); -> B4;
ELSE INBACKSPACE(1)
$FI
INBACKSPACE(1);
@BOX 4.2
B4:
while ((ISYM = INCH()) == ';' && MODE == 0 || ISYM == '\n' || ISYM == ' ' || ISYM == 0x9)
{}

if (INCH() == '*' && ISYM == '*')
{
  SELECTOUTPUT(MSTR);
  PPCCMD();
  goto B4;
}
else
{
  INBACKSPACE(1);
}
INBACKSPACE(1);
@BOX 19.1
1 +> LINE.NO;
TL.LINE(LINE.NO);
$IF CWORD & 2 = 2 $TH
SELECTOUTPUT(MSTR);
NEWLINES(1);OUTLINENO(LINE.NO);
OUTCH(9)
$FI
@BOX 19.2
LINENO++;
TLLINE(LINENO);
if ((CWORD & 2) == 2)
{
  SELECTOUTPUT(MSTR);
  NEWLINES(1);OUTLINENO(LINENO);
  OUTCH(9);
}
@BOX 5.1
IG: $IF SBUFF[SPTR]&%80 = 0 $TH
128 + IPTR => SBUFF[1+>SPTR] $FI
XSYM() => ISYM;
VALCODE[ISYM] => SYM;
SWITCH SWCODE[ISYM]=>SW\
IG,ALPHA,DD,LBR,RBR,DOT,DQ,SQ,DELIM,COLON,PCENT,
COMP,COMP,COMP,MINUS,SCOLON,DOLLAR,NLINE,NPAGE;
@BOX 5.2
IG:
if ((SBUFF[SPTR] & 0x80) == 0)
{
  SPTR++;
  SBUFF[SPTR] = 128 + IPTR;
}
ISYM = XSYM();
SYM = VALCODE[ISYM];
SW = SWCODE[ISYM];
switch (SW)
{
case 0:  /* printf("IG, IPTR=%d\n", IPTR);     */ goto IG;
case 1:  /* printf("ALPHA, IPTR=%d\n", IPTR);  */ goto ALPHA;
case 2:  /* printf("DD, IPTR=%d\n", IPTR);     */ goto DD;
case 3:  /* printf("LBR, IPTR=%d\n", IPTR);    */ goto LBR;
case 4:  /* printf("RBR, IPTR=%d\n", IPTR);    */ goto RBR;
case 5:  /* printf("DOR, IPTR=%d\n", IPTR);    */ goto DOT;
case 6:  /* printf("DQ, IPTR=%d\n", IPTR);     */ goto DQ;
case 7:  /* printf("SQ, IPTR=%d\n", IPTR);     */ goto SQ;
case 8:  /* printf("DELIM, IPTR=%d\n", IPTR);  */ goto DELIM;
case 9:  /* printf("COLON, IPTR=%d\n", IPTR);  */ goto COLON;
case 10: /* printf("PCENT, IPTR=%d\n", IPTR);  */ goto PCENT;
case 11: /* printf("COMP, IPTR=%d\n", IPTR);   */ goto COMP;
case 12: /* printf("COMP, IPTR=%d\n", IPTR);   */ goto COMP;
case 13: /* printf("COMP, IPTR=%d\n", IPTR);   */ goto COMP;
case 14: /* printf("MINUS, IPTR=%d\n", IPTR);  */ goto MINUS;
case 15: /* printf("SCOLON, IPTR=%d\n", IPTR); */ goto SCOLON;
case 16: /* printf("DOLLAR, IPTR=%d\n", IPTR); */ goto DOLLAR;
case 17: /* printf("NLINE, IPTR=%d\n", IPTR);  */ goto NLINE;
case 18: /* printf("NPAGE, IPTR=%d\n", IPTR);  */ goto NPAGE;
}
@BOX 6.1
:: PROCESS CONSTANTS
# MSL03.1.3
@BOX 6.2
// PROCESS CONSTANTS
#MSL03.1.3
@BOX 7.1
:: PROCESS NAMES
:: AND DELIMITERS
# MSL03.1.4
@BOX 7.2
// PROCESS NAMES
// AND DELIMITERS
#MSL03.1.4
@BOX 8.1
LBR:
@BOX 8.2
LBR:
@BOX 9.1
1 +> BCOUNT;
@BOX 9.2
BCOUNT++;
@BOX 10.1
RBR:
@BOX 10.2
RBR:
@BOX 11.1
1 -> BCOUNT;
@BOX 11.2
--BCOUNT;
@BOX 12.1
->DELIM;
@BOX 12.2
goto DELIM;
@BOX13.1
NLINE:
@BOX13.2
NLINE:
@BOX14.1
$IF MODE =0 AND [TAG OF LBUFF[1] /= 0
$OR DLIST[IND OF LBUFF[1]] & %2000=0]
@BOX14.2
if ((MODE==0 && LBUFF[1].TAG != 0) || (DLIST[LBUFF[1].IND] & 0x2000)==0)
@BOX15.1
SCOL:
SCOLON:
@BOX15.2
SCOLON:
@BOX16.1
EOS => LBUFF[1+IPTR];
0 => IPTR
$IF CWORD & 1 /= 0 $TH
PRINT.ITEMLINE() $FI
@BOX16.2
memcpy(&LBUFF[1+IPTR], &EOS, sizeof(ITYPE));
IPTR = 0;
if ((CWORD & 1) != 0)
{
  PRINTITEMLINE();
}
@BOX17.1
$EN
@BOX17.2
;
}
@BOX 18.1
EOL => LBUFF[1+>IPTR];
@BOX 18.2
IPTR++;
memcpy(&LBUFF[IPTR], &EOL, sizeof(ITYPE));
@BOX 21.1
NPAGE:
@BOX 21.2
NPAGE:
@BOX 22.1
LINE.NO & %FFFF0000 + %10000 => LINE.NO;
@BOX 22.2
LINENO = (LINENO & 0xFFFF0000) + 0x10000;
@END
@TITLE MSL03.1.1(1,11)
@COL 3R-4R
@COL 8R-5R
@COL 6R
@ROW 4-5-6
@BOX 3.0
DATAVEC SWCODE
(SWITCH VALUE FOR LABELS
IN MSL03.1 BOX 5)
@BOX 4.0
DATAVEC STEMS
(FIRST TWO CHARS OF
EACH KEYWORD)
@BOX 5.0
DATAVEC REST
(REMAINING CHARS OF
EACH KEYWORD)
@BOX 6.0
DATAVEC PTRS
(POINTER INTO DATAVEC REST
TO MATCH FIRST TWO CHARS
OF STEMS
WITH REMAINDER IN REST)
@BOX 8.0
DATAVEC VALCODE
(VALUE OF CHARS IN DLIST)
@BOX 1.1
@BOX 1.2
@BOX 3.1
DATAVEC SWCODE ($LO8)
0[10]	::CONTROL CHARS
17    ::END OF LINE
0 18
0[20] ::CONTROL CHARS
8 6 8 16 10 8 7 3          :: ! " # $ % & ' (
4 8 8 8 14 5 8             ::) * + , - . /
2 2 2 2 2 2 2 2 2 2        ::0 1 2 3 4 5 6 7 8 9
9 15 13 11 12 1 8          ::: ; < = > ? @
1 1 1 1 1 1 1 1 1 1 1 1 1  ::LETTERS
1 1 1 1 1 1 1 1 1 1 1 1 1
8 8 8 8 8 8                  ::[ \ ]  <- `
1[26] ::LC LETTERS
8 8 8 8 8                :: { | } ~ ERASE
$EN
@BOX 3.2
unsigned char SWCODE[] =
{
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //CONTROL CHARS
17,    //END OF LINE
0, 18,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //CONTROL CHARS
8, 6, 8, 16, 10, 8, 7, 3,                                   // ! " # $ % & ' (
4, 8, 8, 8, 14, 5, 8,                                       //) * + , - . /
2, 2, 2, 2, 2, 2, 2, 2, 2, 2,                               //0 1 2 3 4 5 6 7 8 9
9, 15, 13, 11, 12, 1, 8,                                    //: ; < = > ? @
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                      //LETTERS
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
8, 8, 8, 8, 8, 8,                                           //[ \ ]  <- `
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, //LC LETTERS
8, 8, 8, 8, 8                                               // { | } ~ ERASE
};
@BOX 4.1
DATAVEC STEMS($LO32)
0
"BE"
"PR"
"MO"
"EN"
"IF"
"TH"
"EL"
"FI"
"WH"
"FO"
"DO"
"OD"
"SW"
"AL"
"SP"
"EX"
"PS"
"LI"
"DA"
"TY"
"SE"
"AD"
"IN"
"LO"
"RE"
"VS"
"IM"
"LS"
"BY"
"MA"
"PO"
"PA"
"SI"
"LL"
"LP"
"LE"
"X1"
"BS"
"WI"
"LA"
"OF"
"IS"
"AN"
"OR"
"FR"
END
@BOX 4.2
char *STEMS[] =
{
0,
"BE",
"PR",
"MO",
"EN",
"IF",
"TH",
"EL",
"FI",
"WH",
"FO",
"DO",
"OD",
"SW",
"AL",
"SP",
"EX",
"PS",
"LI",
"DA",
"TY",
"SE",
"AD",
"IN",
"LO",
"RE",
"VS",
"IM",
"LS",
"BY",
"MA",
"PO",
"PA",
"SI",
"LL",
"LP",
"LE",
"X1",
"BS",
"WI",
"LA",
"OF",
"IS",
"AN",
"OR",
"FR"
};
@BOX 5.1
DATAVEC REST($LO8)
0
"GIN" 0
"OC" 0
"DULE" 0
"D" 0

"EN" 0
"SE" 0

"ILE" 0
"R" 0


"ITCH" 0
"TERNATIVE" 0
"ACE" 0
"IT" 0
"PEC" 0
"TERAL" 0
"TAVEC" 0
"PE" 0
"LECT" 0
"DR" 0
"TEGER" 0
"GICAL" 0
"AL" 0
"TORE" 0
"PORT" 0
"PEC" 0
"TE" 0
"KE" 0
"SN" 0
"RT" 0
"ZE" 0
"ST" 0
"ST" 0
"NT" 0
"XX" 0
"XX" 0
"XX" 0
"BEL" 0


"D" 0

"OM" 0
'T 'H 'I 'N 0
END
@BOX 5.2
char *REST = \
"\0"\
"GIN\0"\
"OC\0"\
"DULE\0"\
"D\0"\

"EN\0"\
"SE\0"\

"ILE\0"\
"R\0"\


"ITCH\0"\
"TERNATIVE\0"\
"ACE\0"\
"IT\0"\
"PEC\0"\
"TERAL\0"\
"TAVEC\0"\
"PE\0"\
"LECT\0"\
"DR\0"\
"TEGER\0"\
"GICAL\0"\
"AL\0"\
"TORE\0"\
"PORT\0"\
"PEC\0"\
"TE\0"\
"KE\0"\
"SN\0"\
"RT\0"\
"ZE\0"\
"ST\0"\
"ST\0"\
"NT\0"\
"XX\0"\
"XX\0"\
"XX\0"\
"BEL\0"\


"D\0"\

"OM\0"\
"T\0"\
"H\0"\
"I\0"\
"N";
@BOX 6.1
DATAVEC PTRS($LO8)
0
0
4
7
12
3
14
17
3
20
24
3
3
26
31
41
45
48
52
58
64
67
72
75
81
87
90
95
100
104
107
110
113
116
119
122
125
128
48
146
137
3
3
141
3
143
END
@BOX 6.2
int PTRS[] =
{
0,
0,
4,
7,
12,
3,
14,
17,
3,
20,
24,
3,
3,
26,
31,
41,
45,
48,
52,
58,
64,
67,
72,
75,
81,
87,
90,
95,
100,
104,
107,
110,
113,
116,
119,
122,
125,
128,
48,
146,
137,
3,
3,
141,
3,
143
};
@BOX 8.1
DATAVEC VALCODE ($LO8)
0[33]	::CONTROL CHARS
59 0 86 0 0 58 0 79        :: ! " # $ % & ' (
80 54 52 76 53 0 55        ::) * + , - . /
126[10]                    ::0 1 2 3 4 5 6 7 8 9
75 0 49 51 48 127 84        :::; < = > ? @
127[13]                    ::LETTERS
127[13]
77 81 78 74 84 84          ::[ \ ] ^ <- .
127[13]                    ::LETTERS
127[13]
84 84 84 84 84             ::{ 1 } ~ ERASE
$EN
@BOX 8.2
int VALCODE[] =
{
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	//CONTROL CHARS
59, 0, 86, 0, 0, 58, 0, 79,                                                                         // ! " # $ % & ' (
80, 54, 52, 76, 53, 0, 55,                                                                          //) * + , - . /
126, 126, 126, 126, 126, 126, 126, 126, 126, 126,                                                   //0 1 2 3 4 5 6 7 8 9
75, 0, 49, 51, 48, 127, 84,                                                                         //:; < = > ? @
127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,                                    //LETTERS
127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
77, 81, 78, 74, 84, 84,                                                                             //[ \ ] ^ <- .
127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,                                    //LETTERS
127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
84, 84, 84, 84, 84                                                                                  //{ 1 } ~ ERASE
};
@END
@TITLE MSL03.1.2(1,10)
@COL 1R-2R-3R-4R-5R-6R
@COL 7R-8R
@ROW 3-7
@BOX 2.0
SUBROUTINES
@BOX 3.0
READ AND ECHO CHARACTERS
@BOX 4.0
READ INTEGER
@BOX 5.0
READ HEX NUMBER
@BOX 6.0
READ IN LENGTH OF BASIC
TYPE DECLARATION
@BOX 7.0
READ STRING CHARACTER
@BOX 8.0
PRINT ITEMISED LINE
@BOX2.1
PSPEC XSYM() /$LO;
PSPEC YSYM()/$LO;
PSPEC XINT($LO)/$LO32;
PSPEC XHEX() /$LO64;
PSPEC XBTYPE($LO,$IN)/$IN;
@BOX2.2
int XSYM(void);
int YSYM(void);
int32 XINT(int);
t_uint64 XHEX(void);
int XBTYPE(int, int);
@BOX 3.1
$PR XSYM;
$LI EOT = 4;
INCH() => XSYM;
$IF CWORD & 2 = 2 $TH
$IF XSYM /= EOT $TH
OUTCH(XSYM)
$FI
$FI
XSYM => SBUFF[1+>SPTR];
$EN
@BOX 3.2
int XSYM(void)
{
  const int EOT = 4;
  int result = INCH();
  if ((CWORD & 2) == 2)
  {
    if (result != EOT)
	{
      OUTCH(result);
    }
  }
  SPTR++;
  SBUFF[SPTR] = result;
  return result;
}
@BOX 4.1
$PR XINT(INIT.VAL);
$LO32 VAL;$IN SYM;
INIT.VAL => VAL;
$WH NEXTCH()=>SYM >= '0 $AN SYM =< '9 $DO
VAL * 10 - '0 + XSYM() => VAL $OD
VAL => XINT;
$EN
@BOX 4.2
int32 XINT(int INITVAL)
{
  unsigned int VAL;
  int SYM;
  VAL = INITVAL;
  SYM = NEXTCH();
  while (SYM >= '0' && SYM <= '9')
  {
    VAL =  VAL * 10 - '0' + XSYM();
    SYM = NEXTCH();
  }
  return VAL;
}
@BOX 5.1
$PR XHEX;
$LO64 ANS;$LO ISYM;
0 => ANS;
$WH NEXTCH()=>ISYM >= '0 $AN ISYM =< '9 $OR
ISYM >= 'A $AN ISYM =< 'F $OR ISYM = '( $DO
$IF ISYM = '( $TH
ANS & %F => ISYM;
XSYM();
$FO XINT(XSYM()-'0)-1 $DO
ANS <<- 4 ! ISYM => ANS $OD
$IF XSYM() /= ') $TH MONITOR(14) $FI
$EL $IF XSYM() >= 'A $TH
ANS <<- 4 ! (ISYM-'A+10) => ANS
$EL ANS <<-4 ! (ISYM-'0) => ANS;
$FI $FI $OD
ANS => XHEX;
$EN
@BOX 5.2
t_uint64 XHEX(void)
{
  t_uint64 ANS;
  unsigned int ISYM;
  ANS = 0;
  ISYM = NEXTCH();
  while ((ISYM >= '0' && ISYM <= '9') || (ISYM >= 'A' && ISYM <= 'F') || ISYM == '(')
  {
    if (ISYM == '(')
	{
      ISYM = ANS & 0xF;
      XSYM();
	  int n = XINT(XSYM()-'0')-1;
	  for (int i = 0; i < n; i++)
      {
	    ANS = ANS << 4 | ISYM;
      }
      if (XSYM() != ')')
	  {
	    MONITOR(14);
	  }
	}
	else
	{
	  if  (XSYM() >= 'A')
	  {
        ANS = ANS << 4 | (ISYM-'A'+10);
	  }
      else
	  {
        ANS = ANS << 4 | (ISYM-'0');
      }
	}
	ISYM = NEXTCH();
  }
  return ANS;
}
@BOX 6.1
$PR XBTYPE(TSIZE,PTR);
$IN T;
IF PTR>22<26 THEN
ALTERNATIVE PTR-23 FROM
BEGIN ::INTEGER
$IF TSIZE=0 $TH TINT => T
$EL $IF TSIZE & %7 = 0 $AN TSIZE =< 32 $TH
TSIZE ->> 1 + 60 => T
$EL MONITOR(3) $FI $FI
END
BEGIN ::LOGICAL
$IF TSIZE=0 $TH TLO => T
$EL $IF TSIZE & %7 = 0 $AN TSIZE = <32 $OR TSIZE = 64 $TH
TSIZE ->> 1 + 124 => T
$EL IF TSIZE = 1 $TH TLO1 => T
$EL MONITOR(3) $FI $FI $FI
END
BEGIN ::REAL
$IF TSIZE=0 $TH TRE => T
$EL $IF TSIZE = 32 $OR TSIZE = 64 $OR TSIZE = 128 $TH
TSIZE ->> 1 -4 => T
$EL MONITOR(13) $FI $FI
END
END
$EL IF TSIZE = 0 $TH
TLAB=>T;
$EL MONITOR(3) FI FI
T => XBTYPE;
$EN
@BOX 6.2
int XBTYPE(int TSIZE, int PTR)
{
  int T;
  if (PTR > 22 && PTR < 26)
  {
    switch (PTR-23)
    {
	  case 0: // INTEGER
      {
        if (TSIZE==0)
		{
		  T = TINT;
		}
		else if ((TSIZE & 0x7) == 0 && TSIZE <= 32)
        {
		  T = (TSIZE >> 1) + 60;
		}
        else
		{
		  MONITOR(3);
		}
		break;
      }
	  case 1: // LOGICAL
	  {
          if (TSIZE==0)
	  	{
	  	  T = TLO;
	  	}
	  	else if ((TSIZE & 0x7) == 0 && TSIZE <= 32 || TSIZE == 64)
          {
	  	  T = (TSIZE >> 1) + 124;
	  	}
          else
	  	{
	  	  MONITOR(3);
	  	}
	  	break;
	  }
	  case 2: // REAL
	  {
          if (TSIZE==0)
	  	{
	  	  T = TRE;
	  	}
	  	else if (TSIZE == 32 || TSIZE == 64 || TSIZE == 128)
          {
	  	  T = (TSIZE >> 1) - 4;
	  	}
          else
	  	{
	  	  MONITOR(3);
	  	}
	  	break;
	  }
	}
  }
  else if (TSIZE == 0)
  {
    T = TLAB;
  }
  else
  {
    MONITOR(3);
  }
  return T;
}
@BOX 7.1
$PR YSYM;
$IF XSYM() => YSYM = '$$ $TH
$IF XSYM() => YSYM = 'L $TH NL => YSYM
$EL $IF YSYM = 'P $TH NEWP => YSYM
$EL $IF YSYM = 'N $TH 0 => YSYM
$EL $IF YSYM /= '$$ /= '$"
$TH MONITOR (142);
$FI $FI $FI $FI
128 !> YSYM;
$FI
$EN
@BOX 7.2
int YSYM(void)
{
  int result = XSYM();
  if (result == '$')
  {
    result = XSYM();
	if (result == 'L')
	{
	  result = '\n';
	}
	else if (result == 'P')
	{
	  result = '\f';
	}
	else if (result == 'N')
	{
	  result = '\0';
	}
	else if (result == '$')
	{
	  result = '$';
	}
	else
	{
	  MONITOR(142);
	}
	result |= 128;
  }

  return result;
}
@BOX 8.1
$PS PRINT.ITEM.LINE();
$PR PRINT.ITEM.LINE;
$IN I;
SELECTOUTPUT(MSTR);
NEWLINES(0);
0 =>I;
WHILE LBUFF[1+>I] /= EOS DO
OUTHEX(TAG OF LBUFF[I] <<- 8
! ST OF LBUFF[I] <<- 16
! IND OF LBUFF[I], 8);
SPACES(2);
IF I & 7 = 0 THEN
NEWLINES(1) FI
$OD
END
@BOX 8.2
void PRINTITEMLINE(void);
void PRINTITEMLINE(void)
{
  int I;
  SELECTOUTPUT(MSTR);
  NEWLINES(0);
  I = 0;
  while (memcmp(&LBUFF[++I], &EOS, sizeof(ITYPE)) != 0)
  {
    OUTHEX(LBUFF[I].TAG << 8 | LBUFF[I].ST << 16 | LBUFF[I].IND, 8);
    SPACES(2);
    if ((I & 7) == 0)
	{
      NEWLINES(1);
	}
  }
}
@END
@TITLE MSL03.1.4(1,10)
@COL 23F
@COL 1C-2R-24R-3R-4T-14R-5R-6T-7T-8T-9T-10R-11C
@COL 15C-16R-17R-18T-19R-20C-21R-22C
@ROW 1-15
@ROW 23-11
@FLOW 1-2-24-3-4Y-5-6N-7N-8Y-11
@FLOW 4N-14-23
@FLOW 6Y-23
@FLOW 7Y-9N-10-11
@FLOW 9Y-8N-23
@FLOW 15-16-17-18Y-5
@FLOW 18N-19
@FLOW 20-21-22-5
@BOX1.0
ALPHA
AND ?
@BOX2.0
READ NAME
@BOX3.0
MATCH NAME WITH
KEYWORD DELIMS
@BOX4.0
IS IT A DELIM
@BOX14.0
STORE NAME ITEM
@BOX5.0
STORE DELIM ITEM
@BOX6.0
DELIM COND
& BCOUNT/=0
@BOX7.0
IS IT AN INIT DELIM
@BOX8.0
IS IT A TERM DELIM
@BOX9.0
IS IT FIRST ITEM AND MODE=0
OR *DELIM OR IMPORT
@BOX10.0
DELETE ITEM
@BOX11.0
S.COLON
@BOX15.0
$
@BOX16.0
READ STEM
@BOX17.0
MATCH NAME WITH
KEYWORD DELIMS
@BOX18.0
IS IT A DELIM
@BOX19.0
FAULT
@BOX20.0
MULTI DELIM
@BOX21.0
CREATE MUTLI-CHARACTER DELIM
#MSL03.1.4.1
@BOX22.0
DELIM
@BOX23.0
END
@BOX 24.0
IF ? NAME GOTO FINDN
@BOX 1.1
ALPHA:
@BOX 1.2
ALPHA:
@BOX 2.1
ISYM => CHLIST[LASTCH+1=>PTR];
NEXTCH() => ISYM;
$WH VALCODE[ISYM] >= 126 $OR ISYM = %2E $DO
$IF XSYM() /= %2E $TH
ISYM => CHLIST[1+>PTR] $FI
NEXTCH() => ISYM;
$OD
0 => CHLIST[1+>PTR];
@BOX 2.2
PTR = LASTCH+1;
CHLIST[PTR] = ISYM;
ISYM = NEXTCH();
while (VALCODE[ISYM] >= 126 || ISYM == 0x2E)
{
  if (XSYM() != 0x2E)
  {
    CHLIST[++PTR] = ISYM;
  }
  ISYM = NEXTCH();
}
CHLIST[++PTR] = 0;
@BOX 3.1
CHLIST[LASTCH+1] <<- 8 + CHLIST[LASTCH+2] => STEM;
0 => PTR => INT
$WH 1 +> PTR =< MAX.KEYWORD $DO
$IF STEMS[PTR] = STEM $TH
PTRS[PTR] => RPTR;
LASTCH+2 => NPTR;
$WH REST[1+>RPTR] = CHLIST[1+>NPTR]
$AN REST[RPTR] /= 0 $DO $OD
$IF REST[RPTR]=0 $AN DLIST[PTR] & %200 /= 0 $TH
1 -> NPTR
$WH VALCODE[CHLIST[1+>NPTR]] = 126 $DO
INT *10 + CHLIST[NPTR] - '0 => INT $OD
XBTYPE(INT,PTR) => TY $FI
-> B3 $FI $OD
B3:
@BOX 3.2
STEM = (CHLIST[LASTCH+1] << 8) + CHLIST[LASTCH+2];
PTR = 0;
INT = 0;
while (++PTR <= MAXKEYWORD)
{
  if (STEMS[PTR][0] == (STEM >> 8) && STEMS[PTR][1] == (STEM & 0xFF)) // stems are two bytes and fit into 16 bits
  {
    RPTR = PTRS[PTR];
    NPTR = LASTCH+2;
    while ((REST[++RPTR] == CHLIST[++NPTR]) && REST[RPTR] != 0) {}
    if (REST[RPTR]==0 && (DLIST[PTR] & 0x200) != 0)
	{
      --NPTR;
      while (VALCODE[CHLIST[++NPTR]] == 126)
	  {
        INT = INT *10 + CHLIST[NPTR] - '0'; 
	  }
      TY = XBTYPE(INT,PTR);
	}
    goto B3;
  }
}

B3:
@BOX4.1
$IF PTR =< MAX.KEYWORD $AN
CHLIST[NPTR] = 0 $AN REST[RPTR] = 0
@BOX4.2
/**/ /* The condition in the following line is inverted with respect to how it should be translated, not sure why */
if (PTR > MAXKEYWORD || CHLIST[NPTR] != 0 || REST[RPTR] != 0)
@BOX14.1
1 => TAG OF LBUFF[1+>IPTR];
0 => ST OF LBUFF[IPTR] => TY;
ADDN() => IND OF LBUFF[IPTR];
@BOX14.2
LBUFF[++IPTR].TAG = 1;
LBUFF[IPTR].ST = 0;
TY = 0;
LBUFF[IPTR].IND = ADDN();
@BOX 5.1
PTR => IND OF LBUFF[1+>IPTR];
TY => ST OF LBUFF[IPTR];
0 => TY;
TDELIM => TAG OF LBUFF[IPTR];
@BOX 5.2
LBUFF[++IPTR].IND = PTR;
LBUFF[IPTR].ST = TY;
TY = 0;
LBUFF[IPTR].TAG = TDELIM;
@BOX 6.1
$IF BCOUNT /= 0 $AN DLIST[PTR] & %20 /= 0
@BOX 6.2
if (BCOUNT != 0 && (DLIST[PTR] & 0x20) != 0)
@BOX 7.1
$IF DLIST[PTR] & %80 /= 0
@BOX 7.2
if ((DLIST[PTR] & 0x80) != 0)
@BOX 8.1
$IF DLIST[PTR] & %40 = 0
@BOX 8.2
if ((DLIST[PTR] & 0x40) == 0)
@BOX 9.1
IF [IPTR = 1 AND MODE=0]
OR LBUFF[1] = ASTERISK OR LBUFF[1] = DIMPORT
@BOX 9.2
if ((IPTR == 1 && MODE==0) || memcmp(&LBUFF[1], &ASTERISK, sizeof(ITYPE))==0 || memcmp(&LBUFF[1], &DIMPORT, sizeof(ITYPE))==0)
@BOX 10.1
LBUFF[IPTR] => SAVEDELIM;
1 -> IPTR;
@BOX 10.2
memcpy(&SAVEDELIM, &LBUFF[IPTR], sizeof(ITYPE));
IPTR--;
@BOX 11.1
-> SCOLON;
@BOX 11.2
goto SCOLON;
@BOX 15.1
DOLLAR:
@BOX 15.2
DOLLAR:
@BOX 16.1
XSYM() <<- 8 + XSYM() => STEM;
@BOX 16.2
STEM = (XSYM() << 8) + XSYM();
@BOX 17.1
0 => PTR
$WH 1 +> PTR =< MAX.KEYWORD $DO
$IF STEMS[PTR] = STEM $TH
$IF DLIST[PTR] & %200 /= 0 $TH
XBTYPE(XINT(0),PTR) => TY $FI
-> B17 $FI $OD
B17:
@BOX 17.2
PTR = 0;
while (++PTR <= MAXKEYWORD)
{
  if (STEMS[PTR][0] == (STEM >> 8) && STEMS[PTR][1] == (STEM & 0xFF)) // stems are two bytes and fit into 16 bits
  {
    if ((DLIST[PTR] & 0x200) != 0)
	{
      TY = XBTYPE(XINT(0),PTR);
	}
    goto B17;
  } 
}
B17:
@BOX18.1
$IF PTR =< MAX.KEYWORD
@BOX18.2
/* another case where the condition appears to need to be inverted */
/**/if (PTR > MAXKEYWORD)
@BOX 19.1
MONITOR(0);
@BOX 19.2
MONITOR(0);
@BOX 20.1
:: MULTI-CHARACTER DELIMITERS
@BOX 20.2
// MULTI-CHARACTER DELIMITERS
@BOX 21.1
#MSL03.1.4.1
@BOX 21.2
#MSL03.1.4.1
@BOX 22.1
DELIM:
SYM=>PTR
@BOX 22.2
DELIM:
PTR = SYM;
@BOX 23.1
@BOX 23.2
@BOX 24.1
$IF CHLIST[LASTCH+1] = '? ,->FN;
@BOX 24.2
if (CHLIST[LASTCH+1] == '?') goto FN;
@END
@TITLE MSL03.1.4.1(1,10)
@COL 1S-2R-3R-4R-5R-6R-10F
@COL 9R-7R-8R
@ROW 3-9
@FLOW 1-2
@FLOW 3-4
@FLOW 5-6-10
@FLOW 7-10
@FLOW 8-10
@BOX 1.0
CREATE MULTI-CHAR DELIMITER
IF PREVIOUS ITEM AN OPERATOR
@BOX 2.0
LITERALS OF OPERATORS
@BOX 3.0
COLON
@BOX 4.0
COMPARATOR
@BOX 5.0
EQ (ALSO COLON)
DATAVEC OF POSSIBLE PREVIOUS OPS
AND RESULTING DELIMS FOR "=" OR ":"
@BOX 6.0
CHECK PREVIOUS OPERATOR
@BOX 7.0
GT
@BOX 8.0
LT
@BOX 9.0
MINUS
@BOX 10.0
WRITE NEW DELIM ON TOP OF
PREVIOUS DELIM IN LBUFF
@BOX 1.1
@BOX 1.2
@BOX 2.1
$LI/$LO8
GE = 46,
LE = 47,
GT = 48,
LT = 49,
NE = 50,
EQ = 51,
SUBTRACT = 53,
DIVIDE = 55,
REVERSE.SUBTRACT = 56,
REVERSE.DIVIDE = 57,
NEQ = 60,
MINUS.STORE = 63,
LT.LT = 71,
RIGHT.SHIFT = 72,
LEFT.SHIFT = 73,
RESTART.LABEL = 82,
UNARY.MINUS = 85;
@BOX 2.2
#define GE 46
#define LE 47
#define GT 48
#define LT 49
#define NE 50
#define EQ 51
#define SUBTRACT 53
#define DIVIDE 55
#define REVERSESUBTRACT 56
#define REVERSEDIVIDE 57
#define NEQ 60
#define MINUSSTORE 63
#define LTLT 71
#define RIGHTSHIFT 72
#define LEFTSHIFT 73
#define RESTARTLABEL 82
#define UNARYMINUS 85
@BOX 3.1
COLON:
IF NEXTCH()=': THEN
WHILE XSYM()/='$L DO OD
IF IPTR=0, ->BX3
IF MODE/=0, ->NLINE;
->SCOLON FI
11=>SW;
@BOX 3.2
COLON:
if (NEXTCH()==':')
{
  while (XSYM()!='\n') {};
  if (IPTR==0) goto BX3;
  if (MODE!=0) goto NLINE;
  goto SCOLON;
}
SW = 11;
@BOX 4.1
COMP:
IF TAG OF LBUFF[IPTR]/=0, ->DELIM;
IND OF LBUFF[IPTR]=>I;
SWITCH SW-11\
EQ0,GT0,LT0;
@BOX 4.2
COMP:
if (LBUFF[IPTR].TAG !=0) goto DELIM;
I = LBUFF[IPTR].IND;
switch (SW-11)
{
case 0: goto EQ0;
case 1: goto GT0;
case 2: goto LT0;
}
@BOX 5.1
EQ0:
DATAVEC PREVIOUS($LO8)
SUBTRACT
DIVIDE
GT
END;
DATAVEC EQ.ETC($LO8)
NEQ
NE
GE
END;
DATAVEC COLON.ETC($LO8)
REVERSE.SUBTRACT
REVERSE.DIVIDE
RESTART.LABEL
END;
@BOX 5.2
EQ0:
;
int PREVIOUS[] =
{
SUBTRACT,
DIVIDE,
GT
};
int EQETC[] =
{
NEQ,
NE,
GE
};
int COLONETC[] = 
{
REVERSESUBTRACT,
REVERSEDIVIDE,
RESTARTLABEL
};
@BOX 6.1
-1=>J;
WHILE 1+>J<3 AND PREVIOUS[J]/=I
DO OD
IF J=3,->DELIM;
(IF SYM=EQ THEN EQ.ETC[J]
ELSE COLON.ETC[J])=>SYM;
@BOX 6.2
J = -1;
while (++J<3 && PREVIOUS[J]!= I) {}
if (J==3) goto DELIM;
SYM = (SYM==EQ)? EQETC[J] : COLONETC[J];
@BOX 7.1
GT0:
IF I>=EQ=<NEQ THEN
I+10=>SYM ELSE
IF I=MINUS.STORE THEN
RIGHT.SHIFT=>SYM ELSE
->DELIM
FI FI
@BOX 7.2
GT0:
if ((int)I >= EQ && EQ <=NEQ)
{
  SYM = I+10;
}
else
{
  if (I==MINUSSTORE)
  {
    SYM = RIGHTSHIFT;
  }
  else
  {
    goto DELIM;
  }
}
@BOX 8.1
LT0:
IF I=LT THEN
LT.LT=>SYM ELSE
IF I=EQ THEN
LE=>SYM ELSE
->DELIM
FI FI
@BOX 8.2
LT0:
if (I==LT)
{
  SYM = LTLT;
  if (I==EQ)
  {
    SYM = LE;
  }
  else
  {
    goto DELIM;
  }
}
@BOX 9.1
MINUS:
IF LBUFF[IPTR]=LSHIFT THEN
LEFT.SHIFT=>SYM;->MULTI
ELSE
IF TAG OF LBUFF[IPTR]=0
AND DLIST[IND OF LBUFF[IPTR]]&%18/=0
OR MODE=1 THEN
UNARY.MINUS=>SYM FI FI
->DELIM;
@BOX 9.2
MINUS:
if (memcmp(&LBUFF[IPTR], &LSHIFT,sizeof(ITYPE))==0)
{
  SYM = LEFTSHIFT;
  goto MULTI;
}
else
{
  if ((LBUFF[IPTR].TAG==0 && (DLIST[LBUFF[IPTR].IND] & 0x18)!=0) || MODE==1)
  {
    SYM = UNARYMINUS;
  }
}
goto DELIM;
@BOX 10.1
MULTI:
1->IPTR;
SBUFF[SPTR]=>SBUFF[1->SPTR];
@BOX 10.2
MULTI:
IPTR--;
SBUFF[--SPTR] = SBUFF[SPTR];
@END
@TITLE MSL03.1.3(1,10)
@COL 1S-2R-3C-17T-4R-18R-5C-19T-6R-8F
@COL 21C-22R-20R
@COL 9C-10R-11T-14R-12C-13R-15R-7R-16R
@ROW 3-14
@ROW 20-12
@ROW 4-15
@FLOW 1-2-20-7-16-8
@FLOW 3-17N-4-7
@FLOW 17Y-18-8
@FLOW 5-19N-6-7
@FLOW 9-10-11Y-15-7
@FLOW 11N-14-20
@FLOW 12-13-15
@FLOW 21-22-20
@FLOW 19Y-18
@BOX1.0
'
@BOX2.0
READ CHAR
@BOX3.0
"
@BOX 17.0
IS THE DATAVEC
MODE SWITCH SET
@BOX4.0
READ CH CONST
@BOX 18.0
READ STRING AND
STORE IN CLIST
@BOX 5.0
%
@BOX 19.0
IS NEXT CHAR = "
@BOX 6.0
READ HEX CONST
@BOX 7.0
FIND LENGTH IN BYTES
@BOX 16.0
STORE CONSTANT IN CLIST
@BOX 8.0
END
@BOX 9.0
DD
@BOX 10.0
READ INTEGER
@BOX 11.0
IS NEXT CHAR
'. OR '@
@BOX 12.0
.
@BOX 13.0
GENERATE ZERO
@BOX 14.0
PROCESS UNARY MINUS
@BOX 15.0
FORM REAL NO.
#MSL03.1.3.1
@BOX 20.0
CONVERT TO 64 BITS
@BOX 21.0
FINDN
@BOX22.0
LOOK UP LIB NAME
@BOX 1.1
SQ:
@BOX 1.2
SQ:
@BOX 2.1
YSYM() & 127 => INT;
2 => CTYPE;
@BOX 2.2
INT = YSYM() & 127;
CTYPE = 2;
@BOX 3.1
DQ:
@BOX 3.2
DQ:
@BOX 17.1
$IF MODE = 2
@BOX 17.2
if (MODE == 2)
@BOX 4.1
0 => L64;
$WH YSYM() => ISYM /= '$" $DO
$IF ISYM = NL $TH MONITOR(14) $FI
L64 <<- 8 ! (ISYM&127) => L64 $OD
2 => CTYPE;
@BOX 4.2
L64 = 0;
while ((ISYM = YSYM()) != '"')
{
  if (ISYM == NL)
  {
    MONITOR(14);
  }
  L64 = L64 << 8 | (ISYM&127);
}
CTYPE = 2;
@BOX 18.1
2 => TAG OF LBUFF[1+>IPTR];
CFWDPTR + 1 => IND OF LBUFF[IPTR];
$WH YSYM() => ISYM /= '$" $DO
$IF ISYM = NL $TH MONITOR(142) $FI
ISYM&127 => CLIST[1+>CFWDPTR] $OD
0 => CLIST[1+>CFWDPTR];
@BOX 18.2
LBUFF[++IPTR].TAG = 2;
LBUFF[IPTR].IND = CFWDPTR + 1;
while ((ISYM = YSYM()) != '"')
{
  if (ISYM == NL)
  {
    MONITOR(142);
  }
  CLIST[++CFWDPTR] = ISYM&127;
}
CLIST[++CFWDPTR] = 0;
@BOX5.1
PCENT:
@BOX5.2
PCENT:
@BOX 19.1
$IF NEXTCH()=>ISYM = '"
$AN XSYM() = ISYM
@BOX 19.2
if ((ISYM = NEXTCH()) == '"' && XSYM() == ISYM)
@BOX6.1
XHEX() => L64;
2 => CTYPE;
@BOX6.2
L64 = XHEX();
CTYPE = 2;
@BOX7.1
0 => CSIZE
$WH L64 /= 0 OR [CTYPE = 0 AND CSIZE < 8] $DO
L64 & %FF => CLIST[1->CBWDPTR];
L64 ->> 8 => L64;
1 +> CSIZE;
$OD
@BOX7.2
CSIZE = 0;
while (L64 != 0 || (CTYPE == 0 && CSIZE < 8))
{
  CLIST[--CBWDPTR] = L64 & 0xFF;
  L64 = L64 >> 8;
  CSIZE++;
}
@BOX 16.1
$IF CSIZE = 0 $TH
0 => CLIST[1->CBWDPTR];
1 => CSIZE $FI
3 => TAG OF LBUFF[1+>IPTR];
CTYPE <<- 4 + CSIZE - 1<<- 2 => ST OF LBUFF[IPTR];
CBWDPTR => IND OF LBUFF[IPTR];
@BOX 16.2
if (CSIZE == 0)
{
  CLIST[--CBWDPTR] = 0;
  CSIZE = 1;
}
LBUFF[++IPTR].TAG = 3;
LBUFF[IPTR].ST = ((CTYPE << 4) + (CSIZE - 1))<<2;
LBUFF[IPTR].IND = CBWDPTR;
@BOX8.1
@BOX8.2
@BOX9.1
DD:
@BOX9.2
DD:
@BOX10.1
XINT(ISYM - '0) => INT;
@BOX10.2
INT = XINT(ISYM - '0');
@BOX14.1
$IF LBUFF[IPTR] = UMINUS $TH
1->IPTR;1=>CTYPE;
$IF INT<128 $TH 256-INT => INT
$EL $IF INT=<%7FFF $TH %10000-INT=>INT
$EL 0-INT => INT $FI $FI
$EL 2 => CTYPE $FI
@BOX14.2
if (memcmp(&LBUFF[IPTR], &UMINUS, sizeof(ITYPE)) == 0)
{
  IPTR--;
  CTYPE = 1;
  if (INT<128)
  {
    INT = 256-INT;
  }
  else
  {
    if (INT<=0x7FFF)
	{
	  INT = 0x10000-INT;
	}
	else
	{
	  INT = 0-INT;
	}
  }
}
else
{
  CTYPE = 2;
}
@BOX 11.1
$IF NEXTCH() => ISYM = '@ OR
[ISYM = '. $AN XSYM() = ISYM]
@BOX 11.2
ISYM = NEXTCH();
/* another condition inversion? */
/**/if (!(ISYM == '@' || (ISYM == '.' && XSYM() == ISYM)))
@BOX12.1
DOT:
@BOX12.2
DOT:
@BOX13.1
0 => INT;
@BOX13.2
INT = 0;
@BOX 15.1
#MSL03.1.3.1
@BOX 15.2
#MSL03.1.3.1
@BOX 20.1
INT => L64;
@BOX 20.2
L64 = INT;
@BOX 21.1
FN:
@BOX 21.2
FN:
@BOX 22.1
FINDN(PART(^CHLIST,
LASTCH+2,PTR-1),0)=>INT;
2 => CTYPE;
@BOX 22.2
INT = FINDN(PART(&CHLIST, LASTCH+2,PTR-1),0);
CTYPE = 2;
@END
@TITLE MSL03.1.3.1(1,10)
@COL 1S-2R-3R-4R-5R-6F
@FLOW 1-2-3-4-5-6
@BOX 1.0
REAL NUMBER
@BOX 2.0
READ IN FRACTIONAL PART
@BOX 3.0
READ EXPONENT
@BOX 4.0
FORM REAL NUMBER
@BOX 5.0
PROCESS UNARY MINUS,REMOVE FROM ITEMISED LINE.
CONVERT REAL NUMBER TO LOGICAL
@BOX 1.1
@BOX 1.2
@BOX 2.1
(INT) => FP;
0 => PPOS
$IF ISYM ='. $TH
$WH VALCODE[NEXTCH()=>ISYM] = 126 $DO
FP * (TEN) + (XSYM() - '0) => FP;
1 -> PPOS $OD
$FI
@BOX 2.2
FP = (INT);
PPOS = 0;
if (ISYM == '.')
{
  while(VALCODE[(ISYM = NEXTCH())] == 126)
  {
    FP = FP * (TEN) + (XSYM() - '0');
    PPOS = 1;
  }
}
@BOX 3.1
$IF ISYM ='@ $TH XSYM();
(IF XSYM()=>ISYM = '- $TH 0 -XINT(0)
$EL XINT(ISYM - '0))+>PPOS
FI
@BOX 3.2
if (ISYM =='@')
{
  XSYM();
  ISYM = XSYM();
  PPOS += (ISYM == '-') ? 0 -XINT(0) : XINT(ISYM - '0');
}
@BOX 4.1
TEN => POWERS;
IF PPOS < 0 THEN 1 => J; 0 -:> PPOS;
ELSE 0 => J FI
$WH PPOS /= 0 DO
IF PPOS & 1 /= 0 THEN
IF J = 0 THEN
POWERS *> FP;
ELSE POWERS /> FP;
FI FI
PPOS ->> 1 => PPOS;
POWERS *> POWERS;
$OD
@BOX 4.2
POWERS = TEN;
if (PPOS < 0)
{
  J = 1;
  PPOS = -(int)PPOS;
}
else
{
  J = 0;
}
while (PPOS != 0)
{
  if ((PPOS & 1) != 0)
  {
    if (J == 0)
	{
	  FP *= 10;
	}
	else
	{
	  FP /= 10;
	}
  }
  PPOS = PPOS >> 1;
  POWERS *= POWERS;
}
@BOX 5.1
IF LBUFF[IPTR] = UMINUS $TH
ZERO -:>FP;
1->IPTR
FI
FP => L64;
0 => CTYPE;
@BOX 5.2
if (memcmp(&LBUFF[IPTR], &UMINUS, sizeof(ITYPE))==0)
{
  FP = -FP;
  IPTR--;
}
L64 = (t_uint64)FP;
CTYPE = 0;
@END

