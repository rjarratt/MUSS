*INFORM %FF00;
*TLSEG 0 %FFFF %80040000 0 6;
*TLSEG 1 %FFFF %80000000 0 6;
*TLLOAD 1 5;
*GLOBAL 5;
::*CODE 1;
*VTYPE LOGICAL64;

PSPEC PRINT.STRING(ADDR[LOGICAL8]);

MODULE (CONSOLE.INTERRUPT, TELETYPE.DATA,TELETYPE.CONTROL,A.LITERAL,V.ACCESS,ACCESS.DATA);
VSTORE CONSOLE.INTERRUPT %300;
VSTORE TELETYPE.DATA %306;
VSTORE TELETYPE.CONTROL %307;
LOGICAL64 FILL; :: Used to make sure that we don't just alias the VSTORE backing variable to offset 0
LOGICAL64 PSEUDO.ACCESS;
LOGICAL64 ACCESS.DATA;
VSTORE V.ACCESS PSEUDO.ACCESS <V.ACCESS.READ >V.ACCESS.WRITE;

LITERAL / INTEGER A.LITERAL = 32;

PSPEC HANDLE.INTERRUPT.0();
PSPEC HANDLE.INTERRUPT.1();
PSPEC HANDLE.INTERRUPT.2();
PSPEC HANDLE.INTERRUPT.3();
PSPEC HANDLE.INTERRUPT.4();
PSPEC HANDLE.INTERRUPT.5();
PSPEC HANDLE.INTERRUPT.6();
PSPEC HANDLE.INTERRUPT.7();

:: The interrupt vectors start after the 16th word in segment 8192
DATAVEC PAD (LOGICAL64)
0[13] :: three variables above for V-Store access testing use up some of the space
END;

DATAVEC VECTORS(INTEGER)
0 0 %001D0000 %40020000
0 0 %001D0000 %40020002
0 0 %001D0000 %40020004
0 0 %001D0000 %40020006
0 0 %001E0000 %40020008
0 0 %001E0000 %4002000A
0 0 %001E0000 %4002000C
0 0 %001E0000 %4002000E
END;

*CODE 1;

-> DISPATCH.INTERRUPT.0;
-> DISPATCH.INTERRUPT.1;
-> DISPATCH.INTERRUPT.2;
-> DISPATCH.INTERRUPT.3;
-> DISPATCH.INTERRUPT.4;
-> DISPATCH.INTERRUPT.5;
-> DISPATCH.INTERRUPT.6;
-> DISPATCH.INTERRUPT.7;

DISPATCH.INTERRUPT.0:
*#%F9 %10  :: EXIT VV/0 10

DISPATCH.INTERRUPT.1:
*#%F9 %12  :: EXIT VV/0 12

DISPATCH.INTERRUPT.2:
*#%F9 %14  :: EXIT VV/0 14

DISPATCH.INTERRUPT.3:
*#%F9 %16  :: EXIT VV/0 16

DISPATCH.INTERRUPT.4:
*#%F9 %18  :: EXIT VV/0 18

DISPATCH.INTERRUPT.5:
*#%F9 %1A  :: EXIT VV/0 1A

DISPATCH.INTERRUPT.6:
*#%F9 %1C  :: EXIT VV/0 1C

DISPATCH.INTERRUPT.7:
*#%F9 %1E  :: EXIT VV/0 1E

PROC V.ACCESS.READ;
ACCESS.DATA => PSEUDO.ACCESS;
END

PROC V.ACCESS.WRITE;
PSEUDO.ACCESS => ACCESS.DATA;
END

*END
